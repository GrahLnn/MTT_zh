# MTT 注

"Judgment"在类型理论中通常指的是一个形式系统中的基本断言或声明，这些断言或声明不能被证明或推导，而是被视为基本的、自明的真理。例如，我们可能会有一个"judgment"，声明某个表达式是某个类型的成员。

而"assertion"通常指的是一个可以被证明或推导的声明。在一个形式系统中，我们可以从一组基本的"judgments"出发，通过应用一系列推理规则来得到新的"assertions"。

---

在语言学中，"coordination"（协同或并列）是一种句法关系，其中两个或更多的词、短语或句子被并列在一起，通常通过并列连词（如"and"、"or"和"but"）连接。例如，在句子"Bob and Alice are friends"中，"Bob"和"Alice"就是通过并列关系连接在一起的。

---

"Many-sorted"和"multi-sorted"在逻辑和计算机科学中通常是同义词，都用来描述一个包含多种类型或类别的对象的系统或领域。这两个术语在英语中都被用来描述这种概念，选择哪个术语主要取决于个人偏好或特定的学术或技术传统。

---

"多元排序域"（multi-sorted domain）是逻辑和语义学中的一个概念，用于描述一个包含多种不同类型或"排序"的对象的集合。在这个上下文中，"排序"可以被理解为对象的种类或类型。

例如，我们可以考虑一个多元排序的领域，其中包含人、动物和物体。在这个领域中，"人"、"动物"和"物体"都是不同的排序，每种排序都有其特定的结构属性。

在语言学的语义研究中，多元排序的系统或领域被用来模拟和理解语言如何引用和处理不同类型的对象。例如，一个句子可能会引用一个人（"John"），一个动物（"the cat"）和一个物体（"the chair"），这些都是多元排序领域中的不同排序。

---

一个系统（如一个类型系统或一个编程语言）如果满足强正规化性质，那么它的所有表达式都会在有限步骤内规约到一个正规形式，也就是说，它们都会在有限时间内"完成计算"。这是一个非常重要的性质，因为它保证了系统的计算不会无限制地进行下去。

---

在类型理论中，"membership entries"通常指的是签名（signature）中的元素，这些元素声明了某个变量属于某个特定的类型。例如，一个membership entry可能是形式为"x: A"的声明，这表示变量x是类型A的成员。

在这段文本中，作者提到他们将介绍一种新的签名，这种签名不仅包含常规的membership entries，还包含两种新形式的条目：子类型条目和manifest条目。这些新形式的条目增强了签名在表示（不完全的）可能世界中的能力，即使在情况无限或涉及更复杂现象的情况下。

总的来说，membership entries是类型理论中用于描述变量和其类型关系的一种工具，它们是定义类型系统结构的关键部分。

---

"notion of signatures"可能是指在类型理论中的一个概念，用于描述类型系统的结构。在类型理论中，一个签名（signature）定义了一组类型和操作，以及这些操作在给定类型上的行为。

例如，一个签名可能会定义一个数字类型，以及一些在数字上进行的操作，如加法和乘法。这个签名会规定加法和乘法的类型，例如，它们接受两个数字作为输入，并返回一个数字作为输出。

---

在语义学和哲学中，"可能世界"是一种理论工具，用于描述和分析语句的可能性和必然性。一个可能的世界就是一种可能的现实，一种事情可能发生的方式。例如，有一个可能的世界，在那里你正在阅读这个句子；有另一个可能的世界，你没有阅读这个句子。

当我们说一个"不完全的可能世界"时，我们是指一个可能的世界，其中并非所有的事实都被明确指定。换句话说，这是一个部分指定的可能世界，其中一些事实是确定的，而其他事实则是开放的。

"可能世界"的概念主要用于逻辑和语义学，用于分析语句的可能性和必然性。一个可能的世界是一种可能的现实，一种事情可能发生的方式。

相反，"平行世界"或"多元宇宙"的概念主要在物理学和科幻文学中使用，用于描述可能存在的其他宇宙或现实，这些宇宙或现实与我们的宇宙并行存在，但可能有不同的物理定律或历史。

---

"Logical modal collection operator"在这里可能是指在类型理论中用于处理非承诺修饰（non-committal modification）的一种操作符。在语义学中，非承诺修饰是一种修饰方式，其中修饰词并不确切地改变名词的含义，而是提供了一种可能的解释或视角。

例如，考虑句子"可能的赢家"。在这里，"可能的"是一个非承诺修饰词，因为它并没有改变"赢家"的基本含义，而是提供了一种可能的解释或视角。

在类型理论中，这种修饰可能通过引入一个逻辑模态集合操作符来处理。这个操作符可能会创建一个新的类型，该类型表示所有可能满足修饰词条件的实体的集合。然后，这个新类型可以用于进一步的语义构造。

---

1. **证明论规则的应用**：MTT是通过证明论规则来定义的。证明论是一种逻辑学分支，它关注的是逻辑推理的形式，而不仅仅是逻辑语句的真假。因此，MTT可以通过其推理使用方式在证明论的意义上理解其判断（句子）。
2. **基础语义语言的理解**：MTT提供了一种新的可能性，即我们可以通过其证明论的含义理论来理解MTT作为基础语义语言。这是之前的集合论语义无法做到的。
3. **计算机实现**：由于MTT是基于证明论定义的，因此它们可以轻松地在计算机上实现，以支持自然语言中的计算机辅助推理。这得到了基于MTT的证明助手提供的当前证明技术的支持。
4. **自然语言推理任务**：作者提到，他们将描述如何在计算机上实现MTT语义以执行自然语言中的推理任务。这意味着MTT可以用于处理和理解自然语言，这对于计算语言学和人工智能领域非常重要。

---

这些公式来自于类型理论，它们是用来定义一个有效的类型环境（也称为上下文）的规则。类型环境是一个变量到类型的映射，它为类型检查和类型推导提供了必要的上下文。

这里有三个规则：

1. **空规则**：空序列（表示为`⟨⟩`）是一个有效的类型环境。这是最基本的规则，表示没有任何变量的情况是有效的。
2. **变量添加规则**：如果在类型环境`Γ`中，`A`是一个类型，并且变量`x`不在`Γ`的自由变量集合`FV(Γ)`中，那么在`Γ`中添加一个新的变量到类型的映射`x: A`是有效的。这个规则表示，我们可以在类型环境中添加新的变量，只要这个变量之前没有被使用过。
3. **命题添加规则**：如果在类型环境`Γ`中，`P`是一个命题并且它是真的（表示为`t`），那么在`Γ`中添加一个新的命题`P`是有效的。这个规则表示，我们可以在类型环境中添加新的真命题。

`FV(Γ)`是`Γ`中的自由变量集合，它有三个定义：

1. `FV(⟨⟩) = ∅`：空序列的自由变量集合是空集。
2. `FV(Γ, x: A) = FV(Γ) ∪ {x}`：如果在类型环境`Γ`中添加一个新的变量到类型的映射`x: A`，那么新的自由变量集合是原来的自由变量集合加上新的变量`x`。
3. `FV(Γ, P true) = FV(Γ)`：如果在类型环境`Γ`中添加一个新的真命题`P`，那么自由变量集合不变。

这些规则和定义是类型理论中的基础概念，它们用于定义和操作类型环境，以进行类型检查和类型推导。

---

在蒙塔古语义学中，`talk: e -> t`是一个函数的类型签名，它表示`talk`是一个从实体（`e`）到真值（`t`）的函数。

这里的`e`代表实体类型，通常用来表示自然语言中的名词或名词短语，如人、地点或事物。`t`代表真值类型，通常用来表示一个陈述的真假。

因此，`talk: e -> t`可以理解为一个描述某个实体是否在"talk"（谈话）的函数。例如，如果我们有一个实体`John`，那么`talk(John)`就会返回一个真值，表示John是否在谈话。这是蒙塔古语义学用来描述自然语言中动词的一种方式。

---

$$
\exists x: \mathbf{e} . \operatorname{man}(x) \wedge \operatorname{talk}(x)
$$

这个表达式来自于逻辑和类型理论，它表示的是一个存在量化的陈述。

`∃x: e . man(x) ∧ talk(x)`可以被理解为："存在一个实体`x`，使得`x`是一个人（`man(x)`）并且`x`正在谈话（`talk(x)`）"。

这里的`∃x: e`是一个存在量词，表示存在一个类型为`e`（实体）的`x`。`.`之后的部分是这个`x`需要满足的条件，即`x`是一个人并且`x`正在谈话。`∧`是逻辑与操作符，表示两个条件都需要满足。

这种表达方式常常用于形式语义学和逻辑编程中，用来精确地描述复杂的自然语言陈述。

在逻辑和类型理论中，`.`通常被用作分隔符，用来分隔量词（如`∃x: e`）和量词作用的范围（如`man(x) ∧ talk(x)`）。

所以，`∃x: e . man(x) ∧ talk(x)`应该被理解为："存在一个类型为`e`的`x`，使得`man(x) ∧ talk(x)`成立"。

---

|                          | Type in Montague semantics         | Type in MTT-semantics    |
| ------------------------ | ---------------------------------- | ------------------------ |
| $\text{j}$               | $\mathbf{e}$                       | $Human$                  |
| $\text{talk}$            | $\mathbf{e}\rightarrow \mathbf{t}$ | $Human \rightarrow Prop$ |
| $\operatorname{talk}(j)$ | $\mathbf{t}$                       | $Prop$                   |

这个表格展示了Montague语义学和MTT语义学中的类型对应关系。具体来说，它展示了如何在两种不同的语义框架中表示相同的概念。

1. **j**：在Montague语义学中，`j`被视为一个实体（`e`），而在MTT语义学中，`j`被更具体地视为一个人（Human）。
2. **talk**：在Montague语义学中，`talk`被视为一个从实体到真值的函数（`e -> t`），表示某个实体是否在谈话。而在MTT语义学中，`talk`被视为一个从人到命题的函数（Human -> Prop），表示某个人是否在谈话。
3. **talk(j)**：在Montague语义学中，`talk(j)`是一个真值（`t`），表示实体`j`是否在谈话。而在MTT语义学中，`talk(j)`是一个命题（Prop），表示人`j`是否在谈话。

---

- In MTT-semantics, the sentence (1.7) is interpreted as the proposition $\operatorname{talk}(j)$ : Prop where Prop is the type of all logical propositions - an internal totality that only exists in impredicative type theories such as UTT. 13

"Internal totality"在类型理论中是一个特定的概念，它指的是一个类型的所有可能的值或实例都可以在类型理论的框架内部被明确地定义和处理。这与"external totality"形成对比，后者指的是类型的值或实例可能需要依赖于类型理论框架之外的一些结构或信息。

在你引用的这句话中，"internal totality"是用来描述类型Prop的。Prop是所有逻辑命题的类型，在不可约谓词的类型理论（如UTT）中，它是一个"internal totality"，因为所有的逻辑命题都可以在类型理论的框架内部被定义和处理。

这个概念是理解类型理论，特别是像UTT这样的不可约谓词类型理论的关键。在这样的理论中，所有的类型和值都是"内部的"，这意味着它们都可以在理论的框架内部被完全定义和处理，而不需要依赖于任何外部的结构或信息。

---

In predicative MTTs such as Martin-Löf's type theory, one would use a predicative universe which is only a type of some propositions, not all of them. Although we may relate Prop to the type $\mathbf{t}$ of truth values in Church's simple type theory, they have subtle differences. The differences between MTTs and Church's simple type theory include whether the theory is classical or constructive and whether there are proof objects, among others. These are beyond the scope of our discussions here.

这段话主要在讨论不同类型理论之间的一些区别和细微差异。

1. 在像Martin-Löf类型理论这样的可归谓词MTTs（Modern Type Theories）中，人们会使用一个可归谓词宇宙，它只包含一些命题的类型，而不是所有命题。这与不可归谓词类型理论（如UTT）中的Prop类型有所不同，后者包含所有逻辑命题的类型。
2. 尽管我们可能会将Prop类型与Church简单类型理论中的真值类型`t`相关联，但它们之间存在微妙的差异。例如，MTTs和Church的简单类型理论之间的差异包括理论是经典的还是构造性的，以及是否存在证明对象等。
3. 这些差异超出了这里讨论的范围。也就是说，这些差异的详细讨论和理解可能需要更深入的类型理论知识和背景。

这段话在强调类型理论的多样性和复杂性，以及理解和使用不同类型理论可能需要注意的一些关键区别和细节。

---

"可归谓词"（predicative）和"不可归谓词"（impredicative）是逻辑和数学中用来描述定义或构造的两个术语。

1. **可归谓词**：如果一个定义或构造是可归谓词的，那么它不依赖于自身或更大的整体。换句话说，它的定义是自下而上的，只依赖于已经定义的元素。例如，我们可以定义一个集合是由具有某种性质的所有自然数组成的，这个定义是可归谓词的，因为它只依赖于已经定义的自然数。
2. **不可归谓词**：如果一个定义或构造是不可归谓词的，那么它可能依赖于自身或更大的整体。换句话说，它的定义可能是自上而下的，可能依赖于尚未完全定义的元素。例如，我们可能定义一个集合是由所有不包含自身的集合组成的，这个定义是不可归谓词的，因为它依赖于尚未完全定义的集合。

在类型理论中，这两个概念通常用来描述类型或构造的定义方式。例如，Martin-Löf的类型理论是可归谓词的，因为每个类型都是由更基本的类型构造的。而某些类型理论（如Coq中的类型理论）允许不可归谓词的构造，这使得它们能够表达更复杂的概念，但也可能导致一些逻辑和计算上的困难。

---

在自然语言处理和语言学中，"IV"通常是"Intransitive Verb"的缩写，指的是不需要直接宾语的动词。例如，"talk"、"run"、"sleep"等都是不及物动词，因为你可以只说"he talks"或"she runs"，而不需要添加直接宾语。这与及物动词（Transitive Verb，TV）相对，及物动词需要一个直接宾语，例如"eat"（你不能只说"he eats"，而需要说"he eats an apple"）。

---

A verb (IV) or an adjective (ADJ) can be interpreted as a predicate over a type $D$ that interprets the domain of the verb or adjective, i.e. a function of type $D \rightarrow$ Prop.

这句话的意思是，在现代类型理论（MTT）的语义中，一个动词（Intransitive Verb，IV）或形容词（Adjective，ADJ）可以被解释为一个谓词，这个谓词作用于一个类型D。这个类型D解释了动词或形容词的领域，也就是说，这个谓词是一个类型为"D -> Prop"的函数。

在这里，"D"是一个抽象的类型，它代表了动词或形容词的领域。例如，对于动词"run"，D可能是"Human"，因为"run"的领域是人；对于形容词"red"，D可能是"Object"，因为任何对象都可能是红色的。

所以，这个函数"D -> Prop"的意思是，给定一个类型为D的对象（例如一个人或一个物体），这个函数会返回一个命题（Prop），这个命题表示这个对象是否具有由动词或形容词表示的性质（例如是否在跑，或者是否是红色的）。

---

Modified common nouns (modified $\mathrm{CN}$ ), when the adjectives are intersective, can be interpreted by means of $\Sigma$-types of pairs.

"Modified common nouns"（被修饰的普通名词）是指由形容词、副词或短语修饰的名词。例如，在"red apple"、"quickly running man"或"book on the table"中，"apple"、"man"和"book"都是被修饰的普通名词。

在现代类型理论（MTT）的语义中，当形容词是交集性的（即，形容词描述的性质可以同时应用于多个对象，如"red"、"big"等），被修饰的普通名词可以通过Σ-types来解释。Σ-types，也称为依赖对类型或存在类型，是一种可以表示对象和该对象的性质的配对的类型。例如，Σm: Man. handsome (m)表示的是所有满足"handsome"性质的人的集合。

---

"Dynamic entailment"是动态语义学中的一个概念。在传统的逻辑系统中，"entailment"（蕴含）是一个基本的关系，表示一个命题（或一组命题）的真实性必然导致另一个命题的真实性。例如，在经典逻辑中，如果我们知道"P implies Q"（P蕴含Q）是真的，而且P是真的，那么我们就可以得出Q是真的。

然而，在动态语义学中，这种蕴含关系被重新定义为"dynamic entailment"。在动态蕴含关系中，一个命题的真实性可能会影响到其他命题的解释或真实性。这是因为在动态语义学中，语句的解释不仅取决于当前的语境，还取决于之前的语境和语句。因此，一个语句的真实性可能会改变语境，从而影响到后续语句的解释。

例如，考虑这样一个例子："John walks into a room. He sees a cat." 在这个例子中，第二句"He sees a cat"的解释依赖于第一句"John walks into a room"的解释，因为"he"指代的是"John"。这就是一个动态蕴含的例子：第一句的真实性影响到了第二句的解释。

然而，动态蕴含关系并不满足一些传统蕴含关系的性质，例如反身性（如果P是真的，那么P蕴含P）和传递性（如果P蕴含Q，Q蕴含R，那么P蕴含R）。这是因为在动态语义学中，语境的改变可能会影响到蕴含关系。

---

"Strong"和"Weak"量词是语义学中的概念，用来描述量词的不同类型。

1. "Strong"量词：这类量词在逻辑上有更强的限制性。例如，"all"、"every"、"each"、"none"等都是强量词。当我们说"All dogs bark"时，这个句子的真实性要求每一只狗都会叫。如果存在一只不会叫的狗，那么这个句子就是假的。
2. "Weak"量词：这类量词在逻辑上的限制性较弱。例如，"some"、"a few"、"several"等都是弱量词。当我们说"Some dogs bark"时，这个句子的真实性只要求存在至少一只会叫的狗。即使有很多狗不会叫，只要有一只会叫，这个句子就是真的。

在现代类型理论（MTT）的语义中，强量词和弱量词可以通过不同的方式来解释。例如，强量词可以通过全称量词（∀）来解释，而弱量词可以通过存在量词（∃）或Σ-types来解释。

---

在类型理论中，"type theory with records"（具有记录的类型理论）是一种扩展了基本类型理论的形式，引入了记录类型作为一种新的数据结构。

记录类型允许我们将多个字段组合在一起，以创建复杂的数据结构。每个字段都有一个标签（label）和一个对应的类型。通过使用记录类型，我们可以定义和操作具有不同字段的数据，类似于在编程语言中使用结构体或对象。

在记录类型中，可以进行以下操作：

1. 定义记录类型：通过指定字段的标签和类型，可以定义一个记录类型。例如，可以定义一个人的记录类型，其中包含姓名、年龄和地址字段。
2. 创建记录：可以创建一个具体的记录，为每个字段指定相应的值。例如，可以创建一个名为"John"、年龄为25岁、地址为"123 Main St"的人的记录。
3. 访问记录字段：可以使用字段的标签来访问记录中的特定字段的值。例如，可以通过记录类型中定义的标签"age"来访问人的记录中的年龄字段的值。
4. 更新记录字段：可以通过指定字段的标签和新值来更新记录中的特定字段的值。例如，可以更新人的记录中的地址字段的值为"456 Elm St"。

类型理论中的记录类型提供了一种灵活和强大的数据建模方式，可以用于表示和操作具有复杂结构的数据。它们在编程语言、数据库和形式化验证等领域中都有广泛的应用。

---

It is important to note that a judgment is not a formula in the ordinary sense of logic. In particular, we cannot apply logical operators such as negation and conjunction to judgments. For instance, if we negated the judgment (2.1), the result would not be a judgment anymore: the "negation" of (2.1), often written as $\Gamma \nvdash_{\Delta} a: A$, is not a judgment, but only a meta-level statement saying that the judgment (2.1) is incorrect (or, in a formal jargon, (2.1) is non-derivable). (See section 3.2.3 for further discussions in this respect.) (2.1) $\Gamma \vdash_{\Delta} a: A$

"Non-derivable"在这个上下文中，是指一个判断或公式不能从已知的规则或假设中推导出来。在形式逻辑中，如果一个判断是"derivable"，那么意味着我们可以通过一系列的推理步骤，从一组基本的假设或规则出发，得到这个判断。相反，如果一个判断是"non-derivable"，那么就意味着我们无法通过这样的推理步骤得到它。

在你引用的这段文本中，作者提到，如果我们对判断（2.1）进行否定，那么结果将不再是一个判断：（2.1）的"否定"，通常写作$\Gamma \nvdash_{\Delta} a: A$，不是一个判断，而只是一个元层面的声明，表示判断（2.1）是不正确的（或者用形式术语来说，（2.1）是"non-derivable"的）。这意味着我们不能从已知的规则或假设中推导出判断（2.1）。

在这个上下文中，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个元层面（meta-level）的声明。这个声明表示，我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$。也就是说，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个对 judgment $\Gamma \vdash_{\Delta} a: A$ 的否定或反驳。

这里的关键是，judgment 是类型理论中的基本断言或声明，而我们不能对这些基本断言应用逻辑运算符，如否定和合取。因此，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个新的 judgment，而是一个元层面的声明，表示我们不能从已知的规则或假设中推导出原来的 judgment。

在形式逻辑和类型理论中，$\vdash$ 符号通常用来表示"可推导"或"可证明"。例如，$\Gamma \vdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们可以推导出 $a$ 是类型 $A$ 的。

当我们在 $\vdash$ 符号前加上否定符号 $\nvdash$，这就变成了表示"不可推导"或"不可证明"的符号。因此，$\Gamma \nvdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们不能推导出 $a$ 是类型 $A$ 的。

这就是为什么 $\Gamma \nvdash_{\Delta} a: A$ 这个声明表示我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$ 的原因。这是对原始判断的否定，但这个否定本身并不构成一个新的判断，而是一个元层面的声明。

> 因为一个judgment必须使用 $\vdash$才是judgment，而当变成否定形式后则不是一个judgment，而只能是一种声明，如果将否定形式也当作judgment那么任意一种非当前$\Gamma$都能因为$\nvdash$而成为一个judgment，那么judgment就没意义了对吗

是的，你的理解是正确的。在类型理论中，judgment 是一种基本的断言或声明，它描述了某种事实或关系，如 "$a$ 是类型 $A$ 的"。这些断言是可以被证明或推导出的，这就是为什么我们使用 $\vdash$ 符号来表示它们。

当我们对一个 judgment 进行否定，我们实际上是在说这个 judgment 是不正确的，或者说我们不能从已知的规则或假设中推导出这个 judgment。这种否定本身并不构成一个新的 judgment，因为它并不描述一个可以被证明或推导出的事实或关系。相反，那它是一个元层面的声明，表示我们不能证明或推导出原来的 judgment。

如果我们允许否定形式也成为 judgment，那么我们就会面临你所描述的问题：任何非当前的 $\Gamma$ 都可以因为 $\nvdash$ 而成为一个 judgment，这将使得 judgment 的概念失去意义。因此，我们只将那些可以被证明或推导出的断言视为 judgment，而将否定形式视为元层面的声明。

在类型理论中，"语境"（context）通常指的是一组变量和它们的类型。这些变量和类型为我们提供了一种环境或背景，我们可以在这个环境中进行推理和证明。

例如，如果我们有一个语境 $\Gamma = {x: A, y: B}$，那么我们可以在这个语境中推导出一些 judgment，如 "$x$ 是类型 $A$ 的" 或 "$y$ 是类型 $B$ 的"。这些 judgment 是在给定的语境 $\Gamma$ 下成立的。

因此，你可以把语境看作是一种前提条件。它为我们提供了一种环境，我们可以在这个环境中进行推理和证明。

---

语境（context）和签名（signature），并对它们在类型理论中的应用进行了比较。

1. 传统的语境概念已经被Ranta等人用来表示情境，但在这种表示中，变量和常量之间的区别并未被考虑。
2. 作者提出，他们考虑的是声明常量的签名，而不是声明变量的语境。他们的签名可能包含其他形式的条目，这些条目允许以灵活的方式表示复杂的情境，比如无限的情境。
3. 然而，将这些新形式的条目添加到语境中并不容易：特别是，其元理论研究相当复杂，一直是一个困难的未解问题。相反，将它们作为签名中的条目添加起来更容易。
4. 签名的概念首次在爱丁堡逻辑框架的发展中被引入到类型理论中，其签名只包含成员条目。在本节中，我们将仅使用成员条目，并在后面研究包含新形式条目的扩展签名。

简单来说，这段文字主要讨论了如何更好地在类型理论中表示和处理复杂的情境，特别是无限的情境。作者提出，使用签名（特别是包含新形式条目的签名）比使用传统的语境更为灵活和有效。

---

这段文字进一步解释了签名（signature）和上下文（context）之间的区别，以及它们在类型理论中的作用。

1. 签名（Signature）和上下文（Context）都是一系列的条目（entries），这些条目都在推理过程中起作用。然而，它们的条目类型和作用有所不同。签名中的条目（例如$c: A$）声明了$c$是类型$A$的一个常量对象，而上下文中的条目（例如$x: A$）声明了$x$是一个可以被抽象的变量，比如可以被量化。签名中声明的常量不能被抽象，这就是它们被称为常量的原因。
2. 作者认为，签名更适合于表示语言学意义上的情境（situations），而上下文则不适合。这是因为在表示情境时，我们通常关注的是特定的值（即常量），而不是可能变化的值（即变量）。
3. 在公式(2.6)中，作者给出了包含上下文和签名的判断（judgment）的一般形式。在这个形式中，签名只包含成员条目（membership entries）。这种形式的判断可以表示为：在上下文$x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n}$和签名$c_{1}: A_{1}^{\prime}, c_{2}: A_{2}^{\prime}, \ldots, c_{n}: A_{n}^{\prime}$下，$a$是类型$A$的一个对象。
4. 作者提到，他们将在后面正式介绍签名。但在这里，他们给出了一个例子，展示了如何使用只包含传统成员条目的签名来表示情境。

总的来说，这段文字主要讨论了类型理论中的两个重要概念：上下文和签名，以及它们在表示和处理情境时的作用和区别。

---

在类型理论中，依赖类型（Dependent Type）是一种类型，它的定义依赖于某个值。例如，在上述例子中，我们有一个类型家族 $C h i l d(x)$，其中 Child $(x)$ 是每个 $x : Human$ 的孩子的类型，这里的 Human 是人类的类型。然后，$\Pi x :Human.Child (x)$ 是依赖函数的类型 $f$，对于任何 $h:$ Human，$f(h)$ 是类型 Child $(h)$ - $h$ 的一个孩子。

这里的关键是，函数 $f$ 的输出类型（即 $f(a)$ 的类型 $B(a)$）依赖于输入 $a$。这就使得 $\Pi$-类型成为了依赖类型。换句话说，依赖类型允许我们根据输入的值来改变输出的类型，这在传统的函数类型中是不可能的。

$\Pi x :Human.Child (x)$ 这个表达式表示的是所有从 Human 类型到 Child 类型的依赖函数的类型。这里的 Child 类型是依赖于 Human 类型的，因为 Child(x) 的类型取决于 x 的值。

具体来说，如果你有一个函数 f，它的类型是 $\Pi x :Human.Child (x)$，那么这意味着对于任何人 h（即，对于所有 h:Human），f(h) 是 h 的一个孩子，类型为 Child(h)。换句话说，f 是一个函数，它接受一个人作为输入，并返回这个人的一个孩子作为输出。输出的类型（即孩子的类型）依赖于输入的值（即父母的身份）。

---

$$
(Abs)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B}{\Gamma \vdash_{\Delta} \lambda x: A . b: \Pi x: A . B}
$$

在这里，"Abs" 是 "Abstraction" 的缩写，表示抽象。这是 $\lambda$ 演算中的一个基本概念，用于创建匿名函数（也就是没有名字的函数）。在这个规则中，如果在增加了变量 $x: A$ 的上下文 $\Gamma$ 下，我们可以推导出 $b: B$，那么在上下文 $\Gamma$ 下，我们可以定义一个函数 $\lambda x: A . b$，其类型为 $\Pi x: A . B$。这个函数接受一个类型为 $A$ 的输入 $x$，并返回 $b$，$b$ 的类型是 $B$。

在这里，$\lambda x: A . b$ 表示一个函数，它接受一个类型为 $A$ 的输入 $x$，并返回 $b$。这是 λ-演算中的一种表示法，也被称为 λ-抽象。这个函数是匿名的，也就是说，它没有具体的名字。

$\lambda x: A . b$ 可以被理解为 "一个函数，它接受一个类型为 $A$ 的输入 $x$，并返回 $b$". 这里的 $b$ 是一个表达式，它可能依赖于 $x$。例如，如果 $b$ 是 $x + 2$，那么 $\lambda x: A . b$ 就表示一个函数，它接受一个输入 $x$，并返回 $x + 2$。

---

$$
(App)\qquad\frac{\Gamma \vdash_{\Delta} f: \Pi x: A . B\quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta} f(a):[a / x] B}
$$

在这里，"application" 是函数应用的意思。在函数式编程和 λ-演算中，函数应用是一个基本操作，表示将函数应用到一个或多个参数上。

在这个规则中，$f: \Pi x: A . B$ 是一个函数，$a: A$ 是一个参数，$f(a)$ 就是将函数 $f$ 应用到参数 $a$ 上。$[a / x] B$ 表示将 $B$ 中所有自由出现的 $x$ 替换为 $a$，这就是函数应用的结果的类型。

例如，如果我们有一个函数 $f: \Pi x: \text{Int} . \text{Int}$，表示 $f$ 是一个接受整数输入并返回整数的函数，那么如果我们有一个整数 $a: \text{Int}$，那么 $f(a)$ 就是将函数 $f$ 应用到整数 $a$ 上，结果也是一个整数。

---

$$
(\beta)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B \quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta}(\lambda x: A . b)(a)=[a / x] b:[a / x] B}
$$

这是 λ-演算中的一个基本规则，称为β-规约。β-规约描述了函数应用的行为：当一个函数 $\lambda x: A . b$ 应用于一个参数 $a$ 时，结果是将函数体 $b$ 中所有自由出现的 $x$ 替换为 $a$。

在这个规则中，$\Gamma, x: A \vdash_{\Delta} b: B$ 表示在给定 $x: A$ 的情况下，$b$ 是类型 $B$ 的一个项。$\Gamma \vdash_{\Delta} a: A$ 表示 $a$ 是类型 $A$ 的一个项。然后，规则的结论是 $(\lambda x: A . b)(a)=[a / x] b:[a / x] B$，表示将函数 $\lambda x: A . b$ 应用于 $a$ 的结果是将 $b$ 中所有自由出现的 $x$ 替换为 $a$，并且结果的类型是 $[a / x] B$，即将 $B$ 中所有自由出现的 $x$ 替换为 $a$。

例如，如果我们有一个函数 $\lambda x: \text{Int} . x + 1$，那么应用这个函数到整数 $2$ 上，即 $(\lambda x: \text{Int} . x + 1)(2)$，根据β-规约，结果是将函数体 $x + 1$ 中的 $x$ 替换为 $2$，得到 $2 + 1$，即 $3$。

---

> 请注意，如上所述，假设 $x: A$，那么lambda表达式的主体 $b$ 的类型就是 $B$ ，而 $b$ 和 $B$ 可能都依赖于 $x$（即，$x$ 可能在它们中出现自由）- 这就是类型依赖。关于 $\Pi$ 类型的上述推理规则也可以在附录A2.1中找到。

在计算机科学和数学中，"free" 是一个术语，用来描述在某个表达式或公式中的变量，这些变量没有被绑定到特定的值或表达式。在这个上下文中，如果 $x$ 在 $b$ 或 $B$ 中自由出现，那么意味着 $x$ 在 $b$ 或 $B$ 中的出现并没有被某个特定的值或表达式所绑定。

例如，考虑一个函数定义 $\lambda x . x + y$。在这个函数体中，$x$ 是一个绑定变量，因为它被 $\lambda$ 表达式所绑定。然而，$y$ 是一个自由变量，因为它在函数体中出现，但并没有被绑定到任何特定的值。这就意味着，如果我们想要计算这个函数的值，我们需要知道 $y$ 的值。

在这个段落中，当说 $b$ 和 $B$ 可能依赖于 $x$ 时，意思是 $x$ 可能在 $b$ 或 $B$ 中自由出现，即 $b$ 或 $B$ 的值可能取决于 $x$ 的值。

---

> To explain in terms of the above example, when a function $f$ of type $\Pi x$ : Human. Child $(x)$ ) (or, $\Pi$ (Human, Child) in another notation) is applied to a human $h$, its image $f(h)$ has to be a child of $h$, i.e. of type Child $(h)$, not something else.

在这个上下文中，"image" 是数学术语，指的是函数作用于其定义域中的元素后得到的结果。换句话说，如果你有一个函数 $f$，并且你将它应用于某个元素 $x$，那么 $f(x)$ 就是 $x$ 在函数 $f$ 下的像（image）。这个术语来自于函数映射的概念，即函数将其定义域中的每个元素 "映射" 到其值域中的某个元素。

在你提供的这段文本中，当函数 $f$（类型为 $\Pi x$ : Human. Child $(x)$）应用于一个人 $h$ 时，它的像 $f(h)$ 必须是 $h$ 的一个孩子，即类型为 Child $(h)$，而不是其他的什么。

---

> 非依赖对的平庸乘积类型 $A \times B$ 是依赖的 $\Sigma$ 类型的一个特例。例如，如果 $Woman$ 是女性的类型，那么乘积类型 $Man\times Woman$ 就是普通对 $(m, w)$ 的类型，使得 $m: M a n$ 和 $w: W o m a n$。乘积类型 $Man \times Woman$ 与 $\Sigma$ 类型 $\Sigma x: Man. W(x)$ 是相同的，其中类型的常数族 $W(x)= Woman$。

"Ordinary product"在这里指的是非依赖性的乘积类型。在类型理论中，乘积类型（也称为元组类型或对类型）是一种复合类型，它的值是两个类型值的对。例如，如果A和B是类型，那么A×B就是乘积类型，它的值是形如(a, b)的对，其中a是A的值，b是B的值。

当我们说"ordinary product"时，我们是在区分它和依赖性乘积类型（在这个上下文中，是Σ类型）。依赖性乘积类型是一种更一般的乘积类型，它的第二个组成部分可以依赖于第一个组成部分的值。在你的例子中，Σx: Man. W(x)就是一个依赖性乘积类型，因为W(x)（即Woman）是依赖于x的类型。

所以，当我们说Man × Woman是一个"ordinary product"时，我们的意思是，它是一个非依赖性的乘积类型，它的值是形如(m, w)的对，其中m是Man的值，w是Woman的值，而且w的类型（Woman）并不依赖于m的值。

"Constant family"是指一个类型族，其中每个类型都是相同的，不依赖于索引。在类型理论中，类型族是一种类型的集合，其中每个类型都与一个或多个索引值相关联。例如，我们可以有一个类型族，其中每个自然数n都有一个对应的类型，如"长度为n的整数列表"。

然而，如果我们有一个"constant family"，那么每个索引值都关联到相同的类型。在你的例子中，"W(x) = Woman"就是一个常数族，因为无论x的值是什么（在这种情况下，x是Man的一个值），W(x)的类型都是Woman。换句话说，这个类型族是"常数的"，因为它不依赖于索引x。

---

> In general, $\Sigma$-types can be regarded as types of tuples since their formation can be nested. A nested $\Sigma$-type $\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$ can be written by means of the following notation and, intuitively, its objects are $n$-tuples of terms of the respective types.  $\left\{\begin{array}{lll} x_{1} & : & A_{1} \\ x_{2} & : & A_{2} \\ \cdots & & \\ x_{n} & : & A_{n} \end{array}\right\}$

在这个例子中，$\Sigma$-类型被视为元组的类型，因为它们的形成可以是嵌套的。这里的嵌套$\Sigma$-类型$\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$可以被写成这样的形式，直观上，它的对象是各自类型的$n$元组。

这个表示法的意思是，我们有一个$n$元组，其中每个元素$x_i$都有一个对应的类型$A_i$。这个表示法省略了$\Sigma$符号，因为它的目的是强调这个类型的元素是元组，而不是强调这个类型是通过$\Sigma$类型构造的。

在这个表示法中，$\Sigma$符号被省略了，因为这个表示法的目的是强调元组的结构，而不是$\Sigma$类型的结构。这个表示法是一种方便的方式，用来描述一个类型的元素是如何组织成元组的。

这个嵌套的$\Sigma$-类型$\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$可以被视为元组$(x_1, (x_2, ..., (x_{n-1}, x_n)...))$的类型，其中每个$x_i$都有对应的类型$A_i$。这种表示方式强调了元组的结构，即元素的顺序和层级关系。

---

> Note that Prop is an impredicative universe because we can quantify over Prop itself (or even "larger" types) to form logical propositions in Prop. For example, $\forall X$ : Prop. $X$ is of type Prop and, in fact, this proposition can serve as the false formula since it intuitively means that every proposition is provable (and by logical consistency, this is not the case and, hence, the formula is not provable).

括号中的注释是在解释为什么公式 $\forall X : Prop$ . $X$ 可以被视为 "假" 公式。这个公式的意思是 "对于所有的命题 X，X 是可证明的"。然而，根据逻辑一致性原则，我们知道并非所有的命题都是可证明的。有些命题是假的，因此不能被证明。因此，公式 $\forall X$ : Prop. $X$ 本身就是不可证明的，因此可以被视为 "假" 公式。

---

> REMARK.- As the reader may have noticed, the universally quantified proposition $\forall x: A . P(x)$ is very similar to a П-type. Their difference is that $\forall$-formation can be impredicative, while $\Pi$-formation is always predicative in the sense that we cannot use $\Pi$ for impredicative quantification. In some type theories, one actually overloads $\Pi$ to allow it to express $\forall$ as well: that is, in those type theories such as ECC (Luo 1994) and Coq's type theory (Coq 2010), $\forall x: A . P(x)$ is also written as $\Pi x: A . P(x)$.

这段话主要在讨论全称量词 $\forall$ 和 Π 类型之间的相似性和差异。

首先，作者指出全称量词 $\forall x: A . P(x)$ 和 Π 类型在形式上非常相似。这两者都表示了对于所有的 $x$ 属于类型 $A$，有某个性质 $P(x)$ 成立。

然后，作者指出这两者的主要区别在于，全称量词 $\forall$ 可以是不可约化的（impredicative），而 Π 类型则总是可约化的（predicative）。这里的 "可约化" 和 "不可约化" 是指在定义类型或性质时，是否可以引用到包含自身的更大的类型或集合。如果可以，那么就是不可约化的；如果不可以，那么就是可约化的。

最后，作者提到在一些类型理论中，例如 ECC（Luo 1994）和 Coq 的类型理论（Coq 2010），允许使用 Π 来表示全称量词 $\forall$。也就是说，这些理论中的 $\forall x: A . P(x)$ 也可以写作 $\Pi x: A . P(x)$。这种情况下，Π 类型被 "重载" 了，它既可以表示 Π 类型，也可以表示全称量词。

"可约化"（predicative）和"不可约化"（impredicative）是逻辑和类型理论中的概念，主要用来描述定义的自指性质。

在可约化（predicative）的定义中，我们不能引用到包含定义自身的更大的类型或集合。例如，我们可以定义一个集合，它包含所有的自然数。这个定义是可约化的，因为在定义这个集合时，我们并没有引用到包含这个集合本身的更大的集合。

相反，在不可约化（impredicative）的定义中，我们可以引用到包含定义自身的更大的类型或集合。例如，我们定义一个集合，它包含所有不包含自身的集合。这个定义是不可约化的，因为在定义这个集合时，我们引用了包含这个集合本身的更大的集合（即所有的集合）。

这个概念在类型理论和逻辑中非常重要，因为它关系到定义的合理性和一致性。在某些类型理论和逻辑系统中，不可约化的定义可能会导致悖论，因此被禁止。

---

> Each universe $U_{i}$ contains names of the types in the universe and $T_{i}$ is the function that maps a name to the named type. For instance, for each $U_{i}$, we introduce a name $u_{i}$ in $U_{i+1}$ and $u_{i}$ is a name of $U_{i}$ because $T_{i+1}\left(u_{i}\right)=U_{i}$. Furthermore, (a name of) each type in $U_{i}$ is lifted to the higher universe $U_{i+1}$ by introducing lifting operators $t_{i+1}(i \in \omega)$

在类型理论中，"宇宙"（Universe）是一种特殊的类型，它的成员本身也是类型。这种结构允许我们在类型理论中谈论和操作类型。这是一种处理类型的元理论（metatheory）问题的方式，比如允许我们定义取决于类型的函数。

在你引用的段落中，每个宇宙 $U_{i}$ 包含了它所包含的类型的名称，而 $T_{i}$ 是一个函数，它将一个名称映射到被命名的类型。例如，对于每个 $U_{i}$，我们在 $U_{i+1}$ 中引入一个名称 $u_{i}$，并且 $u_{i}$ 是 $U_{i}$ 的一个名称，因为 $T_{i+1}(u_{i}) = U_{i}$。此外，$U_{i}$ 中每个类型的名称都被提升到更高的宇宙 $U_{i+1}$，通过引入提升操作符 $t_{i+1}(i \in \omega)$。

这里的 "提升" 是指将类型从一个宇宙转移到另一个更大的宇宙。这是一种处理类型的层次结构的方式，允许我们在不同的 "级别" 上操作类型。

---

> 在签名中可以声明强制子类型化条目。正式来说，系统 $\mathrm{LF}_{\Delta}$ 通过子类型化的断言形式 $\Gamma \vdash_{\Delta} A \leq_{\kappa} B:\text{Type}$ 和子类型化 $\Gamma \vdash_{\Delta} K \leq_{\kappa} K^{\prime}$ 进行了扩展。通过以下规则，可以在签名中引入子类型化条目：
> $$
> \frac{\vdash_{\Delta} A: \text { Type }\quad \vdash_{\Delta} B: \text { Type }\quad \vdash_{\Delta} \kappa:(A) B}{\Delta, A \leq_{\kappa} B\ \text{ valid}}
> $$
> 在签名中假定的子类型关系是可推导的，如以下规则所反映：
> $$
> \frac{\vdash_{\Delta, A\leq_{\kappa} B, \Delta^{\prime}} \Gamma}{\Gamma \vdash_{\Delta, A \leq_{\kappa} B, \Delta^{\prime}} A \leq_{\kappa} B: \text{Type}}
> $$
> 那么，虽然扩展了带有签名的断言，但是强制子类型化的规则（Luo等人，2012）都是适用的。例如，如果在签名 $\Delta$ 下，可以证明 $A \leq_{\kappa} B$ 和 $B \leq_{\kappa^{\prime}} C$ ，那么我们就可以推导出在 $\Delta$ 下$A \leq_{\kappa^{\prime} \circ \kappa} C$，其中 $\kappa^{\prime} \circ \kappa$ 是 $\kappa$ 和 $\kappa^{\prime}$ 的函数组合[functional composition]。

在数学中，"函数组合"（function composition）是一种操作，它将两个函数连接在一起，形成一个新的函数。给定两个函数 $\kappa$ 和 $\kappa^{\prime}$，它们的组合 $\kappa^{\prime} \circ \kappa$ 是一个新的函数，这个新函数首先应用函数 $\kappa$，然后将结果输入到函数 $\kappa^{\prime}$ 中。

在这个上下文中，$\kappa$ 和 $\kappa^{\prime}$ 是类型转换函数，它们描述了如何从一个类型转换到另一个类型。函数组合 $\kappa^{\prime} \circ \kappa$ 描述了一个复合的类型转换：首先应用 $\kappa$，然后应用 $\kappa^{\prime}$。

例如，假设我们有两个类型转换函数 $\kappa$ 和 $\kappa^{\prime}$，其中 $\kappa$ 将类型 A 转换为类型 B，$\kappa^{\prime}$ 将类型 B 转换为类型 C。那么，函数组合 $\kappa^{\prime} \circ \kappa$ 将描述一个从类型 A 直接转换到类型 C 的过程。

---

> 同样，量词也可以通过在宇宙 $\mathsf{CN}$ 上的 $\Pi$ 多态性进行类型化。以一个简单的例子来说，量词"some"可能通过逻辑量词 $\exists$ 在(3.12)中定义，以 $\mathsf{CN}$ 作为其限定的域，其类型化为(3.13)，如表3.1所示，即与可以应用到任何类型的逻辑量词 $\exists$ 不同，"some"只能解释 $\mathrm{CN}$ 。
>
> (3.12) $\text{some} =\lambda A: \mathsf{CN}\ \lambda P: A \rightarrow Prop. \exists(A, P)$
>
> (3.13) $\text{some} : \Pi A : \mathsf{CN}. (A \rightarrow \operatorname{Prop}) \rightarrow \operatorname{Prop}$

在这个例子中，"some" 被定义为一个函数，这个函数接受两个参数：一个类型 A（在这里，A 是 CN，表示一类事物，如 "man" 或 "table"）和一个谓词 P（这是一个从 A 到 Prop 的函数，表示 A 的某种属性或条件）。

这个函数的定义是通过 lambda 表达式给出的，这是一种在函数式编程中常用的表示匿名函数（即没有名字的函数）的方式。在这个表达式中，"λA: CN" 表示 "对于所有的类型 A 在 CN 中"，"λP: A -> Prop" 表示 "对于所有的谓词 P，它是一个从 A 到 Prop 的函数"。

然后，"∃(A, P)" 表示存在一个 A 类型的对象，它满足谓词 P。所以，整个表达式的意思是 "对于所有的类型 A 和所有的谓词 P，存在一个 A 类型的对象满足 P"，这就是 "some" 的含义：存在某种类型的对象满足某种条件。

在 (3.13) 中，"some" 的类型是 "对于所有的类型 A，从 A 到 Prop 的函数到 Prop"，这表示 "some" 是一个函数，它接受一个类型 A 和一个从 A 到 Prop 的函数，然后返回一个 Prop。这就是说，"some" 是一个量词，它可以应用于一个类型和一个谓词，然后返回一个命题。

---

> As noticed in Chatzikyriakidis and Luo (2017b), employing both types and predicates as representations of CNs would need to assume that they be related as intended: for instance, the CN "man" can be interpreted as both a type $M a n$ and a predicate $\operatorname{man}_{M}: \mathbf{e} \rightarrow \mathbf{t}$. Then, it is unclear how the two interpretations can be related in the intended way, as described as $(*)$ :
>
> $(*)$ For any $x: \mathbf{e}$, $x: Man$ if and only if $\operatorname{man}_{M}(x)$ is true.
>
> Unfortunately, such a requirement $(*)$ does not seem to be achievable (or reasonable to assume) without violating the key necessary properties such as decidability of type-checking in MTTs. One might use a modern type theory as a foundational semantic language but still adopt the CNs-as-predicates paradigm (for example, in DTS - see footnote 27 on p.16); but this would mean that we would lose the advantages of the CNs-as-types paradigm as mentioned above and, actually, we would not need the rich type structure of MTTs at all - the semantics can already be done in the same or similar way as in Montague semantics that uses simple type theory. 

这段话主要在讨论名词短语（CNs）如何在类型理论中被解释。它提到，CNs可以被解释为类型（例如 "man" 可以被解释为一个类型 "Man"）或者谓词（例如 "man" 可以被解释为一个谓词 "man_M"，它是一个从实体到真值的函数）。然后，作者提出了一个问题，即如何在预期的方式下关联这两种解释。他们给出了一个需求 (*)，即对于任何实体 x，x 是 "Man" 类型当且仅当 "man_M(x)" 为真。

然而，作者指出，这样的需求 (*) 似乎无法实现，或者说假设它是合理的会违反类型理论中的一些关键性质，如类型检查的可判定性。作者提到，人们可能会使用现代类型理论作为基础的语义语言，但仍然采用 CNs-as-predicates 的范式（例如，在 DTS 中，见第16页的脚注27）；但这将意味着我们会失去上述 CNs-as-types 范式的优点，实际上，对于这种情形我们根本不需要 MTTs 的丰富类型结构 - 语义可以已经以与 Montague 语义（使用简单类型理论）相同或类似的方式完成。

---

> The subtyping relations (3.30) and (3.31) can be represented by coercive subtyping. If $M a n$ is a constant type, we may assume that there is a constant coercion $m h$ such that Man $\leq_{m h}$ Human. If it is defined as a $\Sigma$-type by Man $=\Sigma x$ :Human.male $(x)$, then Man is a subtype of Human by means of (3.33): the first projection is a coercion from $\Sigma x: A . P(x)$ to $A$ for every type $A$ and predicate $P: A \rightarrow$ Prop . 
>
> (3.30) $Man \leq Human$  (Every man is a human.) 
>
> (3.31) $\Sigma x :Book.heavy (x) \leq Book$  (Every heavy book is a book.) 
>
> (3.32) $( Human \rightarrow Book \rightarrow Prop ) \leq( Man \rightarrow \Sigma x: Book.heavy (x) \rightarrow Prop )$ 
>
> (3.33) $\Sigma x: A . P(x) \leq_{\pi_{1}} A$

在类型理论中，第一投影函数 $\pi_1$ 可以从一个成对的类型（也就是 $\Sigma$ 类型）提取出第一个元素。例如，如果我们有一个类型为 $\Sigma x: A . P(x)$ 的元素，那么我们可以使用 $\pi_1$ 来获取类型为 $A$ 的元素。

在这个上下文中，$\pi_1$ 被用作一种强制子类型（coercion），这是因为它可以将 $\Sigma x: A . P(x)$ 类型的元素 "强制" 转换为 $A$ 类型的元素。这就是为什么 $\Sigma x: A . P(x)$ 被视为 $A$ 的子类型，因为我们可以通过 $\pi_1$ 将其元素转换为 $A$ 类型。

所以，$\pi_1$ 在这里被视为一种强制子类型（coercion），因为它提供了一种从 $\Sigma$ 类型到其第一个元素类型的转换方法。

---

> 同样，厚重的书也是书，这也是由于(3.33)，我们有 $heavy\ book=\Sigma x :Book.heavy (x) \leq Book$ 。子类型关系(3.30)和(3.31)被实现后，公式(3.27-3.29)类型正确且它们分别解释了(3.24-3.26)中的句子。请注意，尽管在强制子类型（coercive subtyping）中可以使用投影子类型关系[projective subtyping relation]（如公式3.33所示），但在传统的包容子类型[subsumptive subtyping]中，这种关系是不可用的。

这句话的意思是，尽管在强制子类型（coercive subtyping）中可以使用投影子类型关系（projective subtyping relation）（如公式3.33所示），但在传统的包容子类型（subsumptive subtyping）中，这种关系是不可用的。

这里的 "投影子类型关系" 指的是使用投影函数（如 $\pi_1$）来从一个更复杂的类型（如 $\Sigma$ 类型）提取出一个子类型。而 "包容子类型" 是指一个类型可以被视为其超类型的子类型，但没有明确的转换或提取过程。

所以，这句话的意思是，虽然在强制子类型中可以使用投影函数来创建子类型关系，但在传统的子类型系统中，这种方法是不可用的。

---

> REMARK.- Because CNs are interpreted as types (e.g. some modified CNs as $\Sigma$-types), a verb may need to have many different types. For example, in the above, "read" would need to have both types in (3.32) so that the semantic interpretations (3.27-3.29) can be well-typed. This is a very basic problem for MTT-semantics and its solution is necessary. It was recognized by Ranta (1994) (pp. 62-64), where it was called the problem of "multiple categorization of verbs", and three possible solutions were considered, but none of them is satisfactory. One of them is closest to ours where the first projection $\pi_{1}$ was employed explicitly - this is one step short of a complete solution. Using coercive subtyping (e.g. employing $\pi_{1}$ as an implicit coercion), we have managed to arrive at a solution to capture the phenomena as intended.

这段话的主要观点是，由于名词短语（CNs）被解释为类型（例如，一些修改过的名词短语被解释为Σ-类型），一个动词可能需要有多种不同的类型。例如，在上文中，"read" 需要具有公式（3.32）中的两种类型，以便语义解释（3.27-3.29）可以被正确地类型化。这是现代类型理论语义学（MTT-semantics）的一个基本问题，需要找到解决方案。

Ranta（1994）在他的作品中（第62-64页）提出了这个问题，称之为"动词的多重分类问题"，并考虑了三种可能的解决方案，但没有一种是令人满意的。其中一种解决方案最接近我们的方法，它显式地使用了第一投影函数 $\pi_{1}$，但这还不是一个完整的解决方案。

通过使用强制子类型（例如，将 $\pi_{1}$ 作为隐式的强制函数），我们设法找到了一个解决方案，以捕捉到预期的现象。

"隐式强制"是一种编程语言的特性，它允许一种类型自动转换为另一种类型。这种转换是隐式的，也就是说，编程语言的编译器或解释器会在需要的时候自动进行这种转换，而无需程序员显式地指定。

在这个上下文中，"隐式强制"是指在类型理论中，当我们有一个类型A和一个子类型B时，我们可以隐式地将类型B的实例强制转换为类型A的实例。这是通过使用一个强制函数（在这个例子中是第一投影函数 $\pi_{1}$）来实现的。这个强制函数定义了如何将子类型的实例转换为父类型的实例。

这种隐式强制的机制允许我们在处理具有复杂类型结构的语言（如自然语言）时，更灵活地处理类型。例如，一个动词可能需要与多种名词短语（每种名词短语可能有不同的类型）一起使用，隐式强制可以使这种情况下的类型处理变得更加简单。

---

> 假设"w"是一个同音异义词 $w_{i}: A_{i}(i=$ $1, \ldots, n$ ) ，如果 $j \neq k$ 则 $A_{j} \neq A_{k}$。让 $\mathbf{1}_{w}$ 表示只有一个对象 $w: \mathbf{1}_{w}$ 的归纳单元类型[inductive unit type]（有关单元类型的形式细节，请参见附录A2.4）。然后，同音词"w"的含义可以表示为强制转换子 $c_{i}: \mathbf{1}_{w} \rightarrow A_{i} (i=1, \ldots, n)$ ，定义如下：
> $$
> c_{i}(w)=w_{i}: A_{i}
> $$

这段话是在描述如何使用强制子类型（coercive subtyping）来处理同形异义词（homonym）的问题。同形异义词是指那些拼写相同但含义不同的词，例如英语中的 "run" 可以表示 "跑步"，也可以表示 "经营"。

假设 "w" 是一个具有不同含义的同形异义词，每个含义用 $w_{i}: A_{i}$ 表示，其中 $i$ 是从 1 到 n 的整数，$A_{j}$ 和 $A_{k}$ 是不同的类型，只有当 $j$ 不等于 $k$ 时。

然后，引入了一个名为 $\mathbf{1}_{w}$ 的单元类型（unit type），它只有一个对象 $w: \mathbf{1}_{w}$。单元类型是一种特殊的类型，它只有一个元素，通常用于表示没有实际信息的情况。

接下来，定义了一系列的强制子类型 $c_{i}: \mathbf{1}_{w} \rightarrow A_{i}$，其中 $i$ 是从 1 到 n 的整数。这些强制子类型的作用是将单元类型 $\mathbf{1}_{w}$ 转换为其他类型 $A_{i}$。具体的转换规则是 $c_{i}(w)=w_{i}: A_{i}$，也就是说，将 $w$ 映射到 $w_{i}$。

通过这种方式，同形异义词 "w" 的不同含义可以通过不同的强制子类型来表示，从而解决了同形异义词的处理问题。

单元类型（Unit Type）是类型理论中的一个基本概念。它是一种特殊的类型，只包含一个元素，通常表示为 "()" 或 "1"。你可以将其视为编程语言中的 "void" 类型或者 "null" 类型，它不包含任何实际的信息。

单元类型并不像基向量那样用于构建空间。基向量是线性代数中的概念，一组基向量可以张成一个向量空间，每个向量都可以表示为基向量的线性组合。而单元类型更像是一个标记或者占位符，它本身并不包含任何信息，但在类型理论的上下文中，它可以用来表示某些特殊的情况，例如一个函数没有返回值，或者一个数据结构没有实际的数据等。

---

> (3.50) $c(h, b)= \begin{cases}\text {write}(h, b) & \text {if } h \text { wrote } b, \\ \operatorname{read}(h, b) & \text {otherwise.}\end{cases}$

式子(3.50)定义了一个强制操作 \(c(h, b)\)，这是一个函数，它接受两个参数：一个人 \(h\) 和一本书 \(b\)。这个函数的输出是一个事件，这个事件是由人 \(h\) 对书 \(b\) 执行的动作。

这个函数的定义是分段的，意味着它的输出取决于输入满足的条件。具体来说，如果人 \(h\) 写了书 \(b\)，那么函数 \(c(h, b)\) 的输出就是事件 "人 \(h\) 写书 \(b\)"。如果人 \(h\) 没有写书 \(b\)，那么函数 \(c(h, b)\) 的输出就是事件 "人 \(h\) 读书 \(b\)"。

这个函数的目的是为了在给定一个人和一本书的情况下，确定一个合适的事件。这个事件可以是写书，也可以是读书，取决于人和书的具体关系。这个函数的定义反映了一种语言强制性，即在给定的上下文中，一本书可以被强制解释为与某个事件相关联。

---

> 有了以上内容，我们现在可以将（3.48）解释为（3.51）（简化形式），其中 $j$ 和 $t$ 分别解释 "Julie" 和 "Tolstoy"，而 $\Sigma b: Book.long (b)$ 是解释"长篇书[long book]"的 $\Sigma$-类型。在强制子类型中，（3.51）被强制转换并等同于（3.52），它在插入（3.49）中指定的强制转换后，变成了（3.53）。 
>
> (3.51)  $$ \begin{align} &\ \ \operatorname{start}(j, W \& P)\\ &\wedge \operatorname{finish}(t, W \& P)\\ &\wedge \neg \operatorname{last}(j, W \& P)\\ &\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, \pi_{1}(l b)\right) \end{align} $$ 
>
> (3.52)  $$ \begin{align} &\ \ \operatorname{start}(j, c(j, W \& P))\\ &\wedge \operatorname{finish}(t, c(t, W \& P))\\ &\wedge \neg \operatorname{last}(j, c(j, W \& P))\\ &\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, c\left(j, \pi_{1}(l b)\right)\right) \end{align} $$ 
>
> (3.53)  $$ \begin{align} &\ \ \operatorname{start}(j, \operatorname{read}(j, W \& P))\\ &\wedge \operatorname{finish}(t, \operatorname{write} (t, W \& P))\\ &\wedge \neg \operatorname{last}(j, \operatorname{read}(j, W \& P))\\ &\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, c\left(j, \pi_{1}(l b)\right)\right) \end{align} $$ 
>
> 为了更详细地解释，我们有关于 $start$（每个上述公式的第一行）的以下等式： $$ \operatorname{start}(j, W \& P)=\operatorname{start}(j, c(j, W \& P))=\operatorname{start}(j, \operatorname{read}(j, W \& P)) $$ 
>
> 第一个等式成立是因为 $\operatorname{start}(j): \operatorname{Evt}_{A}(j) \rightarrow \operatorname{Prop}$ 和 $W \& P: B o o k \leq_{c(j)} Evt_{A}(j)$，而第二个等式则根据 $c(j)$ 的定义。对于 $finish$ 和 $last$ 来说也是类似的。 如果仔细阅读，(3.53)就是(3.48)的预期语义。注意，在(3.53)的最后一个连词中，强制子 $c$ 仍然存在， $c\left(j, \pi_{1}(l b)\right)$ 无法进一步简化，因为 $l b$ 是个变量。

这些公式是在形式化描述句子(3.48)的语义。这个句子是："朱莉刚开始读《战争与和平》，这是托尔斯泰经过多年辛勤努力才完成的作品。但这种状况不会持久，因为她从未读完过长篇小说。"

公式(3.51)是对这个句子的直接翻译，其中 \(j\) 和 \(t\) 分别代表 "Julie" 和 "Tolstoy"，而 \(W \& P\) 代表 "War and Peace"。这个公式的每一部分都对应句子的一部分：

- \(\operatorname{start}(j, W \& P)\) 对应 "Julie开始读《战争与和平》"
- \(\operatorname{finish}(t, W \& P)\) 对应 "托尔斯泰完成《战争与和平》"
- \(\neg \operatorname{last}(j, W \& P)\) 对应 "Julie不会持续阅读《战争与和平》"
- \(\forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, \pi_{1}(l b)\right)\) 对应 "Julie从未读完过长篇小说"

然后，公式(3.52)和(3.53)是在应用强制子类型化后的公式。强制子类型化是一种语言学现象，其中一个类型可以被强制转换为另一个类型。在这个例子中，书 \(Book\) 被强制转换为事件 \(Event\)，因为在这个上下文中，一本书被理解为与某个事件（如读书或写书）相关联。

在公式(3.52)中，所有的 \(W \& P\) 都被替换为 \(c(j, W \& P)\)，其中 \(c\) 是强制操作。然后在公式(3.53)中，这个强制操作被进一步解析为具体的事件，例如 \(\operatorname{read}(j, W \& P)\) 或 \(\operatorname{write}(t, W \& P)\)。

最后，公式(3.53)的最后一部分，\($\forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, c\left(j, \pi_{1}(l b)\right)\right)$\)，表示 "对于所有的长篇小说 \(l b\)，Julie都没有完成阅读这本书"。这里的 \(c\left(j, \pi_{1}(l b)\right)\) 不能进一步简化，因为 \(l b\) 是一个变量，我们不知道它具体代表哪本书。

在这个上下文中，\(\wedge\) 符号代表逻辑与（AND）操作。这是一种逻辑运算符，用于连接两个逻辑表达式，只有当这两个表达式都为真时，整个表达式才为真。

例如，在公式(3.51)中，\($\operatorname{start}(j, W \& P) \wedge \operatorname{finish}(t, W \& P)$\) 表示 "Julie开始读《战争与和平》" 和 "托尔斯泰完成《战争与和平》" 这两个事件都发生。

同样，$(\neg \operatorname{last}(j, W \& P) \wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, \pi_{1}(l b)\right)$\) 表示 "Julie不会持续阅读《战争与和平》" 和 "对于所有的长篇小说 \(l b\)，Julie都没有完成阅读这本书" 这两个事件都发生。

---

> (3.64) 对于任意 $x: A$ ，有 $p_{A}(x)= \mathbf{true}$ (3.65) $p_{\text {Human }}(j) \wedge \operatorname{happy}(j)$ 请注意，虽然 $p_{A}$ 是一个简单的常量谓词，但它非平凡[non-trivial]，因为 $p_{A}(a)$ 的类型正确性预设了 $a$ 的类型为 $A$ 。换言之，$p_{A}(a)$ 的真实性（在元理论上）等同于断言 $a: A$ 的正确性（可推导性）。例如，当切仅当 $j: Human$ 可推导，$p_{\text {Human }}(j)$ 才为真。这就是为什么我们可以使用 $p_{A}(a)$ 作为可推导断言 $a: A$ 的命题形式。

"非平凡"（non-trivial）是指一个事物或概念具有一定的复杂性或深度，而不是简单的、明显的或容易理解的。这个词常常用于数学和逻辑学中，用来描述一个问题、定理或证明具有一定的复杂性或深度。

相对的，"平凡"（trivial）在数学和逻辑学中通常用来描述一个问题、定理或证明是简单的、明显的或容易理解的。例如，一个平凡的解决方案可能是一个问题的最简单、最直接或最明显的解决方案。

在这个特定的上下文中，作者指出虽然 $p_{A}$ 是一个简单的常量谓词，但它是"非平凡的"，因为 $p_{A}(a)$ 的类型正确性预设了 $a$ 的类型为 $A$。这意味着，尽管 $p_{A}$ 看起来很简单，但它实际上在类型系统中扮演了一个重要的角色，这使得它成为一个"非平凡"的概念。

---

> $\mathrm{\small NOT}: \Pi X: \mathsf{CN}\ \Pi p: X \rightarrow \operatorname{Prop}\ \Pi Y: \mathsf{CN}\ \Pi y: Y. Prop$

这个式子定义了一个否定算符 `NOT`，它是一个依赖类型的函数，接受四个参数，并返回一个命题（`Prop`）类型的结果。这四个参数分别是：

1. `X`：一个公共名词（`CN`）类型的参数，例如 "dog" 或 "book"。
2. `p`：一个从 `X` 到 `Prop` 的函数，即一个将 `X` 类型的元素映射到命题的函数。这可以被视为一个谓词，例如 "is running" 或 "is red"。
3. `Y`：另一个公共名词（`CN`）类型的参数，例如 "cat" 或 "table"。
4. `y`：一个 `Y` 类型的元素，例如特定的 "cat" 或 "table"。

这个函数的返回类型是 `Prop`，表示它返回一个命题。在这个上下文中，这个命题可能是 "y 不满足 p" 或 "y 不是 X"。

这个函数的定义体（即它如何根据输入参数计算结果）没有在这个式子中给出，但通常会在定义 `NOT` 的地方给出。例如，它可能会定义为 "对于所有的 `x`，如果 `x` 是 `X` 并且 `p(x)` 是真的，那么 `y` 不是 `x`"。

---

> 总的来说，我们主张，如Luo (2009c)所提出的，配备了相关的强制子类机制的 $\Sigma$ 类型为交叠形容词修饰提供了充分的语义解释。这个提议在两个方面是充分的。首先，这种形容词修饰的期望推理得到了预期的实现。交叠形容词与两种类型的推理相关，即，$\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N} \& Adj$ ，如表3.2中所示（例如，参见Kamp (1975)）。下面给出了第一种推理的例子，其中（3.92）给出了一个具体的例子，（3.93）指出了一般的非正式预期，（3.94）显示了解释这种修饰的类型 $\Sigma x: [[ N ]] . [[ A d j ]](x)$ 是 $[[ N ]]$ 的子类型，因此得到了预期的推理。这里需要一些解释。子类型关系（3.94）成立是因为我们总是将第一投影 $\pi_{1}$ 视为一种强制子；换句话说，一般来说，我们有 $\Sigma x: A . B(x) \leq_{\pi_{1}} A$ ，这是（3.94）的一个特殊情况。因此，子类型在这里起了作用：$\Sigma x: [[ N ]] . [[ A d j ]](x)$ 的每个对象都可以被视为 $[[ N ]]$ 类型的对象，因此黑猫是猫。
>
> (3.92) $\text{A black cat is a cat.}$ （黑猫是猫）
>
> (3.93) $\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N}$
>
> (3.94) $\Sigma x: [[ N ]] . [[ A d j ]](x) \leq [[ N ]]$
>
> 

在这里，$[[ N ]]$ 和 $[[ Adj ]]$ 是语义括号，它们被用来表示语义解释。具体来说，$[[ N ]]$ 表示名词 "N" 的语义解释，而 $[[ Adj ]]$ 表示形容词 "Adj" 的语义解释。

在形式语义学中，这种表示法常常被用来区分语法结构和它们的语义解释。例如，如果我们有一个句子 "S"，那么 "S" 本身表示的是这个句子的语法结构，而 $[[ S ]]$ 则表示的是这个句子的语义解释。

---

> (3.95) $\text{A black cat is black.}$ （黑猫黑的）
>
> (3.96) $\operatorname{Adj}[\mathrm{N}] \Rightarrow \operatorname{Adj}$
>
> (3.97) 若 $p$ 类型为 $\Sigma x: [[ N ]] . [[ A d j ]](x)$ ，那么 $[[ A d j ]]\left(\pi_{1}(p)\right)$ 为真
>
> 因此，就预期的推断而言，$\Sigma$ 类型的解释为交叉形容词修饰提供了合适的语义解读。
>
> 值得强调的是，上述使用 $\Sigma$-类型来解释交叉形容词修饰的方法只有在两个条件下才能适用并有效[^21]。首先，我们必须有适当的 MTTs 子类型概念 - 在我们的设定中，这是由强制子类型 (Luo 1999; Luo等人 2012) 提供的（参见第 2.4 节和第 3.2.2 节）；否则，这种 $\Sigma$-类型表示将无法正常工作。第二个条件更微妙，也更少被认识到 - 必须执行证明的无关性[proof irrelevance]；如果没有证明的不相关性，使用 $\Sigma$-类型来表示形容词修饰将是不充分的。以 "black cat" 的解释（3.89）为例。要使用 $\Sigma x: Cat. black (x)$ 适当地表示 "black cat"，必须满足以下条件：两只黑猫只有在它们是同一只猫的情况下才是相同的，而与它们是如何证明为黑色无关。换句话说，对于同一只猫 $c$ ，$(c, p)$ 和 $\left(c, p^{\prime}\right)$ 应该是相同的，因为 $p$ 和 $p^{\prime}$ 是 $black (m)$ 的证明，那就应该视为同一只猫（证明的不相关性）。通过考虑（3.98）的语义解释，我们使用 $\Sigma$-类型来解释 "乘飞机旅行的人"，可以意识到证明不相关性的必要性。

这段话强调了使用 $\Sigma$-类型来解释交叉形容词修饰的方法的适用性和可行性，这主要取决于两个条件。

1. 我们必须有一个适当的子类型概念，适用于现代类型理论（MTTs）。在我们的框架中，这是由强制子类型（coercive subtyping）提供的。如果没有这样的子类型概念，这样的 $\Sigma$-类型表示法将无法正常工作。

2. 第二个条件更微妙，也较少被认识到，那就是需要执行证明的不相关性（proof irrelevance）。如果没有证明的不相关性，使用 $\Sigma$-类型来表示形容词修饰将是不充分的。以 "black cat" 的解释（3.89）为例。要使用 $\Sigma x:$ Cat. black $(x)$ 适当地表示 "black cat"，必须满足以下条件：两只黑猫只有在它们是同一只猫的情况下才是相同的，而它们是如何被证明为黑色的应该是无关的。换句话说，对于同一只猫 $c,(c, p)$ 和 $\left(c, p^{\prime}\right)$ 应该是相同的，因为 $p$ 和 $p^{\prime}$ 是 black $(m)$ 的证明，并且应该被视为相同（证明的不相关性）。通过考虑（3.98）的语义解释，我们使用 $\Sigma$-类型来解释 "乘飞机旅行的人"，可以意识到证明不相关性的必要性。

> 两只黑猫只有在它们是同一只猫的情况下才是相同的，而与它们是如何证明为黑色无关。换句话说，对于同一只猫 $c$,$(c, p)$ 和 $\left(c, p^{\prime}\right)$ 应该是相同的，因为 $p$ 和 $p^{\prime}$ 是 black $(m)$ 的证明，并且应该被视为相同（证明的不相关性）。 这里是因为 $p$ 和 $p^{\prime}$ 是 black $(m)$ 的证明，且$(c, p)$ 和 $\left(c, p^{\prime}\right)$ 相同，所以应该视为相同的一只猫是吗

是的，你的理解是正确的。在这里，$(c, p)$ 和 $(c, p')$ 都表示的是黑猫，其中 $c$ 是猫，$p$ 和 $p'$ 是证明猫是黑色的证据。尽管 $p$ 和 $p'$ 可能在形式上不同（例如，它们可能是从不同的观察或不同的理论推导出来的），但只要它们都能证明猫 $c$ 是黑色的，那么我们就认为 $(c, p)$ 和 $(c, p')$ 表示的是同一只猫。这就是所谓的证明不相关性（proof irrelevance）：只要证明的结论相同，我们就认为这些证明本质上是等价的。

> 那么这里的证明不相关性是意味着证明形式的不同不会导致主体不会被视为多个对象是吗

是的，你的理解是正确的。证明不相关性（proof irrelevance）是指，只要证明的结论相同，那么无论证明的形式如何，我们都认为这些证明是等价的。换句话说，证明的具体形式或过程并不影响我们对证明结论的接受。在这个例子中，无论我们如何证明猫是黑色的（即，无论 $p$ 和 $p'$ 的具体形式如何），只要证明的结论是“这只猫是黑色的”，那么我们就认为 $(c, p)$ 和 $(c, p')$ 表示的是同一只猫。

---

"Veridicality"在逻辑和语言学中通常用来描述一个表达式（如副词、句子等）是否暗示或保证其包含的命题是真实的。

在这里，"veridical adverb"（真实副词）是指那些与动词短语（VP）或命题结合后，能够暗示或保证该动词短语或命题在没有副词的情况下也是真实的副词。换句话说，如果一个副词是"veridical"，那么当你在一个句子中使用这个副词时，即使你去掉这个副词，句子的真实性也不会改变。

例如，考虑副词"actually"，如果我们说"John actually passed the exam"，这个句子暗示"John passed the exam"是真实的。因此，"actually"在这里就是一个"veridical adverb"。

---

>另一个常见的推理模式是与意向副词[intensional adverbs]相关的，也就是像“故意[intentionally]”或“据称[allegedly]”这样的副词。这种类型的副词创造了我们所说的不透明语境[opaque contexts]，和表现出指称不透明[referential opacity]的语境。简单来说，在指称不透明语境中，即使你用具有相同引用的词语进行替换，也不会保持语句的真实性。根据副词是动词短语副词还是命题修饰语，在第一种情况下，只有对象的不透明性，而在第二种情况下，主体和对象都会有不透明性。以下就用“据称”和“故意”来举例说明：

这段话在讨论一种被称为"intensional adverbs"（意向性副词）的副词类型，例如"intentionally"（故意地）或"allegedly"（据称）。这类副词被认为会创建所谓的"opaque contexts"（不透明语境）或展示出"referential opacity"（指称不透明性）的语境。

"Opaque contexts"或"referential opacity"是逻辑和语言学中的概念，简单来说，就是在这种语境中，即使你用具有相同引用的词语进行替换，也不会保持语句的真实性。换句话说，即使两个词语指的是同一个事物，但在不透明语境中，将其中一个词语替换为另一个可能会改变句子的真实性。

这段话还指出，根据副词是动词短语（VP）副词还是命题修饰符，我们只在第一种情况下得到对象的不透明性，而在第二种情况下，主语和对象都会出现不透明性。这一点在"allegedly"（据称）和"intentionally"（故意地）的例子中得到了说明。

---

> 另一个常见的推理模式是与意向副词[intensional adverbs]相关的，也就是像“故意[intentionally]”或“据称[allegedly]”这样的副词。这种类型的副词创造了我们所说的不透明语境[opaque contexts]，和表现出指称不透明[referential opacity]的语境。简单来说，在指称不透明语境中，即使你用具有相同引用的词语进行替换，也不会保持语句的真实性。根据副词是动词短语副词还是命题修饰语，在第一种情况下，只有对象[object]的不透明性，而在第二种情况下，主体[subject]和对象都会有不透明性。以下就用“据称[allegedly]”和“故意[intentionally]”来举例说明：
>
> (4.10) $\text{Oedipus intentionally married Jocaste} \Rightarrow \text{The son of Laius intentionally married Jocaste.}$
> 			俄狄浦斯成心娶亲伊俄卡斯忒 $\Rightarrow$ 拉伊俄斯之子成心娶亲伊俄卡斯忒
>
> (4.11) $\text{Oedipus intentionally married Jocaste} \nRightarrow \text{Oedipus intentionally married his mother.}$
> 			俄狄浦斯成心娶亲伊俄卡斯忒 $\nRightarrow$ 俄狄浦斯成心娶亲他母亲
>
> (4.12) $\text{Oedipus allegedly married Jocaste} \nRightarrow \text{The son of Laius allegedly married Jocaste.}$
> 			据说俄狄浦斯娶了伊俄卡斯忒 $\nRightarrow$ 据说拉伊俄斯之子娶了伊俄卡斯忒
>
> (4.13) $\text{Oedipus allegedly married Jocaste} \nRightarrow \text{Oedipus allegedly married his mother.}$
> 			据说俄狄浦斯娶了伊俄卡斯忒 $\nRightarrow$ 据说俄狄浦斯娶了他母亲
>
> (4.10)和(4.11)展示了意向动词短语副词的情况：只为宾语[object]创造了不透明性(4.10)，而没为主语[subject]创造(4.11)。另一方面，(4.12)和(4.13)展示了带有意向性估评副词的情况：为主语和宾语都创造了不透明性。

在这里，"不透明性"（opacity）指的是在某些语境中，即使两个表达式指代的是同一个实体，将一个表达式替换为另一个也不一定会保持语句的真值（即语句的真假性）。这种语境被称为"不透明语境"（opaque contexts）。

在这个例子中，"Oedipus"（俄狄浦斯）和"The son of Laius"（拉伊俄斯之子）都指的是同一个人，所以他们是共指的。在这个语境下，"intentionally"（成心）这个副词并没有改变主语的指称，所以我们可以将"Oedipus"和"The son of Laius"互换，而不改变句子的真值。因此，我们说这个语境对主语没有产生不透明性。

(4.11)中，"Jocaste"和"his mother"都指的是同一个人，但是在"Oedipus intentionally married Jocaste"这个语境中，将"Jocaste"替换为"his mother"，语句的真值就改变了。原句是真的（Oedipus确实有意识地娶了Jocaste），但替换后的句子"Oedipus intentionally married his mother"就不真实了（因为Oedipus并不知道Jocaste就是他的母亲，所以他并没有有意识地娶自己的母亲）。这就是一个不透明语境的例子。

同样地，例子(4.12)和(4.13)展示了在句子级别的副词（如"allegedly"）中，主语和宾语都可能产生不透明性。

在例子(4.12)和(4.13)中，"Oedipus"和"The son of Laius"都指的是同一个人，而"Jocaste"和"his mother"也指的是同一个人。然而，当我们试图将这些同义词在句子中互相替换时，句子的真值并不会保持不变，这就是不透明性的体现。

具体来看：

在例子(4.12)中，"Oedipus allegedly married Jocaste"是一个可能的陈述，因为有人可能会宣称"Oedipus"和"Jocaste"结婚了。然而，当我们将"Oedipus"替换为"The son of Laius"后，得到的句子"The son of Laius allegedly married Jocaste"的真值可能就会改变，因为可能没有人宣称"Laius的儿子"和"Jocaste"结婚了。

同样，在例子(4.13)中，"Oedipus allegedly married Jocaste"是一个可能的陈述，但当我们将"Jocaste"替换为"his mother"后，得到的句子"Oedipus allegedly married his mother"的真值也可能会改变，因为可能没有人宣称"Oedipus"和"他的母亲"结婚了。

因此，这两个例子都展示了评估度量的副词（如"allegedly"）可以为主语和宾语都创建不透明语境。

> 那其实4.12中真值的改变是因为没人宣称Laius的儿子就是俄狄浦斯，而4.13中的改变是没人能够确认Jocaste是俄狄浦斯的母亲，因此同样算是主宾语的不透明语境

是的，你的理解是正确的。在这两个例子中，"Oedipus"和"The son of Laius"，以及"Jocaste"和"his mother"，虽然在某种意义上它们指的是同一个实体，但在特定的语境下，它们可能带有不同的含义或者引发不同的推断，这就导致了所谓的"不透明性"。这种不透明性是由副词（如"allegedly"）引入的，它使得我们不能简单地将这些同义词在句子中互相替换而不改变句子的真值。这就是为什么我们说这些副词创建了一个"不透明语境"。

> 在4.10和4.11中，是否「成心」皆是由俄狄浦斯这个主体所决定的，他看待对象的性质是由他所构造的语境所决定的，所以对于其对象的等位解释替换可能并不存在于主体所构造的语境中，所以对于对象解释的替代会造成句子真性收到影响，而主体的意义只要是收束在他的身上那么其替代解释不会影响到句子意义的真性，因为主体已经是一种结果，已经被确定，使得任何尝试以替代解释替代其主体的行为而只要是指向这个主体的那么就不会影响第三方对当前句子意义的观测，所以主语可以动而宾语不能动所以只有宾语有不透明性，对吗？而在4.12和4.13中，句子被观测所得到的意义在于一个第三者，意义由这个第三者所提供的对于主体和对象定义的语境，那么主体和对象都处于这个事件的过程中而非结果，所以主体和对象都不可变也就都具有了不透明性，对吗？

你的理解是正确的。在例子4.10和4.11中，"intentionally"（成心）这个副词是由"Oedipus"（俄狄浦斯）这个主体决定的，所以主体的替换并不会改变句子的真值。而对于宾语的替换，由于可能并不存在于主体所构造的语境中，所以会影响句子的真值，因此宾语具有不透明性。

在例子4.12和4.13中，"allegedly"（据称）这个副词引入了一个第三者的观点，这个观点为主体和宾语提供了语境。在这种情况下，主体和宾语都是事件的过程的一部分，而不是结果，所以它们的替换都会影响句子的真值，因此主体和宾语都具有不透明性。

总的来说，你的理解是非常准确的，你对这个概念的理解非常深入。

---

> 如前所述，“小[small]”/“大[large]”等形容词不仅是细分的（见3.3.2节的细分形容词），而且还包含一个进一步区别的性质，即可度量性。通常来说，我们所说的可度量形容词指的是那些涉及某种度量特性/参数的形容词，这种特性/参数使得它们可以根据这个特性进行量化。例如，在“小”/“大”的情况下，度量参数就是大小。可度量形容词具有比较级和最高级形式，而且还可以进一步通过程度副词（如“很[much]”）进行修饰。在文献中，根据可度量参数是否在可度量形容词的定义中形式编码，能找到两种方法定义可度量形容词。能形式编码此参数的观点认为可度量形容词涉及一个程度参数，而不可度量形容词则不涉及。例如，假设小和大给出了较低的谓项类型（即 $\mathbf{e} \rightarrow \mathbf{t}$ ），为了处理可度量性，修正后的类型将是 $d \rightarrow(\mathbf{e} \rightarrow \mathbf{t})$ （ $d$ 代表程度）。从这个观点出发，“小”这个形容词可以被赋予如下定义：[^6]
>
> (4.17) $\mathsf{small} =\lambda \mathsf{d} : \mathsf{Degree}. \lambda \mathsf{x}: \mathbf{e} . \mathsf{height} (\mathsf{x}) \leq \mathsf{d}$
>
> [^6]: 来自MTT语义外部观点的式子时使用无衬线字体。
>
> 这种方法的支持者可以在（Bartsch和Vennermann 1973; Von Stechow 1984; Heim 2000）等中找到。处理可度量形容词的另一种选择是假设它们具有与非度量形容词相同的类型。然后，不同之处在于，即使是从个体到真值谓词的可度量形容词，也涉及部分有序域[partially ordered domains]。可度量形容词在这些部分有序域上划分。对于落入形容词 $A$ 所施加域的上侧对象 $x$ ，$A(x)$ 为真，而对于位于标准下侧的对象$y$ ，$A(y)$ 为假。这就是Kennedy（1999）所称的模糊谓词方法[vague predicate approach]。这种方法的支持者可以在（Lewis 1970; McConnell-Ginet 1973; Klein 1980; Van Benthem 2013）等中找到。可度量形容词的观点相当多，无法完全提及，有兴趣的读者可以参考Kennedy（1999），以获取有关这些观点和其他文献的更多信息。Lassiter（2014）的成果也提供了这两种方法更近期的概述。

这段话在讨论处理可度量形容词的另一种方法。这种方法假设可度量形容词和不可度量形容词具有相同的类型，但是可度量形容词涉及的是部分有序的领域（partially ordered domains）。

"部分有序的领域"是数学术语，指的是一个集合，其中的元素之间存在一种关系，这种关系满足反身性（每个元素与自身有关系）、反对称性（如果元素a与元素b有关系，并且元素b与元素a也有关系，那么a和b必须是同一个元素）和传递性（如果元素a与元素b有关系，元素b与元素c有关系，那么元素a与元素c也有关系）。但是，不是所有的元素对都必须具有这种关系，这就是为什么它被称为"部分"有序。

在这种处理可度量形容词的方法中，可度量形容词会在这些部分有序的领域上施加一个划分。对于落在由形容词A施加的领域上侧的对象x，A(x)为真，而对于在刻度下侧的对象y，A(y)为假。这种方法被Kennedy（1999）称为"模糊谓词方法"（vague predicate approach）。

这段话还提到了一些支持这两种处理可度量形容词方法的学者和他们的工作，并推荐了Kennedy（1999）和Lassiter（2014）的工作，以便读者了解更多关于这些方法的信息和其他参考文献。

"模糊谓词方法"是一种处理可度量形容词的方法。在这种方法中，可度量形容词被视为从个体到真值的谓词，就像不可度量形容词一样。然而，可度量形容词还涉及到部分有序的领域，这是它们与不可度量形容词的主要区别。

部分有序的领域是指一种结构，其中元素之间存在某种顺序，但并非所有元素之间都可以进行比较。例如，我们可以考虑一组人的身高。这是一个部分有序的领域，因为我们可以比较两个人的身高，但并不能说一个人的身高在所有情况下都比另一个人的身高高或低。

在这种方法中，可度量形容词在这些部分有序的领域上施加了一个划分。例如，对于形容词"高"，它可能会将人群划分为"高"和"不高"两部分。具体划分的标准可能取决于上下文或其他因素。对于落在由形容词A施加的领域上侧的对象x（例如，被认为是"高"的人），A(x)为真，而对于在刻度下侧的对象y（例如，被认为是"不高"的人），A(y)为假。

这种方法的一个关键特点是，它允许形容词的含义在不同的上下文中有所变化，因为划分的标准可能会根据上下文而变化。这就是为什么它被称为"模糊谓词方法"的原因。

> 为什么「高(x)」为真，而「不高(y)」为假		(ps:实际上是“高(y)“为假，y没有满足「高」标准)

在这里，“高(x)”为真，是指在我们给定的划分标准或上下文中，对象x满足“高”的定义或标准。换句话说，x的身高超过了我们设定的“高”的阈值，所以我们说“x是高的”，或者“高(x)”为真。

相反，“不高(y)”为假，是指在同样的划分标准或上下文中，对象y并未满足“高”的定义或标准。也就是说，y的身高没有超过我们设定的“高”的阈值，所以我们说“y不是高的”，或者“高(y)”为假。

这里的真和假是相对于我们设定的“高”的标准来说的。如果我们改变了标准或上下文，那么可能原来被认为是“高”的对象现在就不再被认为是“高”，反之亦然。这就是为什么这种方法被称为“模糊谓词方法”的原因，因为形容词的含义可以根据上下文或标准的变化而变化。

---

> 如前所述，“小[small]”/“大[large]”等形容词不仅是细分的（见3.3.2节的细分形容词），而且还包含一个进一步区别的性质，即可度量性。通常来说，我们所说的可度量形容词指的是那些涉及某种度量特性/参数的形容词，这种特性/参数使得它们可以根据这个特性进行量化。例如，在“小”/“大”的情况下，度量参数就是大小。可度量形容词具有比较级和最高级形式，而且还可以进一步通过程度副词（如“很[much]”）进行修饰。在文献中，根据可度量参数是否在可度量形容词的定义中形式编码，能找到两种方法定义可度量形容词。能形式编码此参数的观点认为可度量形容词涉及一个程度参数，而不可度量形容词则不涉及。例如，假设小和大给出了较低的谓项类型（即 $\mathbf{e} \rightarrow \mathbf{t}$ ），为了处理可度量性，修饰后的类型将是 $d \rightarrow(\mathbf{e} \rightarrow \mathbf{t})$ （ $d$ 代表程度）。从这个观点出发，“小”这个形容词可以被赋予如下定义：[^6]
>
> (4.17) $\mathsf{small} =\lambda \mathsf{d} : \mathsf{Degree}. \lambda \mathsf{x}: \mathbf{e} . \mathsf{height} (\mathsf{x}) \leq \mathsf{d}$

这段文字主要讨论了形容词的一个重要特性，即"可度量性"（gradability）。可度量的形容词是指那些可以根据某种等级或参数进行量化的形容词。例如，在"小"（small）和"大"（large）这样的形容词中，度量参数就是大小（size）。可度量的形容词具有比较级和最高级形式，并且可以进一步通过程度副词（如"much"）进行修饰。

在文献中，根据是否在可度量形容词的定义中正式编码度量参数，可以找到两种处理方式。一种假设是，可度量形容词涉及一个度量参数，而不可度量的形容词则不涉及。例如，如果我们假设"小"和"大"被赋予了较低的谓词类型（即 $\mathbf{e} \rightarrow \mathbf{t}$），那么为了处理可度量性，修饰后的类型将是 $d \rightarrow(\mathbf{e} \rightarrow \mathbf{t})$（这里的 $d$ 代表度量）。在这种观点下，形容词"小"可以被定义如下：

(4.17) small $=\lambda d$ : Degree. $\lambda x: \mathbf{e} \cdot$ height $(x) \leq d$

这个公式的意思是，对于一个给定的度量d和一个实体x，如果x的高度小于或等于d，那么我们就可以说"x是小的"。这就是形容词"小"的定义。

在这里，"较低的谓词类型"（lower predicate types）是指在类型理论中的一个概念。类型理论是一种形式逻辑系统，用于描述和分析计算机科学、语言学和相关领域中的各种概念。

在类型理论中，谓词（或函数）的类型通常表示为 "输入类型 -> 输出类型"。例如，一个将实体（e）映射到真值（t）的谓词的类型可以表示为 "e -> t"。

在这个上下文中，"较低的谓词类型"（lower predicate types）可能是指这样的谓词类型，它们的输入类型和/或输出类型相对简单。例如，"e -> t" 可能被视为一个"较低的"谓词类型，因为它只涉及到实体和真值这两种基本类型。

然而，为了处理可度量的形容词，我们可能需要引入一个更复杂的类型，如 "d -> (e -> t)"。在这个类型中，我们有一个度量（d）作为输入，输出是一个从实体（e）映射到真值（t）的谓词。这就是为什么这个类型被称为"修饰后的"类型。

这里的 Lambda 函数是一种在计算机科学和数学中常见的函数表示方法。Lambda 函数可以用于创建匿名函数，即没有名字的函数。在这个上下文中，Lambda 函数用于定义形容词的语义。

在给出的定义中：

(4.17) small = λd : Degree. λx: e. height(x) ≤ d

这个 Lambda 函数可以解读为：“对于任何度量 d 和任何实体 x，如果 x 的高度小于或等于 d，则 'small' 函数返回真（即，x 是小的）。”

这里的 "λd : Degree" 是一个函数，它接受一个度量（Degree）作为输入。"λx: e" 是另一个函数，它接受一个实体（e）作为输入。"height(x) ≤ d" 是这个函数的主体，它定义了函数的行为：如果实体 x 的高度小于或等于度量 d，那么函数返回真。

这个定义捕捉了 "small" 这个形容词的语义：一个实体被认为是 "small"，如果它的高度小于或等于某个度量。这个度量可以是任何值，取决于我们如何使用 "small" 这个词。例如，如果我们说 "That is a small building"，那么这个度量可能就是建筑物的高度的某个标准值。

---

> 接下来，我们将提出一个通用的框架来处理使用MTTs的度量形容词[^7]。这个框架基于作者们对比较形容词[comparative adjectives]（Chatzikyriakidis和Luo 2014，2017a）提出的早期处理方法，同时，也与涉及到明确的度量参数的可度量性的处理方法一致。这个思想使用了带有一个程度参数的索引类型，特别是 $\mathrm{CNs}$ [^8]。让我们开始看看形容词"高"。我们假设高是由一个高度类型的数字如1.70来测量的[^9]。然后，我们就会考虑由高度索引的类型家族 $Human : Height \rightarrow Type$ ， $\operatorname{Human}(n)$ 是高度为 $n$ 的人的类型。然后，我们可以定义一个函数，它接受一个数字 $i$ 和一个高度为 $i$ 的人，然后返回 $i$ ：
>
> (4.18) $height : \Pi i : Height. Human (i) \rightarrow Height$
>
> (4.19) $height (i, h)=i$
>
> 然后按如下给出了高的类型和定义：
>
> (4.20) $tall : \Pi i: Height. Human (i) \rightarrow Prop$
>
> (4.21) $tall(i, h)=h e i g h t(i, h) \geq n$
>
> [^7]: 近期，Maclean和第二作者为MTTs开发了子类型宇宙，证明了它们在编程和自然语言语义应用中的实用性，并进一步研究了它们的元理论结果（Maclean和Luo 2020）。例如，他们证明了将子类型宇宙扩展到MTTs可以保持逻辑一致性，这是一个类型理论用作基础语义语言的必不可少的结果。关于NL语义的一个例子，Maclean和Luo（2020）使用子类型宇宙提出了新的可度量形容词的语义构造，包括多维形容词 - 更多详细内容请参见（Maclean和Luo 2020; Chatzikyriakidis和Luo 2020）。
> [^8]: 关于术语的一点说明是必要的：有时人们会将依赖类型称为索引类型，特别是当相关类型依赖于数字时。
> [^9]: 这里我们并未明确指出$Height$的类型。有人可能会将$Height$视为自然数类型$Nat$，并使用170来表示1.70等等。
>
> 上述定义规定，对于任何类型为 $Height$ 的 $i$ ，$tall$ 将接受一个类型为$H uman (i)$ 的参数，并返回一个命题，即人的高度 $i$ 大于或等于自然数 $n$ 。这个自然数 $n$ 代表了受语境限制的参数 - 高于 $n$ 的人视为高。同样我们可以定义比较形式，其中(4.23)的右侧与 $i>j$ 相同：
>
> (4.22) $taller\_than : \Pi i, j: Height. Human (i) \rightarrow H u m a n(j) \rightarrow Prop$
>
> (4.23) $taller\_than \left(i, j, h_{1}, h_{2}\right)=h e i g h t\left(i, h_{1}\right)>height\left(j, h_{2}\right)$
>
> 从这个定义中，我们可以轻易证明，比如，如果 $h e i g h t\left(i, h_{1}\right) \geq$ $h e i g h t\left(j, h_{2}\right)$ 并且 $\operatorname{tall}\left(j, h_{2}\right)$ ，那么就有 $\operatorname{tall}\left(i, h_{1}\right)$ 。

这段内容主要在讨论如何使用类型理论（MTTs）来处理可度量的形容词。这个框架基于作者之前对比较形容词的处理，并且与那些假设可度量形容词涉及明确等级参数的方法一致。这个框架使用了索引类型，特别是由等级参数索引的常用名词（CNs）。

首先，我们考虑形容词"tall"。我们假设高度是由一个数字类型Height（例如1.70）来衡量的。然后，我们考虑由高度索引的类型族Human : Height $\rightarrow$ Type：$\operatorname{Human}(n)$是高度为$n$的人的类型。然后，我们可以定义一个函数height，它接受一个数字$i$和一个高度为$i$的人，返回$i$：

(4.18) height : Пi : Height. Human $(i) \rightarrow$ Height

(4.19) height $(i, h)=i$

然后，我们可以给出"tall"的类型和定义：

(4.20) tall : $i:$ Height. Human $(i) \rightarrow$ Prop

(4.21) $\operatorname{tall}(i, h)=h e i g h t(i, h) \geq n$

上述定义指出，对于任何类型为Height的$i$，tall接受一个类型为$H$ uman $(i)$的参数，并返回一个命题，即$i$（人的高度）大于或等于一个自然数$n$。这个自然数$n$代表了上下文限制的参数——高于$n$的人被视为高。同样，我们可以定义比较级，其中(4.23)的右侧与$i>j$相同：

(4.22) taller_than $: \Pi i, j:$ Height. Human $(i) \rightarrow H u m a n(j) \rightarrow$ Prop

(4.23) taller_than $\left(i, j, h_{1}, h_{2}\right)=h e i g h t\left(i, h_{1}\right)>\operatorname{height}\left(j, h_{2}\right)$

从这个定义，我们可以轻易地证明，例如，如果$h e i g h t\left(i, h_{1}\right) \geq$ $h e i g h t\left(j, h_{2}\right)$并且$\operatorname{tall}\left(j, h_{2}\right)$，那么$\operatorname{tall}\left(i, h_{1}\right)$。

---

> (4.22) $taller\_than : \Pi i, j: Height. Human (i) \rightarrow H u m a n(j) \rightarrow Prop$

这是一个依赖类型的函数定义。让我们一步步来解释这个定义：

- `taller_than` 是我们定义的函数名。
- `: Π i, j: Height.` 表示这个函数有两个参数，i和j，它们的类型都是Height。这里的 `\Pi` 是类型理论中的一个符号，用来表示依赖类型的函数。在这个例子中，i和j代表的是身高，它们是实数类型。
- `Human(i) -> Human(j) -> Prop` 表示这个函数的返回类型。这是一个函数类型，表示这个函数接受两个参数，一个类型为 `Human(i)` 的参数和一个类型为 `Human(j)` 的参数，然后返回一个类型为 `Prop` 的结果。这里的 `Human(i)` 和 `Human(j)` 是依赖类型，表示身高为i和j的人。`Prop` 是命题类型，表示逻辑命题。

所以，整个定义的意思是：`taller_than` 是一个函数，它接受两个身高参数i和j，然后返回一个函数，这个函数接受两个人作为参数，一个人的身高为i，另一个人的身高为j，然后返回一个命题，表示第一个人是否比第二个人高。

在类型理论中，`->` 符号通常用来表示函数类型。如果我们有 `A -> B`，那么这表示一个函数，这个函数接受一个类型为 `A` 的输入，并返回一个类型为 `B` 的输出。

在你给出的 `taller_than` 函数定义中，`Human(i) -> Human(j) -> Prop` 的意思是这个函数接受一个类型为 `Human(i)` 的输入，然后返回一个新的函数。这个新的函数接受一个类型为 `Human(j)` 的输入，并返回一个类型为 `Prop` 的输出。

所以，`->` 可以被看作是 "接受...然后返回..." 的意思。

---

> 在(4.31)/4.32)中，最自然的理解并不是大的物理尺寸，而是名词在很大程度上持有某种属性。这样的例子通常被视为名词领域中可度量性的证据，也证明了附加名词修饰词的存在，即在(4.31)/4.32)中的形容词"enormous"和"big"（Paradis 2001; Morzycki 2009）。另一方面，Constantinescu (2013)认为，尺寸形容词总是与尺寸读数相关，这取决于名词，可以接收具体或抽象的尺寸读数。主张附加名词修饰词方法的人（尤其是Morzycki 2009）提出的相关论点，声称可度量名词应该与可度量形容词一样进行分析，但这有许多问题。例如，正如Solt (2009)正确指出的，与我们在形容词领域（too, very等）发现的情况相反，附加名词修饰词没有明确定义的类别，这一事实也被其他研究者注意到，例如Constantinescu (2013)。我们在这里想提出的是，基于我们在这本书中一直在发展的观点，可度量名词被解释为类型，特别是$\Sigma$类型，其中它们的第一投影是一个抽象的度量参数，而第二投影是一个依赖于这个度量参数的$\mathrm{CN}$类型。我们假设像"enormous"这样的形容词是多态谓词，它们的论点延伸到$\mathrm{CN}$的宇宙，而这些论点的指数延伸到Degree宇宙。在接下来的部分，我们将这些假设付诸实践。

在这里，"indices"指的是索引。在类型理论中，索引通常用于表示依赖类型的参数。例如，如果我们有一个依赖类型`A(i)`, 其中`i`是一个索引，那么`A(i)`的类型可能会根据`i`的值而变化。在这个上下文中，"indices of these arguments extend over the Degree universe"意味着这些参数的索引（或者说，这些参数所依赖的值）取自"Degree universe"，也就是度量的范围或集合。

---

> 正如我们之前所述，索引类型是依赖类型的一种，即由一个通常是简单类型的参数索引的类型族。我们在处理可分级形容词时已经使用了索引类型。问题是我们是否可以将索引类型的使用扩展到可度量名词。我们将要论证的是，这确实是可能的。我们想在这里提出的是，名词和形容词之间的区别仍然很明显，形容词视为谓词，名词为类型，但是，同时，我们假设像“白痴[idiot]”这样的可度量名词和像“高[tall]”这样的可度量形容词都涉及到程度参数，尽管前者的情况下是一个抽象的参数。捕捉这个想法的一个自然方式，即抽象名词是类型但仍涉及到一个程度参数，使用 $\Sigma$ 类型，并假设第一投影实际上是抽象参数。为此，我们考虑由愚蠢程度索引的类型族 $IHuman : Idiocy \rightarrow Type$ ，其中愚蠢程度的类型为 $Idiocy : Degree$ ，$Idiocy$ 是个类型，其对象形成全序[total order]，可以通过如 $\geq$ 关系进行比较：然后，“白痴”可以通过(4.33)来表示：
>
> (4.33) $Idiot =\Sigma i: Idiocy. IHuman (i) \times(i \geq \operatorname{STND}( Idiocy, Human, IDIOTIC ))$

"Total order"是数学术语，也被称为全序或线性序，它是一个二元关系，具有反身性、反对称性、传递性和连通性。在全序集合中，任何两个元素都可以比较大小。例如，实数集就是一个全序集合，因为你可以比较任何两个实数的大小。在这个上下文中，"total order"意味着"Idiocy"类型的对象可以通过某种方式（例如，≥关系）进行比较。

这个式子定义了"Idiot"这个类型。在这个定义中，"Idiot"类型是一个Σ类型，它由两部分组成：一个"Idiocy"类型的度量i和一个"IHuman(i)"类型的人。这两部分都是必要的，以满足"Idiot"类型的定义。

Σ类型可以理解为一个包含两部分的元组，其中第二部分可能依赖于第一部分。在这个例子中，第二部分是"IHuman(i)"，它依赖于第一部分的"i"。

"Idiocy"是一个度量，表示愚蠢的程度。"IHuman(i)"表示具有特定愚蠢程度i的人的类型。

"i ≥ STND( Idiocy, Human, IDIOTIC )"是一个条件，表示i（愚蠢的程度）必须大于或等于某个标准值。这个标准值由函数"STND"给出，它取"Idiocy"（愚蠢的度量）、"Human"（人的类型）和"IDIOTIC"（表示愚蠢的常量）作为参数。

因此，这个定义可以理解为："Idiot"类型包含的是那些愚蠢程度大于或等于某个标准值的人。

---

> 上述段落主张，各个维度合并（换言之就是坍塌[collapse]）成为一个独特的度量[degree]，因此，它们不能像多元形容词那样被量化。将常用名词视为类型似乎与这个观点相容。思路如下：为了使一个对象成为 $\mathsf{CN}$ 类型，其必须超越对名词维度中理想值相似度之加权总和的会员标准[standard of membership] [^15]。实际上，Sassoon和Fadlon（2017）后来修改了他们的观点，并在这种类型名词的情况下谈到了加权乘积[weighted products]。在这两种类型的多维性之间，即像"健康"这样的多元形容词和像"鸟"这样的多元名词之间，我们找到了像"语言学家"和"艺术家"这样的社会名词。这些词似乎表现得像多元形容词，它们的维度似乎可以根据以下示例进行量化：

"Standard of membership"在这里指的是一个对象被认为属于某个类型（在这里是一个名词类别，比如"bird"）的程度或标准。这个标准是通过将对象在名词的各个维度上的相似度度量值进行加权求和（或者在某些情况下，可能是加权乘积）得到的。如果这个加权和超过了某个阈值，那么这个对象就被认为属于该名词所代表的类型。

例如，对于"bird"这个类型，可能有多个维度，比如"能否飞行"、"是否有羽毛"、"是否下蛋"等。一个对象（比如一个动物）在这些维度上的相似度度量值可能分别是0.9、1.0和0.8，然后通过某种方式（比如加权求和或加权乘积）将这些度量值结合起来，得到一个总的度量值。如果这个总的度量值超过了某个阈值，那么这个对象就被认为是"bird"这个类型的成员。

在这个上下文中，"with respect to"是一个短语，意思是"关于"或"在...方面"。它用来指明我们正在讨论或考虑的特定方面或维度。

例如，当我们说"the standard of membership with respect to the weighted sum of its similarity degrees to the ideal values in the dimensions of the noun"时，我们是在说"关于其与名词维度中理想值的相似度度量的加权和的成员资格标准"。这里的"with respect to"用来指出我们正在讨论的是这个加权和，而不是其他可能的度量或标准。

---

> 现在，我们可以认为，在社交名词[social nouns]维度可获取的情况下，会发生的事情是，某种量化正在以 $\Sigma$ 类型的形式发挥作用，其中第一投影仅仅是人类类型，第二投影指定了这个人的所有艺术维度。在这些假设的基础上，我们对艺术家的定义如下：[^17]
>
> (4.46) $artist=\Sigma h:  Human.  \forall a: Art.DIM_{C N}(h, a)$
>
> [^17]: 其中 $D I M_{C N}: \Pi D: Degree.Human \rightarrow D \rightarrow Prop$

这个脚注是对公式(4.46)中使用的函数$DIM_{CN}$的定义。这个函数是一个多元函数，它接受一个度量（Degree）、一个人（Human）和一个艺术（Art）作为输入，并返回一个命题（Prop）。这个函数的具体含义可能会根据上下文和具体的应用场景有所不同，但在这个上下文中，它可能被用来表示一个人在某个艺术领域的技能或才能的度量。

---

当然可以。在类型理论中，$\Sigma$-类型（也称为依赖对或存在类型）是一种依赖类型，它对应于逻辑中的存在量词。一个$\Sigma$-类型的元素是一个对，其中第二个元素的类型可能依赖于第一个元素。

例如，我们可能有一个类型为$\Sigma x: A. B(x)$的元素，其中$A$是一个类型，$B$是一个函数，它接受一个类型为$A$的元素并返回一个类型。这个$\Sigma$-类型的元素是一个对$(a, b)$，其中$a$是类型$A$的元素，$b$是类型$B(a)$的元素。

在这种情况下，我们可以说类型$B(a)$是强制的，因为它是依赖于$a$的。换句话说，我们不能只是随意选择一个类型$B(a)$的元素，我们必须选择一个元素，它的类型依赖于我们已经选择的$a$。

这种强制性的概念在处理依赖类型时非常重要，因为它强调了类型的选择是如何依赖于已经选择的值的。

---

> 上述段落主张，各个维度合并（换言之就是坍塌[collapse]）成为一个独特的度量[degree]，因此，它们不能像多元形容词那样被量化。将常用名词视为类型似乎与这个观点相容。思路如下：为了使一个对象成为 $\mathsf{CN}$ 类型，其必须超越对名词维度中理想值相似度之加权总和的成员标准[standard of membership] [^15]。实际上，Sassoon和Fadlon（2017）后来修改了他们的观点，并在这种类型名词的情况下谈到了加权积[weighted products]。在这两种类型的多维性之间，即像"健康"这样的多元形容词和像"鸟"这样的多元名词之间，我们找到了像"语言学家"和"艺术家"这样的社会名词。这些词似乎表现得像多元形容词，它们的维度似乎可以根据以下示例进行量化：

在这里，"membership"指的是一个对象是否属于某个特定类型或类别。当我们谈论一个对象的"membership"时，我们实际上是在评估这个对象是否满足成为某个特定类型或类别成员的条件。

在你引用的这段文字中，"the standard of membership"指的是成为某个特定类型（在这里是名词类型，或者更具体地说，是可度量名词类型）成员的标准或条件。这些条件可能涉及到对象在名词的各个维度上的相似度度量，这些度量可能被加权求和或者以其他方式组合，以确定对象是否满足成为该类型成员的标准。

---

> 那么我们将如何处理MTTs中的这类副词呢？首先要看的是本体论。更具体地说，要看的是方式如何表示。我们在这里要追求的想法是基于Luo和Soloviev（2017）提出的依赖事件类型，并将在第7.2节中进行讨论。主要的直观理解是，事件可以依赖于一个或多个主题关系。例如，对于 $a:Agent$ ，我们可以形成 $E v t_{A}(a)$ ，即依赖于代理的事件类型。对于方式也可以做同样的处理，假设方式可以视为一种主题关系。因此，对于 $m:Manner$ ，我们可以形成 $Evt_{M}(m)$ ，即依赖于方式的事件类型。在这样的设定中，谓词将是什么样子？非依赖事件中的普通谓词可以假定为类型 $A \rightarrow Event \rightarrow Prop$（其中 $A: \mathsf{CN}$ ）。因此，一个依赖于方式的事件的谓词将是类型 $(A \rightarrow Evt_{M}(m) \rightarrow Prop)$ ，而方式副词将是多态的谓词修饰符，具有以下类型： (4.57) $ADV_{manner} : \Pi m: Manner. \Pi A: \mathsf{CN}. (A \rightarrow Evt_M(m) \rightarrow Prop ) \rightarrow \left(A \rightarrow E v t_M(m) \rightarrow\right. Prop )$ 将这些放一块，像"难以辨认地[illegibly]"这样的副词可以定义如下：对于任意 $P: A \rightarrow \operatorname{Evt}_{M}(m) \rightarrow \operatorname{Prop}$ , $x: A$ 和 $E: E v t_{M}(m)$ , (4.58) $illegibly (P, x, E)=P(x, E) \wedge illegible (E)$ , 其中 $illegible:\operatorname{Evt}_{M}(m) \rightarrow Prop$ 。毋庸置疑，与方式副词相关的真实推理由上述条目所捕捉。例如，上述定义将预测出像“他写[he wrote]”这样的句子总是跟随着“他写得难以辨认[he wrote illegibly]”。

这段文字主要在讨论如何在类型理论（特别是MTT）中处理副词，特别是表示方式的副词，如"illegibly"（难以辨认地）。

在这个框架中，事件被视为可以依赖于一个或多个主题关系的类型。例如，一个事件可以依赖于一个代理（Agent），也可以依赖于一个方式（Manner）。这种依赖关系可以用类型来表示，例如，依赖于代理的事件类型可以表示为$Evt_{A}(a)$，依赖于方式的事件类型可以表示为$Evt_{M}(m)$。

谓词（predicate）在这个框架中是用来描述事件的。对于非依赖事件，谓词可以假定为类型$A \rightarrow Event \rightarrow Prop$。对于依赖于方式的事件，谓词将是类型$(A \rightarrow Evt_{M}(m) \rightarrow Prop)$。这里的$A$是名词类型，$Prop$是命题类型。

方式副词在这个框架中被视为多态的谓词修饰符，具有类型$\Pi m: Manner. \Pi A: \mathsf{CN}. (A \rightarrow Evt_M(m) \rightarrow Prop ) \rightarrow \left(A \rightarrow E v t_M(m) \rightarrow\right. Prop )$。这里的$\Pi$表示多态性，即这个修饰符可以接受任何方式和名词类型，并返回一个新的谓词。

例如，副词"illegibly"（难以辨认地）可以定义为对于任意$P: A \rightarrow \operatorname{Evt}_{M}(m) \rightarrow \operatorname{Prop}$，$x: A$ 和 $E: E v t_{M}(m)$，$illegibly (P, x, E)=P(x, E) \wedge illegible (E)$。这里的$illegible:\operatorname{Evt}_{M}(m) \rightarrow Prop$是一个谓词，表示事件$E$是难以辨认的。

这种定义可以捕捉到与方式副词相关的真实推理。例如，如果一个人以难以辨认的方式写（"he wrote illegibly"），那么我们可以推断他写了（"he wrote"）。

---

> 重组一下语言，给定类型 $A$ 和 $B$ ，只有当 $A$ 和 $B$ 没有共同部分（正式称之为组件[components]）时，我们才能形成点类型 $A \bullet B$ 。例如，$\mathrm{{P\small HY}} \bullet \mathrm{{I\small NFO}}$ 是合法的点类型，而 $\mathrm{{P\small HY}}\bullet(\mathrm{{P\small HY}} \bullet \mathrm{{I\small NFO}})$ 是不合法的，因为在后者中，构成型 $\mathrm{{P\small HY}}$ 和 $\mathrm{{P\small HY}} \bullet \mathrm{{I\small NFO}}$ 共享了公共部分$\mathrm{{P\small HY}}$ 。此外，请注意点类型 $A \bullet B $ 同时也是其两个组成类型 $A $ 和 $B $ 的子类型。还要注意整个点类型形成基于组件概念。其定义如下： 定义 5.1（组件）。- 设 $T : Type$ 是一个空语境中的类型。那么，$\mathcal{C}(T)$，即 $T$ 的组件集合，定义为： 
>
> $$ \mathcal{C}(T)={ }_{d f} \begin{cases}\mathrm{S\small UP}(T) & \text { if the normal form of } T \text { is not of the form } X \bullet Y \\ \mathcal{C}\left(T_{1}\right) \cup \mathcal{C}\left(T_{2}\right) & \text { if the normal form of } T \text { is } T_{1} \bullet T_{2}\end{cases} $$ 
>
> 其中 $\mathrm{S\small UP}(T)=\left\{T^{\prime} \mid T \leq T^{\prime}\right\}$

这个公式定义了一个类型的"组件"（components）集合。组件是构成类型的基本元素。

这个定义有两部分：

1. 如果类型 $T$ 的正规形式（normal form）不是 $X \bullet Y$ 的形式，那么 $T$ 的组件集合就是 $T$ 的上集（superset），记作 $\mathrm{SUP}(T)$。上集是指包含 $T$ 的所有类型的集合，即 $\mathrm{SUP}(T)=\left\{T^{\prime} \mid T \leq T^{\prime}\right\}$。

2. 如果类型 $T$ 的正规形式是 $T_{1} \bullet T_{2}$，那么 $T$ 的组件集合就是 $T_{1}$ 的组件集合和 $T_{2}$ 的组件集合的并集，即 $\mathcal{C}\left(T_{1}\right) \cup \mathcal{C}\left(T_{2}\right)$。

这个定义的目的是为了确定一个类型的所有组件，以便于判断一个点类型（dot-type）是否合法。只有当一个点类型的两个组成类型没有共同的组件时，这个点类型才是合法的。

---

> 注意，在通常的非共谓情况下，相关名词之间的关系类似于“男人”和“人类”的关系：一个领域是另一个的子类型（如 $Man \leq Human$）。因此，其中一个名词继承了另一个名词的内涵条件，在相同意义上 $=_{M}$（名词 "man" 的内涵条件）继承了 $=_{H}$（名词 "human" 的内涵条件）。这种继承关系在许多情况下都会发生。这样的例子包括“男人”和“人类”，“红色桌子”和“桌子”，以及其他许多例子。为这种关系提供一个名称可能会很有用。以下定义完全相同。
>
> **定义 5.2（子集型[Sub-setoid]）**：我们说一个集合 $\mathsf{A}=(A,=_\mathsf{A})$ 是 $\mathsf{B}=(B, =_{\mathsf{B}})$ 的子集型，记作 $\mathsf{A} \sqsubseteq \mathsf{B}$，如果 $A \leq B$ 且 $=_{\mathsf{A}}$ 和 $\left.(=_\mathsf{B})\right|_{A}$ 相同（即 $=_\mathsf{B}$ 在 $A$ 上的限制）。我们通常用 $=_\mathsf{B}$ 来表示 $(=_{\mathsf{B}})|_{A}$ ，省略了限制运算符。
>
> 例如，除了 $\mathsf{M\small AN}\sqsubseteq \mathsf{H\small UMAN}$ 之外，我们还有$(RTable,=_{t}) \sqsubseteq( Table, =_t)$。其中 $R Table$ 是类型 $\Sigma x: Table.red (x)$ 表示红色桌子的域，而 $=_{t}$ 则表示桌子的等价关系（也继承给红色桌子）的辨衡。请注意，在像 $Man$ 或 $RTable$ 这样受限制的域中，辨衡与 $Human$ 和 $Table$ 的相同，并且在这种情况下，它们本质上是相同的，因此我们可以安全地忽略它们，并研究相关示例。

这段话在讨论子集型（Sub-setoid）的概念。子集型是一种特殊的集合关系，其中一个集合（称为子集型）是另一个集合的子集，并且子集型的等价关系（即集合中元素的相等性判断）与其父集合的等价关系在子集型的范围内是相同的。

例如，考虑 "Man" 和 "Human" 这两个集合。"Man" 是 "Human" 的子集，因为所有的 "Man" 都是 "Human"。同时，"Man" 集合的等价关系（即判断两个 "Man" 是否相等的规则）在 "Human" 集合中也是有效的。这就意味着 "Man" 是 "Human" 的子集型。

另一个例子是 "Red Table" 和 "Table"。"Red Table" 是所有红色的桌子的集合，它是 "Table" 的子集，因为所有的 "Red Table" 都是 "Table"。同时，"Red Table" 集合的等价关系（即判断两个 "Red Table" 是否相等的规则）在 "Table" 集合中也是有效的。这就意味着 "Red Table" 是 "Table" 的子集型。

这个概念在处理集合和子集时非常有用，因为它允许我们在处理子集时使用父集合的等价关系，这可以简化很多计算和推理过程。

---

> - complex objects are denoted with the + operator while plural objects with the $\oplus$ operator (assumes a join semilattice ála Link (1983));

在这个句子中，"join semilattice ála" 是一个术语。它指的是一种数学结构，用于描述集合中元素之间的关系。

具体来说，"join semilattice" 是一个数学概念，表示一个集合，在该集合上定义了一个二元操作（通常称为 "join"），并且满足结合律、交换律和吸收律等性质。这个操作可以将两个元素组合成一个更大的元素。

而 "ála Link (1983)" 则是引用了作者 Link 在 1983 年发表的相关论文或著作。这里使用 "ála" 表示类似于或以...方式。

整个句子的意思是：根据 Link (1983) 的观点，假设存在一种 join semilattice 结构。

以下是几个与此相似含义的英语例句：

1. The committee operates as a democracy á la ancient Greece.
   这个委员会运作方式类似于古希腊时期的民主制度。

2. She decorated her house in a minimalist style á la Scandinavian design.
   她以斯堪地纳维亚设计风格装饰她的房子。

---



在这个句子中，"Lexical entries" 指的是词汇条目。它们是指词典或语法中对于特定单词的定义和描述。

整个句子的意思是：在蒙塔古语法中，CI（或者IC？打错了？）和动词的词汇条目比传统上所认为的更加复杂。它们不仅决定了扩展性质，还进一步规定了一个独立性标准。

这里并没有使用到习语。但我可以给你一些类似含义的例子：

1) "Glossary entries" 是指术语表中对特定术语进行定义和解释。
2) "Dictionary definitions" 是指字典中对单词进行详细说明和定义。

---

> 