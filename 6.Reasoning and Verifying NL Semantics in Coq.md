# Reasoning and Verifying NL Semantics in Coq

本书一直在构建并探讨基于现代类型理论（MTTs）的自然语言语义（MTT-语义）。我们强调：MTT-语义同时具有**模型论**与**证明论**两方面的特征。作为一种证明论的形式体系，MTTs 已被实现于多种证明助手中——这些由计算机科学家开发的系统可用于交互式构造证明并机器校验正确性。由于 MTT-语义可以直接落地在这类系统里，MTT 基的证明助手便能高效开展语义推理（Luo 2011b; Chatzikyriakidis and Luo 2014, 2016）。

本章把这一路径统称为**证明助手技术**（proof assistant technology），展示如何在其中实现 MTT-语义，并把前几章提出的语义构造形式化用于推理。我们选用 Coq（Coq 2010）作为证明助手，其核心类型理论 pCIC 与我们所说的 UTT（Luo 1994）在本质上等同（见第 2 章）[^1]。因此，可以把本章在 Coq 中的实现视为在**内涵**类型理论 UTT 中实现 MTT-语义与推理。

[^1]: Coq 目前实现的类型理论与 UTT 基本一致，主要差别在于 Coq 支持**共归纳类型**（UTT 无此构造），以及若干细节变化。尤其自 2004 年起 Coq 中的集合层级 `Set` 变为可谓词化（此前是非谓的 impredicative）。另：Coq 的**记录类型**本质上就是 $\Sigma$-types（见第 2.2.2 节），本书在各章均有广泛使用（参见第 6.2.4 节）。

## Proof assistant technology based on MTTs

证明助手技术自 20 世纪 60 年代起发展，目标是**形式化数学**：交互式构造证明并由机器检查其正确性。一个里程碑式项目是 AUTOMATH（De Bruijn 1980），这是首个系统性运用 **Curry–Howard 同构**的系统，也展示了形式验证的可行性与前景[^2]。

[^2]: 参见 AUTOMATH ARCHIVE（http://www.win.tue.nl/automath/）及 Nederpelt 等（1994）的综述。

此后，众多成熟的证明助手相继出现，涵盖不同逻辑与类型理论。其中相当一部分直接实现了 MTTs，例如：Agda（Agda 2008）、Coq（Coq 2010）、Lean（De Moura et al. 2015）、Lego（Luo and Pollack 1992）、Matita（Mat 2008）、NuPRL（Constable et al. 1986）与 Plastic（Callaghan and Luo 2001）等。也有面向经典高阶逻辑的系统，如 Isabelle（Nipkow et al. 2002）、HOL（Gordon and Melham 1993）与 Mizar（Naumowicz and Korniłowicz 2009）。这些工具在数学与软件验证上取得了大量令人瞩目的成果，举例如下。

### Mathematical proofs

- **四色定理**：任何简单平面图可用四种颜色着色使相邻区域异色——已在 Coq 中形式化证明（Gonthier 2008）。
- **Feit–Thompson 定理**：每个奇数阶有限群皆可解——Coq 形式化（Gonthier et al. 2013）。
- **素数定理**：素数在正整数中的密度渐近为 $\frac{1}{\ln x}$——在 HOL 与 Mizar 中分别完成（Avigad et al. 2007; Hales 2007）。
- **Jordan 曲线定理**：平面上任一简单闭曲线把平面分成内外两个区域——Isabelle 形式化（Korniłowicz 2005）。

### Software verification

- **CompCert**：高可信 C（ISO C99 近全覆盖）编译器，核心在 Coq 中实现与验证（Leroy 2013）。
- **Coq in Coq**：在 Coq 中形式化构造演算（CoC）的定义与元理论（Barras and Werner 1997）。

总的来看，证明助手技术已相当成熟，相关社区活跃。而 MTT-语义在语义学中的发展也已具备相当完备度。在这样的背景下，系统性探讨“**如何把证明助手用于自然语言语义**”正当其时。本章接下来先简要介绍我们将依托的系统：**Coq**。

## A linguist friendly introduction to Coq

本节面向语义学读者，给出对证明助手 Coq（Coq 2010）的入门介绍，并用语义学小例子说明它的核心特征与使用动机。

直观地说，Coq 让我们在一个依赖类型的语言里，基于（预先定义或用户自定义的）**定义、参数、变量**等，检查某个**命题**是否可证。Coq 实现的是归纳构造演算（Calculus of Inductive Constructions, CiC；见 Coq 2010），也就是一种现代类型理论（MTT）。这与我们书中用于语义解释的 UTT 高度契合：可以把 Coq 当作“会说我们语义学语言”的推理引擎。与自然语言语义的结合至少有两条常用路径：(1) 把 Coq 当**形式检查器**，验证你给出的语义分析在系统内是否成立；(2) 做**自然语言推理（NLI）**，在 Coq 中实现语义并对NL结论进行演绎验证。

**安装（简要）：**Coq 可从官网获取并在各平台安装[^3]，也可用 MacPorts、Homebrew 或 Nix。Mac/Linux 上推荐配合 Proof General[^4]（Emacs 前端）。如前所述，从非常粗略的角度看，Coq 的实现语言与本书第 2 章介绍的 UTT 的主要差别在于：Coq 还支持**共归纳类型**（本书未用到）。其他一些小差异与本章实现无关，读者可忽略。

### Basics of Coq: types, sorts, functions

在 Coq 中，一切对象都有**类型**。用 `Check` 可查看对象的类型：

```coq
Coq < Check nat.
nat : Set

Coq < Check 1.
1 : nat
```

这里，自然数类型 `nat` 属于宇宙 `Set`，而常量 `1` 属于类型 `nat`。再看宇宙本身：

```coq
Coq < Check Set.
Set : Type
```

Coq 采用**宇宙层级**（universes）：存在无限多层谓词性的 `Type_i`，另有一个**非谓词**的命题宇宙 `Prop`。这与 UTT 的设置一致（见第 2.3 节）。粗略而言，Coq 中常见三类宇宙：`Prop`（命题）、`Set`（常用数据类型所在地）与更一般的 `Type`（统摄前二者）[^5][^6]。

要**声明**新对象（如类型），可用 `Variable` 或 `Parameter`：

```coq
Coq < Variable H : Set.
H is assumed
Warning: H is declared as a parameter because it is at a global level

Coq < Parameter H : Set.
H is assumed

Coq < Section S.
Coq < Variable H1 : Set.
H1 is assumed
```

若在**全局**用 `Variable`，效果与 `Parameter` 等同；若在 `Section` 内声明，则其作用域仅限该小节。**定义**的一般形态是：

(6.1) $Definition\ \mathrm{ident} : \text{term}_1 := \text{term}_2$

系统会检查 $\text{term}_2$ 的类型与 $\text{term}_1$ 是否定义相等，然后将 `ident` 登记为类型 $\text{term}_1$ 的常量，取值为 $\text{term}_2$。

以最熟悉的 Montagovian 设定为例：设实体类型 $\mathbf{e}$ 属于 `Set`，真值类型 $\mathbf{t}$ 取 `Prop`。谓词 `Man : e -> t` 可这样给出：

```coq
Parameter e : Set.
Definition t := Prop.
Parameter Man : e -> t.
```

进一步定义常见的一元谓词 `man`（语义上就是 $\lambda x.\,Man(x)$）：

```coq
Definition man := fun x : e => Man x.
```

`fun` 即 $\lambda$ 抽象。若询问 `man` 的类型，Coq 会自动推断。也可**显式注解**类型：

```coq
Definition man : e -> t := fun x : e => Man x.
```

再看一个非语言学的玩具例子：**平方函数**。它取一个自然数，返回自身乘积：

```coq
Definition square := fun x : nat => x * x.
```

我们既可以 `Check` 类型，也可**求值**：

```coq
Eval compute in square 3.
     = 9 : nat
```

同理，应用到语义上也可直接化简：

```coq
(* 假设已声明 e、t 与 Man、man、John 等 *)
Eval compute in man John.
     = Man John : Prop
```

Coq 在此告诉我们：将 `man` 作用于 `John` 的结果是命题 `Man John`，其类型为 `Prop`——正是我们所期望的。

---

[^5]: 在 Coq 的早期版本中，`Set` 是**非谓词**的；自 Coq 8.0（2004）起，`Set` 改为**谓词**（见第 127 页脚注 1）。
[^3]: 下载地址见 http://coq.inria.fr/download.
[^4]: Proof General 主页：https://proofgeneral.github.io.
[^6]: 形式上，写作 `Type : Type` 会触发 Girard 悖论，但在 Coq/UTT 这并非问题：实际存在一条无限上升的层级 $Type_0, Type_1, \dots$，`Set : Type_0`，且 $Type_i : Type_{i+1}$。Coq/LEGO 通过 **typical ambiguity** 隐去这些下标；可用命令 `Set Printing Universes` 查看具体分配。
[^7]: 上述 `man` 与 `Man` 在 Coq 中通过 $\eta$-变换等价。

### The proof engine of Coq

本节介绍 Coq 的证明引擎。处于“证明模式”时，用户通过一组预定义（或自定义）的**策略**（tactics）逐步把当前目标化简直至可证。为说明其工作方式，我们先在**命题逻辑（PL）**里做一个极简示例。定义三个命题变量，并给出要证的传递律定理：

```
Parameters P Q R : Prop.
Theorem trans :
  (P -> Q) -> (Q -> R) -> (P -> R).
```

`Theorem` 会把 Coq 置入证明模式。常用的第一步是 `intro`（或 `intros`）把蕴含式的前件引入为假设、把结论留在目标处。连用三次 `intro` 后，目标是要证明 $R$，上下文中已有三个假设 $H,H0,H1$：

```
1 subgoal
H:  P -> Q
H0: Q -> R
H1: P
============================
R
```

接着可用 `apply H0`：若所应用的假设/引理的结论与目标匹配（此处为 $Q\to R$ 的结论 $R$），则目标改为其前提 $Q$（这就是“演绎推理/小前提规则”）：

```
H: P -> Q
H0: Q -> R
H1: P
============================
Q
```

再 `apply H`：

```
H: P -> Q
H0: Q -> R
H1: P
============================
P
```

此时目标与假设一致，可用 `assumption`（或 `exact H1`）结束。最后 `Qed` 关闭证明。

---

现在看个更有意思的例子：**从排中律推出皮尔斯律**。约定（下文默认 $A,B:Prop$）：

```
Definition lem := A \/ ~ A.
Definition Peirce := ((A -> B) -> A) -> A.
Theorem lemP :
  lem -> Peirce.
```

先把定义**展开**（`unfold`）：

```
1 subgoal, subgoal 1 (ID 5)
H0 : A \/ (A -> False)
H2 : (A -> B) -> A
============================
A
```

对析取假设用 `elim H0`（相当于析取的消去规则），得到两个子目标：

```
H0: A \/ (A -> False)
H2: (A -> B) -> A
============================
A -> A
subgoal 2 (ID 7) is:
(A -> False) -> A
```

第一个子目标用 `intros` 后可直接 `assumption`。第二个子目标再 `intros`，并应用 $H2$，把目标化为需要证明 $A\to B$：

```
1 subgoal, subgoal 1 (ID 10)
H0: A \/ (A -> False)
H2: (A -> B) -> A
H3: A -> False
============================
A -> B
```

继续 `intro` 一个 $A$ 的实例，然后用 `absurd A`（荒谬法）：它会把目标转为同时证明 $A$ 与 $\neg A$ 从而得出 `False`：

```
H0: A \/ (A -> False)
H2: (A -> B) -> A
H3: A -> False
H4: A
============================
~ A
subgoal 2 (ID 14) is:
A
```

两个子目标分别由假设 $H3$ 与 $H4$ 即得，证明完成。

---

### Useful proof tactics in Coq

这一小节按常见**连接词**简要汇总常用策略（更多可参考 Chlipala 的表格[^8]）。随后用一个蒙塔古传统的小例子做示范。我们把 Montagovian 的 $\mathbf{e}$ 设为 `Set`，$\mathbf{t}$ 设为 `Prop`，并定义三个经典的类型转换算子（仅作说明，不深嵌其底层类型系统）：

```
Definition e : Set.
Definition t := Prop.

(* 恒等关系 *)
Definition Ident :=
  fun x : e => fun y : e => x = y.

(* 提升为广义量词 *)
Definition Lift :=
  fun x : e => fun P : e -> t => P x.

(* Montague 的 BE-type lowering *)
Definition BE :=
  fun P : (e -> t) -> t =>
  fun x : e => P (fun y : e => y = x).
```

[^8]: 依据 Adam Chlipala 的速查表整理：http://adam.chlipala.net/itp/tactic-reference.html。

| Connective                    | Introduction tactics                                      | Elimination tactics                                          |
| ----------------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| $\wedge$（合取）              | `split`（或 `constructor`）                               | `elim`（或 `induction`）                                     |
| $\vee$（析取）                | `left`, `right`                                           | `elim`（或 `induction`）                                     |
| $\Rightarrow$（蕴含）         | `intro [a]`, `intros [a b H]`, `intros until a`           | `apply t`，`apply t (a:=t)`                                   |
| `False`                       | —                                                         | `absurd`                                                     |
| `Exists`（存在）              | `exists t`                                                | `elim`（或 `induction`）                                     |
| `Forall`（全称）              | `intro [a]`, `intros [a b H]`, `intros until a`           | `elim`（或 `induction`），`subst`，`replace`                 |
| $=$（相等）                   | `reflexivity`，`symmetry`，`transitivity t`，`congruence` | `rewrite [<-]`，`rewrite [<-] t in H`，`subst`，`replace`     |
| $\neg$（否定）                | —                                                         | `intro`（把 $\neg A$ 看作 $A\to False$）                     |

接着给出若干常量、谓词与量词 `a`（some）和 `every`（every）：

```
Parameter man woman human : e -> t.
Parameter j m h : e.

Definition a :=
  fun P Q : e -> t => exists x : e, P x /\ Q x.
Definition every :=
  fun P Q : e -> t => forall x, P x -> Q x.
```

简单求值示例：

```
Eval compute in Lift j.
     = fun P : e -> t => P j
     : (e -> t) -> t

Eval compute in BE (a man) j.
     = exists x : e, man x /\ x = j
     : t
```

二者的类型与化简结果均符合直觉。

现在做个小推理：从 “John is a man” 推出 “存在某个实体等于 John”。

```
Theorem BE1 :
  BE (a man) j -> exists x : e, x = j.
```

用 `unfold` 展开 `BE`，再 `intro`：

```
1 subgoal, subgoal 1 (ID 11)
H0 : exists x : e, Man x /\ x = j
============================
exists x : e, x = j
```

对存在式用 `elim H0`：

```
1 subgoal, subgoal 1 (ID 12)
H0 : exists x : e, Man x /\ x = j
============================
forall x : e, Man x /\ x = j -> exists x0 : e, x0 = j
```

`intros` 引入：

```
1 subgoal, subgoal 1 (ID 14)
H0 : exists x : Set, Man x /\ x = j
x  : e
H2 : Man x /\ x = j
============================
exists x0 : Set, x0 = j
```

对合取用 `elim H2`：

```
1 subgoal, subgoal 1 (ID 15)
H0 : exists x : Set, Man x /\ x = j
x  : e
H2 : Man x /\ x = j
============================
Man x -> x = j -> exists x0 : e, x0 = j
```

再次 `intros`：

```
1 subgoal, subgoal 1 (ID 17)
H0 : exists x : Set, Man x /\ x = j
x  : e
H2 : Man x /\ x = j
H3 : Man x
H4 : x = j
============================
exists x0 : e, x0 = j
```

此时由 $H4$ 立即构造到结论（例如 `exists x; assumption`），定理得证。

---

再快速梳理几个常用等式与结构化策略，并给出一个小例子：

- **`reflexivity`（自反）**：证明形如 $A=A$ 的目标。  
- **`symmetry`（对称）**：把目标 $A=B$ 化为已知 $B=A$。  
- **`transitivity`（传递）**：由 $A=B$ 与 $B=C$ 推 $A=C$。  
- **`idtac`**：占位，不改变目标；常用于复合策略脚本中。  
- **`cut`**：若有 $t_1:Q\to P$ 与 $t_2:Q$，可一并引入把目标转为 $P$。  
- **`induction`**：如 `induction x` 把目标拆成对 $x$ 的结构性子目标，并结合 `elim` 生成分支。

例：同时用到对称与传递。

```
Theorem symmetry_transitivity :
  forall n m n1 : nat,
    n = m /\ m = n1 -> n = n /\ n = n1 /\ m = n.
```

`intros` 后 `destruct H` 再 `split`，即可得到：

```
2 subgoals, subgoal 1 (ID 26)
n, m0, n1 : nat
H0 : n = m0
H2 : m0 = n1
============================
n = n

subgoal 2 (ID 27) is:
n = n1 /\ m0 = n
```

第一个子目标 `reflexivity` 即证；对第二个子目标 `split`，然后分别用 `rewrite`/`transitivity` 及 `symmetry` 配合已有等式化解，证明完成。

---

最后提到几招**自动化**：

1. `auto`：在 `intros`、`apply`、`split`、`left/right`、`reflexivity` 的封闭世界里自动搜索。  
2. `eauto`：`auto` 的存在量词增强版（如 `eapply` 可引入存在的占位变量）。  
3. `tauto`：命题逻辑（直觉主义）层面的重言式判定。  
4. `firstorder`：一阶直觉主义逻辑的自动化。

更多策略与全面介绍，可参阅 Bertot & Castéran（2004）、Coq（2010）、Chlipala（2013）。

### Inductive types and record types

本节简要介绍 Coq 中两类非常实用的类型：**归纳类型**与**记录类型**[^9]。先看一个最普通的类型声明：

```
Parameter A : Type.
```

[^9]: 关于归纳类型可参见第 2.2 节。Coq 的“记录类型”本质上就是带有命名投影符号的 $\Sigma$-types（参见第 2.2.2 节），而非独立的 record 系统；更严格的记录语义可参考 Pollack (2002) 与 Luo (2009a,b)。

上面只声明了一个类型 $A$，但没有说明它的元素如何构造、具有什么性质。**归纳类型**恰好用来说明“这个类型的元素如何被构造”。例如，Coq 中布尔类型的定义：

```
Inductive bool : Set := true | false.
bool is defined
bool_rect is defined
bool_ind  is defined
bool_rec  is defined
```

这条定义引入集合类型 `bool`，给出两个构造子 `true` 与 `false`，并自动生成三类消去/归纳算子。比如 `bool_ind` 允许我们对任意 $b:\texttt{bool}$ 做分类证明（要么是 `true`，要么是 `false`）。该类型没有递归成分，因此是**非递归**的归纳类型。

含递归的典型例子是自然数类型 `nat`：

```
Inductive nat : Set :=
| O : nat
| S : nat -> nat.
nat is defined
nat_rect is defined
nat_ind  is defined
nat_rec  is defined
```

归纳类型由其构造子**穷举**给定类型的全部元素；对应产生的归纳原理 `nat_ind` 就是 Peano 归纳：若某性质对 $0$ 成立且对后继闭合（对 $n$ 成立则对 $S\,n$ 也成立），则对所有 $n$ 成立。`nat_rect` 和 `nat_rec` 则用于在自然数上定义函数。更具体地：`nat_ind` 用于 $Prop$ 宇宙上的归纳证明，并可通过 `nat_rect` 定义；`nat_rect` 工作在更大的 $Type$ 宇宙；`nat_rec` 面向 $Set$ 宇宙。Coq 中它们的签名为：

```
Print nat_ind.
nat_ind =
fun P : nat -> Prop => nat_rect P
     : forall P : nat -> Prop,
       P 0 ->
       (forall n : nat, P n -> P (S n)) ->
       forall n : nat, P n

nat_rect
  : forall P : nat -> Type,
    P 0 ->
    (forall n : nat, P n -> P (S n)) ->
    forall n : nat, P n
```

注意 `nat_rec` 也可由 `nat_rect` 得到；`nat_rect` 定义在 $Type$ 上，因而同时覆盖 $Set$ 与 $Prop$，这解释了它为何能作为二者的统一基元。

---

**记录类型**可视为“只有一个构造子”的特殊归纳类型，用来把若干字段打包在一起。举个和语义学相关的例子：假设我们不满足于把 Montagovian 的实体类型 $\mathbf e$ 当作一个不带结构的集合，而想用一个带**依赖字段**的记录来刻画“是人类”的限制：

```
Record Entity : Set := mkentity { x : e; z : human x }.
```

于是 $Entity$ 是一个 `Set` 类型，包含字段 `x : e` 与依赖字段 `z : human x`。这是一个**依赖记录类型**：`z` 的类型依赖于 `x`。熟悉 Cooper 的 TTR（Type Theory with Records）会立刻意识到，用 Coq 的依赖记录可以自然表达大量 TTR 风格的语义结构[^10]。

[^10]: Coq 的依赖记录机制足以编码 TTR 的许多常见构造。

接下来给出一个更贴近本书 MTT 语义立场的例子。第 3.3 节中提到，形容词修饰（至少交叉/子集修饰这两类）可以用 $\Sigma$-type 编码[^11]；在 Coq 里，依赖记录与 $\Sigma$-type 等价，因此我们可以直接用**依赖记录**来写修饰后的名词：

```
Definition CN := Set.
Parameters Animal Object Delegate Human : CN.
Parameter Irish : Human -> Prop.
Axiom dh : Delegate -> Human. Coercion dh : Delegate >-> Human.

Record Irishdelegate : CN := mkIrishdelegate
  { c :> Delegate;  C : Irish c }.
```

[^11]: 详见第 2.2.2 节关于 $\Sigma$-types 及其与依赖记录的对应关系。

解释如下：第一行把语义里的 $\mathsf{CN}$ 暂以 `Set` 近似[^12]；随后声明若干 $\mathsf{CN}$ 类型，并给出谓词 `Irish : Human -> Prop`。`Axiom dh` 配合 `Coercion` 说明 `Delegate` **强制**为 `Human` 的子类型（强制转换/强制子类型化）。最后定义记录 `Irishdelegate`：字段 `c :> Delegate` 前的 `:>` 声明其**第一投影是强制转换**，也就是把 `Irishdelegate` 看作 `Delegate` 的子类型（同时借由前面的强制，也就看作 `Human` 的子类型）。因此我们能直接得到如下推理：如果有某个爱尔兰代表会走路，则存在某个代表会走路；进一步也得到存在某个人会走路：

```
Theorem delegate1 :
  some Irishdelegate walk -> some Delegate walk.
  cbv. firstorder. Qed.

Theorem delegate2 :
  some Irishdelegate walk -> some Human walk.
  cbv. firstorder. Qed.
```

[^12]: Coq 目前不允许用户自定义新的宇宙层级（与 Plastic 等系统不同），因此这里用 `Set` 近似 $\mathsf{CN}$，尽管理想情况它应是一个独立宇宙。

以上是对 Coq 中归纳类型与记录类型的速览。下一步我们将在 Coq 里形式化前文的语义构造，并通过可机证的推理来检验它们的正确性与可用性。

## MTT-semantics in Coq

本节用 Coq 实现 MTT 语义，覆盖本书已讨论的大部分现象，并通过推理检验其形式正确性。所给代码力求自包含；按现象分类的完整版本见附录 A7。若干通用约定（如：普通名词的基础设置、子类型关系、基本量词）如下，详见附录 A7.1：

```
Definition CN := Set.

(* Common Nouns as Types *)
Parameters Woman Man Human : CN.

Parameters Mary Helen : Woman.
Parameters John George : Man.

(* Subtyping relations *)
Axiom mh : Man -> Human.   Coercion mh : Man   >-> Human.
Axiom wh : Woman -> Human. Coercion wh : Woman >-> Human.

(* Some quantifiers *)
Definition some := fun A : CN => fun P : A -> Prop => exists x : A, P x.
Definition all  := fun A : CN => fun P : A -> Prop => forall  x : A, P x.
```

加载上述通用部件后，附录 A7.2–A7.9 彼此独立可用。A7.2 实现了第 3.2.2 节的同形异义（本节不再赘述）。

### Adjectival and adverbial modification

先给出形容词的基本分类：**交叉型**（intersective）与**子集型**（subsective）。交叉型形容词用普通谓词表示；子集型形容词是跨 $\mathsf{CN}$ 的多态谓词。

```
Parameter Irish : Human -> Prop.
Record Irishhuman : CN := mkirishhuman
  { h :> Human; I : Irish h }.

(* Skilful as a polymorphic type *)
Parameter skilful : forall A : CN, A -> Prop.
Record Skilfulhuman : CN := mkskilfulhuman
  { h1 :> Human; S : skilful Human h1 }.
```

如第 3.3 节所述，交叉型的 *Irish* 是 $Human \to Prop$ 的简单谓词；*skilful* 则以 $\Pi$（在 Coq 中写作 `forall`）形式多态于 $\mathsf{CN}$[^13]。修饰后的名词用 $\Sigma$-type（在 Coq 中为依赖记录）实现，记录首字段后的 `:>` 声明其为强制投影，因而有 $\Sigma(Human, Irish)\leq Human$；在代码里即 $Irishhuman \leq Human$、$Skilfulhuman \leq Human$。与 UTT 不同，Coq 的强制子类型不会自动经由类型构造子（此处为 $\Sigma$）向外传播，这是 Coq 的一个限制；因此需要在推理中显式使用构造子携带的子类型信息。相关推理示例见附录 A7.3.14[^14]。

[^13]: $\Pi$-types 见第 2.2.1 节；交叉/子集型形容词的语义见第 3.3 节。
[^14]: 另见附录 A7.4，对 “fake” 的初步规范化分析。

接下来处理**多维形容词**。第 4.4 节提出以枚举类型收纳相关维度。以 *healthy* 为例，定义健康维度 `Health`，并给出 *sick* 与 *healthy* 的存在/全称量化差异[^15]：

```
Definition Degree := Set.
Inductive Health : Degree := Heart | Blood | Cholesterol.

Parameter Healthy : Health -> Human -> Prop.

Definition sick    := fun y : Human => ~(forall x : Health, Healthy x y).
Definition healthy := fun y : Human =>   forall x : Health, Healthy x y.
```

由此可得预期推论：若某人 *healthy*，则在胆固醇、血压、心脏等各维度上均满足；而 *sick* 只需在某一维度上不满足。更多定理见附录 A7.5。

[^15]: 关于 “Degree” 的更细化设置见第 4.2 节的可度量形容词；对多维形容词而言，上述简单版本足够。

随后编码**可度量形容词**。为容纳度量宇宙，我们采用 Tarski 风格的宇宙（与第 2.3.3 节的对比可参见原文）。其基本骨架如下：

```
(* Degree is the type of names of degrees; d : Degree corresponds to type D d *)
Require Import Omega.
Inductive Degree : Set := HEIGHT | AGE | IDIOCY.
Definition D (d : Degree) := nat.
Definition Height := D HEIGHT.
Definition Age    := D AGE.
Definition Idiocy := D IDIOCY.
```

把宇宙扩展到索引化的名词与上下文标准函数 $STND$（第 4.2 节）：

```
(* Universe CN_G of indexed CNs *)
Definition CN_G (_ : Degree) := Set.

Parameter STND :
  forall d : Degree, forall A : CN_G d, ADJ d A -> D d.
```

有了 $STND$，即可定义 *tall* 与比较级：

```
Definition tall (h : Human) :=
  ge (height h) (STND HEIGHT Human TALL).

Definition taller_than (h1 h2 : Human) :=
  gt (height h2) (height h1).
```

比较级的性质、以及第 4.3 节讨论的可度量名词的实现见附录 A7.6。

继续到副词修饰。先看**真实性**（veridicality）副词（第 4.5.1 节）。对句子级真实性定义 $VER_{PROP}$，并证明 “fortunately, John walks” 蕴含 “John walks”：

```
Definition VER_PROP (Q : Prop) := forall P : Prop, P -> Q.
Definition fortunately := VER_PROP.

Theorem VER1 :
  fortunately (walk John) -> walk John.
  cbv. firstorder. apply H with (fortunately (walk John)).
  cbv. firstorder. Qed.
```

更多如式 (4.51)、(4.52) 的性质及 VP 级真实性见附录 A7.7。

作为**方式副词**的样例，按第 4.5.2 节的依赖事件类型思路，令 $Evt_m$ 为依赖于方式 $m$ 的事件类型（此处将 `Manner : Set` 作为参数），则 *illegibly* 可写为：

```
Definition illegibly :=
  fun (m : Manner) (A : CN)
      (P : A -> Evt_m m -> Prop) (x : A) (E : Evt_m m) =>
    P x E /\ illegible_m E.
```

据此可证明：

(6.2) John wrote illegibly $\Rightarrow$ John wrote in an illegible manner.

完整证明见附录 A7.8。

### Copredication and individuation in Coq

本节形式化第 5.3.3 与 5.3.4 节的点类型，并验证与量化/计数的相互作用。关键目标是刻画著名的“双重区别性”：

(6.3) John picked up and mastered three books $\Rightarrow$ John picked up three physical objects and mastered three informational objects.

首先将普通名词解释为 **setoid**（类型 $+$ 该类型上的等价关系），而非单纯类型。为此改造 $\mathsf{CN}$：令 $DomCN$ 为基础域，$\mathsf{CN}$ 为包含等价关系的记录：

```
(* CN as Setoids: second projection is the equivalence relation *)
Record Equiv (A : DomCN) : Type := mkEquiv
  { eq1 :> A -> A -> Prop;
    _eq2 : reflexive A eq1
         /\ symmetric  A eq1
         /\ transitive A eq1 }.

Record CN := mkCN
  { B  :> DomCN;
    B2 :  Equiv B }.
```

以 $\mathsf{HUMAN}$ 为例：其域为 `Human`，辨衡为其上的等价关系：

```
(* IC for Human and def of HUMAN *)
Parameter IC_Human : Equiv Human.

(* CN types in capitals are the setoids *)
Definition HUMAN := mkCN Human IC_Human.
```

如第 5.3.1 节所述，“Man” 的辨衡从 “Human” 继承。先以 `AIC_Man` 指定其在 `Human`-等价之下判同（省略自反/对称/传递证明，见附录 A7.9）：

```
Definition AIC_Man := fun x : Man => fun y : Man => IC_Human x y.

Definition IC_Man := mkEquiv Man AIC_Man EQ.
Definition MAN    := mkCN   Man IC_Man.
```

于是可轻易证明：

(6.4) Three men walk $\Rightarrow$ three humans walk.[^16]

[^16]: 证明见附录 A7.9。

接着给出专用于本章的点类型实例：只为 $\mathrm{P\small HY}$ 与 $\mathrm{I\small NFO}$ 构造点类型，足以支撑示例（更通用的点类型实现可参见 Xue & Luo 2012 在 Plastic 中的版本）。

```
(* Defining the dot type PhyInfo and declaring the coercions *)
Record Phyinfo : DomCN := mkPhyInfo
  { p :> Phy; i :> Info }.

Parameter book : DomCN.

Axiom bf : book -> PhyInfo.
Coercion bf : Book >-> PhyInfo.
```

分别给出组成类型的辨衡，并包装为 setoid：

```
Parameter IC_Phy  : Equiv Phy.
Parameter IC_Info : Equiv Info.
Definition PHY  := mkCN Phy  IC_Phy.
Definition INFO := mkCN Info IC_Info.
```

点类型上的“预集对象”关系（第 5.3.4 节）取两边等价之析取：

```
Definition AIC_PhyInfo :=
  fun a1 : PhyInfo => fun b1 : PhyInfo =>
    IC_Phy  a1.(p) b1.(p) \/
    IC_Info a1.(i) b1.(i).

Theorem EQ1 :
  reflexive PhyInfo AIC_PhyInfo /\ symmetric PhyInfo AIC_PhyInfo.
  cbv. destruct IC_Phy.  firstorder.
      destruct IC_Info. firstorder. Qed.

Definition IC_PhyInfo := mkEquiv_K PhyInfo AIC_PhyInfo EQ1.
Definition PHYINFO    := mkCN_K  PhyInfo IC_PhyInfo.
```

把 “book” 的两种辨衡分别立起后，即可证明双重区别性目标（略去若干词法与量词展开的样板）：

```
Theorem copred_dd2 :
  (three Book)
    (and PhyInfo (picked_up John) (mastered John))
  -> exists x y z : Book,
       not (PHY.(E)  x y)  /\ not (PHY.(E)  y z)  /\ not (PHY.(E)  x z)
    /\ picked_up John x   /\ picked_up John y   /\ picked_up John z
    /\ not (INFO.(E) x y) /\ not (INFO.(E) y z) /\ not (INFO.(E) x z)
    /\ mastered  John x   /\ mastered  John y   /\ mastered  John z.
```

完整实现（含与形容词交互的量化共谓，如式 (5.49)）见附录 A7.9。

### Related work

用证明助手处理自然语言语义的工作并不多，但影响深远：Ranta (1993)、Luo & Callaghan (1997) 将证明助手用于数学通俗语（MV）；Hallgren & Ranta (2000) 扩展 ALF 支持自然语言 I/O；Ranta & Cooper (2004) 构建了面向对话语义的系统。基于 Coq 的 MTT 语义最早见于 Luo (2011b)。Chatzikyriakidis & Luo (2014) 证明 Coq 可用于 NLI，并在 FraCaS（Cooper et al., 1996）的部分数据上取得良好结果，但该方案预设了解析。Mineshima et al. (2015) 将广覆盖 CCG（Clark & Curran 2007）解析接入 Coq，FraCaS 近半子集上准确率 0.69。Bernardy & Chatzikyriakidis (2017) 将 GF（Ranta 2011）与 Coq 对接，基于 FraCaS 的 GF 树库（Ljunglöf & Siverbo 2012）实现语义映射，近半子集上准确率 0.83；其后续工作（2019）引入动态语义以处理回指/省略，采用两阶段管道（Haskell 转换器 + Coq 组合器），准确率 0.89，并且据我们所知，是唯一覆盖 FraCaS 回指与省略部分的运行系统。此外，Zwanziger (2019) 使用 agda-flat 形式化了一种依赖类型的蒙塔古语义。

总体而言，证明助手技术不论在理论还是工程层面，都是形式语义的有力工具。希望本章的实现与推理示例，能为在类型理论或其他合适逻辑框架下的语义验证/形式化，以及诸如 NLI 之类的任务，提供可复用的范式与实践经验。