## Modern Type Theories

现代类型理论（MTT）是一种计算形式系统，涵盖了对逻辑系统全新且实用的多种基本机制。例如，类型理论中的“断言”[judgments]概念，这种声明断言用于进行断言推导[assertions]，其中涉及的“语境”[context]机制可以有效地描述语言语义中的情境（或不完全的可能世界）。

MTT类型结构丰富，比蒙塔古箭头类型 $A \rightarrow B$ 要丰富得多。除了逻辑命题（即根据Curry-Howard命题即类型原理的命题证明类型（Curry和Feys 1958; Howard 1980）），它还有很多其他类型，可以在构建形式语义学时用于各种表现目的。在语言语义研究中，人们讨论过多序逻辑系统[many-sorted logical systems]或多序集合论域[multisorted set-theoretical domains]。正如Link所说：

> 语言对象涉及各种类型，在结构特性上各有不同。因此，语言和哲学话语的宇宙自然便是一个多元序域[multi-sorted domain]，所有这些对象都在其中。(Link 1998, 前言)。

MTTs 不仅仅是多序系统，而且这些“序[sorts]”或说是类型结构非常强大且丰富。包括可用于解释逻辑操作、名词、形容词修饰、副词修饰、协同[coordination]以及更高级的特性，例如子类型化、共指谓词和语言强制转换等等。除了功能强大之外，这些类型还很好管理；例如，在某种意义上，给定 $a$ 和 $A$ 可以决定 $a$ 的类型是否是 $A$ 这种类型检查。这样做的结果很好，诸如此类类型理论可基于命题即类型原则而具有逻辑。

上述两个方面，即语境机制和丰富的类型，对于MTT成为形式语义学强有力的基础性语言至关重要。本章中，我们将在第2.1节介绍断言概念及相关的语境机制，并在第2.2节和第2.3节中介绍几种类型构造器。MTT中现有的语境机制通过罗（2014年、2019年a）所引入新的签名[signature]概念而得到丰富，这能充分给出不完整世界的语义表示。另一个必不可少的机制是子类型：在第2.4节中，我们将研究MTT（因此也适用于MTT-语义学） 的强制子类型框架（Luo 1999；Luo等人2012）。第2.5节将给出MTTs 完整而正式的描述(Luo 2019a)，这主要是为了内容完备而非理解(因此大多数读者可以安全跳过)。

## Judgments and contextual mechanisms

在本节中，我们将介绍断言的概念和相关的语境机制，并且说明这种机制如何被用来描述情境。[^1]

[^1]: 对于对“断言”一词历史感兴趣的人来说，它在逻辑学中的使用可以追溯到弗雷格。马丁-勒夫（1975）在发展他的类型理论时引入了形为$\Gamma \vdash a: A$ 的断言，这将在本书中通过签名进行丰富。

**断言/Judgments**。在MTT中，最基本的概念是断言，它们是用来作出推导断言的陈述。典型的断言如(2.1)，它声明“ $a$ 对象在 $\Gamma$ 语境和 $\Delta$ 签名下类型为 $A$ （ps:在给定的语境$\Gamma$和签名$\Delta$下，对象$a$是类型$A$的成员）"。[^2]

(2.1) $\Gamma \vdash_{\Delta} a: A$

[^2]: 关于符号的注释：传统上用$\Sigma$来表示签名。我们选择使用$\Delta$而不是$\Sigma$，是以免与本书中经常使用的$\Sigma$类型混淆。

MTT中类型表示对象的集合。作为集合的一种表示，类型非常类似集合论中的集合，即便它是一个句法实体，通常通过证明理论规则归纳定义。直观地说，上述断言（2.1）说明，在环境 $\Delta$ 和 $\Gamma$ 假设下（有关签名和语境概念，请参见下文），$a$ 是 $A$ 集合的一个对象。例如，我们可以断定以下断言，暂时省略 $\Delta$ 和 $\Gamma$：

(2.2) $John : Man$

这句话表明 $John$ 是一个男人，其中“$Man$”类型表示所有男性的合集。

要注意，断言不是逻辑公式。我们不能对断言用否定[negation]和合取[conjunction]等逻辑算符。如果我们否定了（2.1）这个断言，则结果将不再是断言：（2.1）的“否定”，通常写作 $\Gamma \nvdash_{\Delta} a: A$，这并非断言，只是声明断言（2.1）不正确（或者在正式术语中说，(2.1) 是无法推导出来的）的元层次陈述[meta-level statement]。 （有关此方面进一步讨论，请参见第3.2.3节。）

MTT中的类型结构非常丰富，为语义学家提供了足够和有用的工具来构建形式语义。例如，类型可以是逻辑命题的证明（或证明对象）合集 - 这是命题即类型原理的基础。例如，如果$A$是一个逻辑命题的证明合集，则(2.1) $a$ 便是该命题的证明。这在类型论内部提供了一致性逻辑以用于语义构造。在接下来的几节中，我们将介绍几个类型构造器以说明如何在语义研究中使用它们。但在此之前，我们将解释断言中涉及到的其他概念 - 签名和语境这两种背景机制。

**签名和语境机制/Signatures and contextual mechanisms。**在逻辑术语中，MTT中的语境机制描述了基础环境和为做出断言而进行的假设。例如，在语义学研究中，一个人可能想要描述做出断言的情况（或不完整的可能世界）。在语言学中，“语境”一词用于指代那些围绕着交际事件的对象或实体，为其适当解释提供资源。在MTT-语义学中，我们可以使用语境机制作为某些语言背景的正式代表。[^3]

[^3]:目前尚不清楚签名和语境的正式概念在多大程度上接近于非正式的语言环境概念。这个问题超出了我们当前讨论的范围。

在类型理论的通常表述中，没有签名，并且断言只涉及语境，该语境由成员条目组成，形式为 $\Gamma \vdash a: A$，其中语境 $\Gamma$ 是变量-类型对的有限序列。

(2.3) $x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n}$

其中假设$x_{i}$是类型$A_{i}(i=1, \ldots, n)$的变量。注意语境中的这些类型可能取决于“先前”的变量：$x_{1}, \ldots, x_{i-1}$可能在$A_{i}$中自由出现。例如，语境$\Gamma$可以包含条目(2.4)：

(2.4) $x: Man,  y: handsome(x)$

假设 $x$ 是一个英俊的（任意）男人（通过假设 $y$ 是证明 $x$ 英俊的任意证据）。由于它们可以抽象为语境条目形成命题，所以假定实体 $x$ 和 $y$ 是变量，例如 $\forall x: Man \forall y: handsome (x).\neg ugly(x)$ 。[^4]

[^4]:从形式上讲，变量可以通过量化或$\lambda$抽象来进行抽象，如下所示的规则（参见第2.3.1节和附录A3.1）：$\frac{\Gamma \vdash_{\Delta} \text { A type } \Gamma, x: A \vdash_{\Delta} P: \text { Prop }}{\Gamma \vdash_{\Delta} \forall x: A . P: \text { Prop }}$ 当起始语境为(2.4)时，可以通过两次应用上述规则形成命题$\forall x: Man \forall y: handsome (x).\neg ugly(x)$ 。

在自然语言语义学中，人们可以使用语境来表示情境。但是，使用语境这样做存在问题。其中一个问题是应该通过假设常量[constants]而不是变量来表示情境。例如，我们可能有这样一种情况：约翰是男人。然而，将 $John: Man$ 作为语境条目会使得对 $John$ 进行抽象以形成 $\forall John:Man.P(John)$ 等式，显然这并不合适——约翰不是任意的男人。另一个问题是仅使用成员条目通常很难表示更复杂的情况，如无限情境（因为语境总是有限的）。[^5]

[^5]:如第1.4.2节所述，传统的语境概念被Ranta（1994）和其他人用来表示情境。在那里，不考虑变量和常量之间的区别。我们考虑声明常量的签名（Luo 2014），而不是声明变量的语境 - 我们的签名可能包含其他形式的条目，以允许灵活地表示复杂情况，如无限情况（请参见第2.4节和第2.5节）。然而，在语境中添加这些新形式的条目并不容易：特别是它们元理论研究相当复杂，并且一直是一个困难的开放性问题。相反，将它们作为签名中的条目添加更容易。签名概念最初在爱丁堡逻辑框架（Harper等人1993）发展引入类型理论中，其标记仅包含成员条目。本节我们只使用成员条目，并稍后研究具有新形式条目扩展功能的标记。

这就是为什么我们在断言形式（2.1）等中使用了签名 $\Delta$ 。签名类似于语境，但又有所不同。相似之处在于签名也是有限序列条目，就像（2.3）中的语境一样。不同之处在于，首先，除了形式为 $c:A$ 的成员条目之外，还可以有其他形式的条目（见下文），其次，签名中的条目引入的是常量而不是变量。一般而言，只包含成员条目的签名具有以下形式：

(2.5) $c_{1}: A_{1}, c_{2}: A_{2}, \ldots, c_{n}: A_{n}$

就像语境中的条目一样，在签名的条目中给定的假设在推理中都得到了考虑。然而，有一个关键的区别：签名中的成员条目 $c: A$ 声明 $c$ 是类型为 $A$ 的常量对象。这与上面所示的声明 $x: A$ 不同，后者声明 $x$ 是一个可以通过量化等方式抽象的变量。在签名中声明的常量永远不会被抽象化 - 这就是为什么它们被称为常量的原因。因此，签名能够充分表示语言意义上的情境，而语境则不能。[^6]

[^6]:另外，由于在签名中声明的常量不能被抽象化，从元理论的角度来看，向签名中添加新的条目形式比向语境中添加更容易（参见第2.5节）。

在语境和签名分别为(2.3)和(2.5)的情况下，判断(2.1)的一般形式如下(2.6)，其中我们的签名中只有成员项。

(2.6) $x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n} \vdash_{c_{1}: A_{1}^{\prime}, c_{2}: A_{2}^{\prime}, \ldots, c_{n}: A_{n}^{\prime}} a: A$

签名将在稍后正式介绍。在这里，我们举一个例子来展示如何通过仅使用传统成员条目来表示情况的方法。

**以签名表示情境/Representing situations by signatures：一个简单的例子**。这里，我们使用 Luo（2014）中给出的例子来说明如何使用签名来表示情境。我们的例子很简单，例如，该例子中的情境域是有限的。这将作为我们讨论的基础，探讨如何表示涉及无限或其他更复杂的特殊情境。

*例2.1- 该例子摘自Saeed（1997）的第10章，描述了1962年利物浦的Cavern Club里的一个（假想的）情境，当时披头士乐队正在为演出进行排练。这个情境可以如下所示：*

1. *情境的领域包括几个人，包括披头士乐队的成员（约翰、保罗、乔治和林戈）、他们的经理（布莱恩）和一位歌迷（鲍勃）。可以通过以下标记 $\Delta_{1}$ 来表示：*

$$
\begin{aligned}
\Delta_{1}= & D: \text { Type, } \\
& \text { John }: D, \text { Paul }: D, \text { George }: D, \text { Ringo }: D, \text { Brian }: D, \text { Bob }: D
\end{aligned}
$$

2. *赋值函数将谓词符号，如 $B$ 和 $G$ ，分别赋予表示“是一位披头士乐队成员”和“弹吉他”的命题函数。我们可以在我们的签名中引入以下内容来表示这样的赋值函数：*

$$
\begin{aligned}
\Delta_{2}= & B: D \rightarrow Prop , b_{J}: B( John ), \ldots, b_{B}: \neg B( Brian ), b_{B}^{\prime}: \neg B(Bob), \\
& G: D \rightarrow Prop , g_{J}: G(John ), \ldots, g_{G}: \neg G(Ringo), \ldots
\end{aligned}
$$

*代表这种情况的标记将采用形式 $\Delta \equiv \Delta_{1}, \Delta_{2}, \ldots$ 。例如，我们将有：*
$$
\vdash_{\Delta} G(J o h n)\ true \text { and } \vdash_{\Delta} \neg B(B o b) \ true
$$
*在这里，$G(John)$ 和 $B(Bob)$ 在语义上分别解释为约翰弹吉他和鲍勃是甲壳虫乐队成员。*[^7]

[^7]:严格地说，$\Gamma \vdash_{\Delta} A\ true$ 表示的是"对于某个 $a$，$\Gamma \vdash_{\Delta} a: A$ 成立"这一陈述。

在上面的例子中，我们使用签名来表达部分（或不完全）世界，就像人们通常在集合论模型中所做的那样。请注意，语言学中的语境概念（即语言语境）通常模糊地描述了前一句为解释后一句而设置了一个环境的连续句子。其中一些解释会涉及类型构造器，比如 $\Sigma$ — 在第2.2.2节末尾的示例中可以看到。

## Type constructors

在MTTs中，存在着多种归纳定义的类型构造器。在本节中，我们介绍了几种典型的类型构造器，包括本书中将要使用的构造器。

### $\Pi$-Types of dependent functions

现代类型理论包含依赖类型，典型为依赖函数的 $\Pi$ 类型。当 $A$ 是一个类型，$B$ 是依赖于 $A$ 对象的类型族[family of types]时，$\Pi x: A . B(x)$，有时写作 $\Pi(A, B)$，表示 $\lambda$-函数 $f$ 的类型，满足对于任意 $a: A$，应用 $f$ 到 $a$ 后的结果 $f(a)$ 是类型 $B(a)$ 的实例。

请注意，应用 $f(a)$ 的类型 $B(a)$ 取决于输入 $a$，这使得 $\Pi$ 类型成为一种依赖类型。例如，我们可以有一个族群 $C h i l d(x)$ — 对于每个 $x:Human$ ，$C h i l d(x)$ 是 $x$ 的子代类型 ，其中 $Human$ 类型是人类本身。那么，依赖函数 $f$ 的类型是 $\Pi x :Human.Child (x)$ ，对于任何 $h:Human$ ，$f(h)$ 的类型是 $Child (h)$ — $h$ 的一个子代。

型在非依赖情况下退化为普通的函数类型 $A \rightarrow B$ ，即第二个参数 $B$ 是常数类型时。更精确地说，当  $B(x)$ 是一个常数类型（即无论 $x$ 是什么，类型总是相同）时，$\Pi$ 型 $\Pi x: A . B(x)$ 就退化为我们熟悉的非依赖函数类型。例如，关于 $Man$ 的谓词类型就是函数类型 $Man \rightarrow Prop$，其中 $Prop$ 是所有逻辑命题的类型宇宙。

$\Pi$ 类型是归纳定义的。正式地说，每一个归纳类型构造器都是通过推理规则来指定的，这些推理规则采用自然演绎的方式，被称为形成规则、引入规则、消除规则以及计算规则。对于 $\Pi$ 类型，我们有以下形成规则，告诉我们如何合法地形成一个 $\Pi$ 类型：
$$
(\Pi)\qquad \frac{\Gamma \vdash_{\Delta} A \text { type }\quad \Gamma, x: A \vdash_{\Delta} B \text { type }}{\Gamma \vdash_{\Delta} \Pi x: A . B \text { type }}
$$
引入规则告诉我们， $\Pi$ 型对象是什么：
$$
(Abs)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B}{\Gamma \vdash_{\Delta} \lambda x: A . b: \Pi x: A . B}
$$
$\Pi$ 类型的消除规则指定了应用(application)运算符的行为，其中 $[a / x] B$ 表示通过"将 $B$ 中的 $x$ 替换为 $a$ "获得的项（即，将所有自由出现的 $x$ 替换为 $a$ ）：例如，如果 $B$ 是 $\operatorname{Child}(x)$ ，那么 $[h / x] B$ 就是 $\operatorname{Child}(h)$ 。
$$
(App)\qquad\frac{\Gamma \vdash_{\Delta} f: \Pi x: A . B\quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta} f(a):[a / x] B}
$$
应用操作符通过以下计算规则（通常称为 $\beta$ 规则）获得其含义，该规则规定了应用的行为：
$$
(\beta)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B \quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta}(\lambda x: A . b)(a)=[a / x] b:[a / x] B}
$$
请注意，如上所述，假设 $x: A$，那么lambda表达式的主体 $b$ 的类型就是 $B$ ，而 $b$ 和 $B$ 可能都依赖于 $x$（即，$x$ 可能在它们中出现自由）- 这就是类型依赖。关于 $\Pi$ 类型的上述推理规则也可以在附录A2.1中找到。

以上面的例子来解释，当一个类型为 $\Pi x : Human. Child (x)$ 的函数 $f$ （或者，用另一种记法，$\Pi (Human, Child)$ ）应用到一个人 $h$ 时，它的image $f(h)$ 必须是 $h$ 的孩子，即类型 $Child (h)$，而不是其他东西。
