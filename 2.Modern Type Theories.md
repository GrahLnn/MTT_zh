## Modern Type Theories

现代类型理论（MTT）是一套可计算的形式系统，为逻辑与语义提供了一组务实而有力的机制。其核心概念是“断言”（judgments）与“语境”（context）：通过在语境中推导断言，可以精确刻画语言中的情境（或不完全的可能世界）。

与蒙塔古体系里仅有箭头类型 \(A \rightarrow B\) 的格局不同，MTT 的类型结构极为丰富。除了承载逻辑命题（借 Curry–Howard 的“命题即类型”原则；Curry & Feys 1958；Howard 1980），还提供多样的类型构造，可在形式语义建模中承担不同角色。语义学中常谈“多序”逻辑或“多序”集合论域；正如 Link 所说：

> 语言对象分属多种类型，且结构特征各异。因此，语言与哲学话语的宇宙天然是一个多序域（multi-sorted domain），各种对象共处其中。（Link 1998，前言）

MTT 不止是“多序”。这些“序”（sorts）——也即类型——拥有强劲而细粒度的结构，足以解释：逻辑联结与量词、名词与其修饰、动词短语的副词修饰、并列（coordination），以及更高阶的机制，如子类型化、共指谓词与强制（coercion）等。更重要的是，这些类型“可管理”：在给定项 \(a\) 与类型 \(A\) 的前提下，能判定断言 \(a:A\) 是否成立（类型检查可判定）。配合 Curry–Howard，逻辑联结与量词以类型构造落地，语义与推理同构到可执行的计算规约之上。

上述两点——语境机制与富类型——是 MTT 成为强力“基础语义语言”的关键。本章的组织如下：§2.1 介绍断言与语境；§2.2–§2.3 给出主要类型构造器。基于 Luo（2014；2019a），我们以“签名”（signature）扩展传统语境，从而充分表达不完全世界的模型信息。另一项必要机制是子类型：§2.4 讨论适用于 MTT（因而也适用于 MTT 语义）的“强制子类型”框架（coercive subtyping；Luo 1999；Luo et al. 2012）。为完整起见，§2.5 汇总给出 MTT 的形式化定义（Luo 2019a）；该节偏技术性，理解本书主线并不依赖于它，读者可按需略读。

## Judgments and contextual mechanisms

本节给出“断言”（judgments）及其配套的语境机制，并说明如何用它们描述情境（situations）。[^1]

[^1]: “断言”在逻辑史上可追至弗雷格。Martin-Löf（1975）在其类型理论中引入 \(\Gamma \vdash a:A\) 形式的断言；本书在此基础上以“签名”（signature）加以扩展。

**断言 / Judgments。** 在 MTT 中，基本对象是断言。典型形状如（2.1）：在语境 \(\Gamma\) 与签名 \(\Delta\) 下，项 \(a\) 的类型为 \(A\)。

(2.1) \(\ \Gamma \vdash_{\Delta} a: A\)

[^2]: 记号说明：传统常以 \(\Sigma\) 表示签名。为避免与 \(\Sigma\)-类型混淆，本文记签名为 \(\Delta\)。

类型把“对象的合集”以语法方式表示——它们是由证明论规则归纳给定的句法实体，但在语义上对等于集合论中的“集合”。以（2.2）为例（暂略 \(\Gamma,\Delta\)）：

(2.2) \(\ John : Man\)

表示 “John 是男性”，其中 \(Man\) 是“所有男性”的类型。

断言不是逻辑公式，不能对其施加否定、合取等联结。所谓“否定”（常写作 \(\Gamma \nvdash_{\Delta} a:A\)）并非新断言，而是元层面的陈述：断言（2.1）不可推导（见 §3.2.3）。

在 MTT 中，类型结构足够丰富以承载语义构造。依照“命题即类型”（Curry–Howard），某些类型即“命题的证明之类型”；若 \(A\) 是某命题之证明的类型，则（2.1）中的 \(a\) 就是该命题的一个证明。由此在类型论内部得到一致的“内建逻辑”，可直接用于语义建模。下文将引介若干类型构造器；在此之前，先给出与断言并行的两类背景机制：语境与签名。

**签名与语境 / Signatures and contextual mechanisms。** 语境机制用于描述做出断言时的背景与假设。在语义学中，这类背景可理解为“情境”（或“不完全可能世界”）。语言学中，“语境”通常指围绕言语事件的对象与关系，为解释提供资源；在 MTT-语义中，可用形式化的语境机制来呈现这类背景。[^3]

[^3]: 形式化的“签名/语境”与语言学上非正式的“语境”之间的贴合度并不明朗，本文不深究。

在类型论的常规呈现里通常**没有**签名，只有语境 \(\Gamma\)：它是变量—类型对的有限序列

(2.3) \(\ x_{1}:A_{1},\ x_{2}:A_{2},\ \ldots,\ x_{n}:A_{n}\)

其中 \(x_i\) 是类型 \(A_i\) 的变量，且 \(A_i\) 可依赖先前变量 \(x_1,\ldots,x_{i-1}\)。例如

(2.4) \(\ x:Man,\ \ y:handsome(x)\)

表示“取一任意男性 \(x\)，并假定有证据 \(y\) 表明 \(x\) 英俊”。变量可被抽象以形成命题，如 \(\forall x:Man\,\forall y:handsome(x).\ \neg ugly(x)\)。[^4]

[^4]: 形式上，变量可由量化或 \(\lambda\) 抽象出去；如（见 §2.3.1 与附录 A3.1） $$\frac{\Gamma \vdash_{\Delta} A:\text{Type}\quad \Gamma,x:A \vdash_{\Delta} P:\text{Prop}}{\Gamma \vdash_{\Delta} \forall x:A.\ P:\text{Prop}}$$ 从（2.4）出发，连用两次即可得到 \(\forall x:Man\,\forall y:handsome(x).\ \neg ugly(x)\)。
若要**直接**用“语境”来表示具体情境会遇到两难。其一，情境往往涉及**常量**而非变量；如“John 是男人”，把 \(John:Man\) 放进语境就允许形成 \(\forall John:Man.\ P(John)\) 之类的抽象，明显不当——John 并非“任意男性”。其二，语境是有限序列，仅靠“成员条目”难以表示更复杂甚至无限的情境。[^5]

[^5]: 早期做法（如 Ranta 1994）用语境来呈现情境，并不区分常量与变量。本文转而使用**签名**（Luo 2014）：签名声明常量，且可增添新型条目以灵活表示复杂或无限情境（见 §2.4、§2.5）。把这些新条目并入“语境”在元理论上困难；加入“签名”则可控。签名概念源自 Edinburgh Logical Framework（Harper et al. 1993），起初只含“成员条目”。本节先仅用成员条目，后续再扩展。

这正是（2.1）中加入签名 \(\Delta\) 的理由。签名与语境同为有限条目序列，但差异在于：除成员条目 \(c:A\) 外还可容纳其他条目形式；且签名条目**引入常量**而非变量。仅含成员条目的签名形如

(2.5) \(\ c_{1}:A_{1},\ c_{2}:A_{2},\ \ldots,\ c_{n}:A_{n}\)

在推导中，签名条目与语境条目一样作为假设使用。关键区别：\(c:A\) 声明的是一个**常量对象**；而 \(x:A\) 声明的是可被量化/抽象的**变量**。签名中的常量不可抽象，因此能恰当承载“具体情境”的信息，而语境不宜胜任。[^6]

[^6]: 也因此，从元理论角度看，给“签名”增添新条目形式要比给“语境”增添容易（见 §2.5）。

当语境与签名分别如（2.3）、（2.5）时，断言（2.1）的通式为：

(2.6) \(\ x_{1}:A_{1},\ldots,x_{n}:A_{n}\ \vdash_{\,c_{1}:A_{1}',\ldots,c_{m}:A_{m}'}\ a:A\)

下例示范仅用“成员条目”的签名如何表示情境。

**用签名表示情境：一个简单例子。** 取 Luo（2014）的例子：域有限，便于演示；复杂（无限）情境的表示方法随后讨论。

*例 2.1（改写自 Saeed 1997，第 10 章）。情境：1962 年，利物浦 Cavern Club，披头士在排练。*

1) *情境域含若干人物：披头士四人（John、Paul、George、Ringo）、经纪人 Brian、歌迷 Bob。用下述签名 \(\Delta_1\) 表示：*
\[
\Delta_{1}=\ \ D:\text{Type};\quad
John:D,\ Paul:D,\ George:D,\ Ringo:D,\ Brian:D,\ Bob:D
\]

2) *赋予谓词符号含义：\(B\) 表“披头士成员”，\(G\) 表“会弹吉他”。在签名中写作：*
\[
\begin{aligned}
\Delta_{2}=\ & B:D\to Prop,\quad b_{J}:B(John),\ \ldots,\ b_{B}:\neg B(Brian),\ b_{B}':\neg B(Bob),\\
             & G:D\to Prop,\quad g_{J}:G(John),\ \ldots,\ g_{G}:\neg G(Ringo),\ \ldots
\end{aligned}
\]

*整个情境的签名为 \(\Delta \equiv \Delta_{1},\Delta_{2},\ldots\)。例如：*
\[
\vdash_{\Delta} G(John)\ \text{true}\qquad\text{以及}\qquad \vdash_{\Delta} \neg B(Bob)\ \text{true}
\]
*此处 \(G(John)\) 与 \(B(Bob)\) 的语义分别为“John 会弹吉他”“Bob 不是披头士成员”。*[^7]

[^7]: 严格说，\(\Gamma \vdash_{\Delta} A\ \text{true}\) 代表“存在某个 \(a\) 使得 \(\Gamma \vdash_{\Delta} a:A\)”的元陈述。

本例用签名来表达“部分（不完全）世界”，与集合论模型的做法相仿。语言学中“语境”常指由前句逐步设定的解释背景；这些解释在形式化时会用到类型构造器（如 \(\Sigma\)），见 §2.2.2 末尾的示例。

## Type constructors

在 MTTs 中，有多种以归纳方式给出的类型构造器。本节选取若干典型构造器——也是全书后续会用到的——加以说明。

### $\Pi$-Types of dependent functions

现代类型理论包含依赖类型，最常见的是“依赖函数类型”$\Pi$。当 \(A\) 为一种类型、而 \(B\) 是以 \(A\) 的对象为自变量的类型族（family of types）时，\(\Pi x:A.\,B(x)\)（亦写作 \(\Pi(A,B)\)）表示那类 $\lambda$-函数 \(f\) 的类型：对任意 \(a:A\)，应用 \(f\) 得 \(f(a)\) 的类型为 \(B(a)\)。

要点：结果类型 \(B(a)\) 依赖输入 \(a\)。例如，设 \(Human\) 为“人类”之类型，并对每个 \(x:Human\) 给出其子嗣类型族 \(Child(x)\)。则依赖函数的类型为 \(\Pi x:Human.\,Child(x)\)。给定 \(h:Human\)，有 \(f(h):Child(h)\)。

当 \(B(x)\) 与 \(x\) 无关（即为常量类型）时，\(\Pi\)-型退化为通常的函数类型：\(\Pi x:A.\,B \cong A\to B\)。例如，“关于 \(Man\) 的谓词”的类型即 \(Man\to Prop\)，其中 \(Prop\) 是（在相关体系中）“全部逻辑命题”的类型。

\(\Pi\) 型以归纳规则给出。每个归纳型均由自然演绎式的**形成**、**引入**、**消除**与**计算**规则刻画：

- **形成规则 / formation**
\[
(\Pi)\qquad 
\frac{\Gamma \vdash_{\Delta} A\ \text{type}\quad \Gamma,x:A \vdash_{\Delta} B\ \text{type}}
     {\Gamma \vdash_{\Delta} \Pi x:A.\,B\ \text{type}}
\]

- **引入规则 / introduction（抽象）**
\[
(Abs)\qquad
\frac{\Gamma,x:A \vdash_{\Delta} b:B}
     {\Gamma \vdash_{\Delta} \lambda x:A.\,b:\Pi x:A.\,B}
\]

- **消除规则 / elimination（应用）**
\[
(App)\qquad
\frac{\Gamma \vdash_{\Delta} f:\Pi x:A.\,B\quad \Gamma \vdash_{\Delta} a:A}
     {\Gamma \vdash_{\Delta} f(a):[a/x]B}
\]
其中 \([a/x]B\) 表示在 \(B\) 中以 \(a\) 替换自由出现的 \(x\)；若 \(B=\operatorname{Child}(x)\)，则 \([h/x]B=\operatorname{Child}(h)\)。

- **计算规则 / computation（$\beta$）**
\[
(\beta)\qquad
\frac{\Gamma,x:A \vdash_{\Delta} b:B\quad \Gamma \vdash_{\Delta} a:A}
     {\Gamma \vdash_{\Delta} (\lambda x:A.\,b)(a)=[a/x]b:[a/x]B}
\]

如上，若假定 \(x:A\)，则抽象体 \(b\) 的类型为 \(B\)，且 \(b\) 与 \(B\) 均可依赖 \(x\)。以上关于 \(\Pi\) 的规则亦见附录 A2.1。直观地：若 \(f:\Pi x:Human.\,Child(x)\)，则对任意 \(h:Human\)，必有 \(f(h):Child(h)\)，而非其他类型。

与“宇宙”（universe）结合时，\(\Pi\) 还给出多态性机制，见 §2.3。

### $\Sigma$-types of dependent pairs

另一典型依赖型是 \(\Sigma\)-类型。若 \(A\) 是类型、\(B\) 为以 \(A\) 的对象为自变量的类型族，则 \(\Sigma x:A.\,B(x)\)（或 \(\Sigma(A,B)\)）由满足 \(a:A\) 且 \(b:B(a)\) 的**对** \((a,b)\) 组成。配套的**投影**满足：对 \(p=(a,b):\Sigma x:A.\,B(x)\)，\(\pi_1(p)=a\)、\(\pi_2(p)=b\)。

例：设 \(Man\) 为男性之类型，\(handsome:Man\to Prop\) 为“英俊”的谓词（因命题即类型，谓词值亦为类型）。则 \(\Sigma x:Man.\,handsome(x)\) 是“英俊男性”的类型；其对象形如 \((m,p)\)，其中 \(m:Man\)、\(p:handsome(m)\)。注意 \(handsome(x)\) 依赖 \(x\)，故 \(\Sigma x:Man.\,handsome(x)\) 是依赖型。

非依赖情形给出笛卡尔乘积：若 \(W(x)\equiv Woman\) 为常量族，则
\[
Man\times Woman \;\cong\; \Sigma x:Man.\,W(x).
\]

\(\Sigma\) 型同样以归纳规则刻画：

- **形成规则 / formation**
\[
(\Sigma)\qquad
\frac{\Gamma \vdash_{\Delta} A\ \text{type}\quad \Gamma,x:A \vdash_{\Delta} B\ \text{type}}
     {\Gamma \vdash_{\Delta} \Sigma x:A.\,B\ \text{type}}
\]

- **引入规则 / introduction（配对）**[^8]
\[
(pair)\qquad
\frac{\Gamma \vdash_{\Delta} a:A \quad \Gamma \vdash_{\Delta} b:[a/x]B \quad \Gamma,x:A \vdash_{\Delta} B\ \text{type}}
     {\Gamma \vdash_{\Delta} (a,b):\Sigma x:A.\,B}
\]

[^8]: 为便于阅读，略去部分实现层面的类型标注；严格表述中，对偶元的类型信息需显式保留以支持类型推断。

- **消除规则 / elimination（投影）**
\[
\frac{\Gamma \vdash_{\Delta} p:\Sigma x:A.\,B}{\Gamma \vdash_{\Delta} \pi_1(p):A}
\qquad
\frac{\Gamma \vdash_{\Delta} p:\Sigma x:A.\,B}{\Gamma \vdash_{\Delta} \pi_2(p):[\,\pi_1(p)/x\,]B}
\]

- **计算规则 / computation**
\[
\frac{\Gamma \vdash_{\Delta} a:A \quad \Gamma \vdash_{\Delta} b:[a/x]B}
     {\Gamma \vdash_{\Delta} \pi_1(a,b)=a:A}
\qquad
\frac{\Gamma \vdash_{\Delta} a:A \quad \Gamma \vdash_{\Delta} b:[a/x]B}
     {\Gamma \vdash_{\Delta} \pi_2(a,b)=b:[a/x]B}
\]

这些规则见附录 A2.2。直觉上，若 \((m,p):\Sigma x:Man.\,handsome(x)\)，则必有 \(p:handsome(m)\)，即第二分量之类型依赖第一分量。

当第二自变量为命题族 \(P(x):Prop\) 时，\(\Sigma x:A.\,P(x)\) 可表达“子集”构造：对每个 \(x:A\)，\(P(x)\) 是命题、因而亦是类型[^9]，于是 \(\Sigma\)-型成立。上面的“英俊男性”即属此例。更一般地，带“交集”语义的形容词修饰（modified CN）可用 \(\Sigma\) 给出（Ranta 1994；详 §3.3）。

[^9]: 在诸如 UTT 的非归谓（impredicative）类型理论中，命题与类型的关系见 §2.3.1。

\(\Sigma\)-型常可视作“元组型”，并可嵌套。形如
\[
\Sigma x_1:A_1\ \Sigma x_2:A_2\ \cdots\ \Sigma x_n:A_n
\]
可用“记录式”记号表示为[^10]
\[
\left\{
\begin{array}{lll}
x_1 & : & A_1\\
x_2 & : & A_2\\
\vdots & & \\
x_n & : & A_n
\end{array}
\right\},
\]
其对象直观上是 \(n\)-元组。

[^10]: 该“记录”记号在编程语言中用于（非依赖）记录类型；Luo（2009b）用于表示 \(\Sigma\)-型，Luo（2009a）用于依赖记录型；DTS（Bekki 2014）亦采用相近记法。

例如：
\[
\tag{2.7} \Sigma x:Man.\,handsome(x)
\]
可写为
\[
\tag{2.8}
\left\{
\begin{array}{ll}
\text{name}   & :\ Man\\
\text{hproof} & :\ handsome(\text{name})
\end{array}
\right\},
\]
其中 `name` 与 `hproof` 为绑定变量[^11]。

[^11]: 在支持“$\Sigma$-记录”的 Coq（2010）中，此类字段名本质上由投影算子定义。

除了解释形容词修饰，\(\Sigma\) 亦常用于组织语义表示，尤其适合刻画“前句为后句设定解释背景”的篇章效应。例：
\[
\tag{2.9}\text{A man walked in. He lit a cigarette.}
\]
其一种语义表示为
\[
\tag{2.10}
\Sigma z:\big[\Sigma x:Man.\ \text{walk\_in}(x)\big].\ \exists y:\text{Cigarette}.\ \operatorname{light}(\pi_1(z),y),
\]
若用记录式写作
\[
\tag{2.11}
\left\{
\begin{array}{l}
s_1:\left\{
\begin{array}{l}
x:Man\\
w:\text{walk\_in}(x)
\end{array}\right\}\\[6pt]
s_2:\ \exists y:\text{Cigarette}.\ \operatorname{light}(x,y)
\end{array}
\right\},
\]
其中 \(s_1,s_2\) 分别对应（2.9）的第一、二句，且第二句在类型上依赖第一句所引入的实体 \(x\)。

需注意，我们在（2.10）–（2.11）里**同时**使用了 \(\Sigma\) 与存在量词 \(\exists\)（\(\exists\) 有时称“弱和”（weak sum），见 §2.3.1）。在如 UTT 这类非归谓体系中，两者并存为语义构造打开了新路径——以往难以做到。相关地，关于含回指与计数的“驴句”（由 *most* 触发）的满意解释，见第 16 页脚注 26 及 Luo（2019b）。

### Disjoint union types, unit types and finite types

除前述构造外，MTTs 还包含一类常用的归纳类型——**不相交并（直和）类型**。当 \(A,B\) 为类型时，\(A + B\) 亦为类型，其对象要么形如 \(\operatorname{inl}(a)\)（其中 \(a:A\)），要么形如 \(\operatorname{inr}(b)\)（其中 \(b:B\)）。在 MTTs 中**没有**与集合论“并集”对应的**并集类型**[^12]。不相交并类型是在不破坏类型理论关键性质（如可判定的类型检查）的前提下，进行类型合成的可行方式。其正式归纳规则见附录 A2.3。

[^12]: 并集/交集类型作为一阶构造会显著增强表达力，但会牺牲诸如类型检查可判定性等良好性质。参见 Hayashi（1991）与后续文献；未类型化 \(\lambda\)-演算中的交集类型，见 Coppo & Dezani-Ciancaglini（1980）；Coppo 等（1980）。

不相交并类型配合**强制子类型化**（§2.4）可用来刻画**否定形容词**对普通名词的修饰（Luo 2011a；Chatzikyriakidis & Luo 2013, 2017a）。例：设真枪的类型为 \(G_R\)，假枪为 \(G_F\)，则可取
\[
G \;=\; G_R + G_F
\]
表示“枪”的全域（详见 §3.3.3）。

**有限类型**（finite types）亦可归纳给出。其中特例是**单位类型**（unit type）：仅含一个对象。记号取 \(\mathbf{1}_w\)，表示唯一定元为 \(w\) 的单位类型。相关推理规则见附录 A2.4。

---

## Universes

直观地，**宇宙**（universe）是“类型之类型”。Martin-Löf（1975）将宇宙引入类型理论后，使许多“以类型为值”的概念得以内部化。例：给定自然数类型 \(Nat\) 与非依赖乘积构造 \(\times\)（即特例化的 \(\Sigma\)，见 §2.2.2），可定义类型值函数
\[
f(n)\;=\;\underbrace{Nat\times\cdots\times Nat}_{n\ \text{个因子}}
\]
对任意 \(n:Nat\)，返回 \(n\) 元笛卡尔积类型。**若无类型宇宙**，此类“以类型为值”的函数在体系内不可定义[^13]。

[^13]: 直观理由：归纳类型（如 \(Nat\)）的消除通常不允许直接“落到类型层”构造新类型；一旦有“承载类型本身”的宇宙存在，方可定义以上 \(f\) 之类的类型值函数。技术细节从略。

本书将先引入两类宇宙：§2.3.1 的**逻辑宇宙 \(Prop\)** 与 §2.3.2 的**语义宇宙**；§2.3.3 给出两种将宇宙引入类型理论的正式做法之概要。

### \(Prop\) and logical propositions

在如 UTT 的**非归谓**（impredicative）类型理论中，逻辑命题组成宇宙 \(Prop\)。若 \(A\) 为类型、\(P:A\to Prop\) 为其上的谓词，则
\[
\forall x:A.\ P(x)
\]
是命题（亦写 \(\forall(A,P)\)）。当第一参数本身是命题（因“命题即类型”，也是类型），且 \(x\) 不自由出现于第二参数时，\(\forall x:P.\ Q\) 表示 \(P\Rightarrow Q\)。例如
\[
\tag{2.12}\text{If a man is handsome, he is not ugly.}
\]
可形式化为
\[
\tag{2.13}\forall x:Man.\ handsome(x)\Rightarrow \neg ugly(x).
\]

依 Curry–Howard，“命题即类型”使命题带有**证明对象**。设
\[
\tag{2.14} A \;=\; \forall P:Nat\to Prop.\ \forall x:Nat.\ P(x)\Rightarrow P(x),
\]
取
\[
\tag{2.15} p \;=\; \lambda P:Nat\to Prop.\ \lambda x:Nat.\ \lambda y:P(x).\ y,
\]
则
\[
\tag{2.16} p:A
\]
可推导成立。亦即：当且仅当存在证明对象时，公式才为真；上例中 \(A\) 为真，因为有见证 \(p\)。

\(Prop\) 与全称量词的推理规则见附录 A3.1。其**形成**规则为
\[
(\forall)\qquad
\frac{\Gamma \vdash_{\Delta} A:\text{Type}\quad \Gamma,x:A \vdash_{\Delta} P:Prop}
     {\Gamma \vdash_{\Delta} \forall x:A.\ P:Prop }.
\]
由于 \(Prop\) 是**非归谓宇宙**，可对 \(Prop\) 自身（甚至“更大”的类型）量化，构造仍落在 \(Prop\) 中。例如 \(\forall X:Prop.\ X\) 是 \(Prop\) 中的式子，但它为**假**：它断言“一切命题都可证明”，与一致性相冲突。

在非归谓设定下，可用 \(\forall\) 定义其余联结与量词（见附录 A3.2）。如：
\[
\tag{2.17} P\wedge Q \;=\; \forall X:Prop.\ (P\Rightarrow Q\Rightarrow X)\Rightarrow X
\]
\[
\tag{2.18} \exists x:A.\ P(x) \;=\; \forall X:Prop.\ \big(\forall x:A.\ (P(x)\Rightarrow X)\big)\Rightarrow X.
\]
还可定义**莱布尼茨等式**：对任意 \(A\) 与 \(a,b:A\)，
\[
\tag{2.19}
(a={}_A b) \;=\; \forall P:A\to Prop.\ P(a)\Rightarrow P(b).
\]

**备注。** \(\forall x:A.\ P(x)\) 与 \(\Pi x:A.\ P(x)\) 形似，差别在于：\(\forall\) 可取**非归谓**形式，而 \(\Pi\) 的形成总为**归谓**（不能表达非归谓量化）。一些体系（如 ECC：Luo 1994；Coq 2010）重载记号，使 \(\forall x:A.\ P(x)\) 亦可写为 \(\Pi x:A.\ P(x)\)。

### Universes in linguistic semantics

宇宙（universe）之所以重要，在于它把一族类型作为“内部整体”来操控，并且与 \(\Pi\) 类型配合，可给出**多态/通用**（\(\Pi\)-polymorphic）的语义规格。在 MTT 语义中，常用的两个例子是 \(\mathsf{CN}\)（普通名词的宇宙）与 **LTYPE**（“语言类型”的宇宙）。以下用它们说明：宇宙与相关的 \(\Pi\) 多态如何高效支撑语义构造。

<img src="https://gitee.com/grahlnn/typora_img/raw/master/20251001200548.png" alt="image-20230604230843879" style="zoom:50%;" />

> Figure 2.1. \(\mathsf{CN}\) 宇宙示意

**普通名词的宇宙 \(\mathsf{CN}\)。** 按 Luo（2011b, 2012b），\(\mathsf{CN}\) 是“普通名词（或其解释）”的宇宙，因此它本身是一个类型，其对象包含解释 “man” 的 \(Man\)、解释 “red table” 的 \(\Sigma x:Table.\ red(x)\) 等等（见图 2.1）。\(\mathsf{CN}\) 与 \(\Pi\) 多态在语义构造中尤为有用，可统一刻画动词修饰副词（Luo 2012b；Chatzikyriakidis & Luo 2017a）、细分性（subsective）形容词（Chatzikyriakidis & Luo 2017a）与量词（Lungu & Luo 2014；Chatzikyriakidis & Luo 2018），其类型分别为：
\[
\tag{2.20} quickly:\ \Pi A:\mathsf{CN}.\ (A\to Prop)\to(A\to Prop)
\]
\[
\tag{2.21} small:\ \Pi A:\mathsf{CN}.\ (A\to Prop)
\]
\[
\tag{2.22} some:\ \Pi A:\mathsf{CN}.\ (A\to Prop)\to Prop
\]

有了 \(\mathsf{CN}\)，可写出多态语义。例如
\[
\tag{2.23}\text{Some students spoke.}
\]
可解释为
\[
\tag{2.24} some(Student,\ speak),
\]
其中 \(Student:\mathsf{CN}\)、\(speak:Human\to Prop\)，并假定 \(Student\leq Human\)（见 §2.4）。

\(\mathsf{CN}\) 的**子宇宙**也能用于语义建模，典型如由某一类普通名词的**子类型**构成的宇宙（Maclean & Luo 2020；见第 4 章）。

**用于并列（coordination）的 LTYPE 宇宙。** LTYPE 引入以系统处理 MTT 语义中的并列（Chatzikyriakidis & Luo 2012）。自然语言里的 “and” 能连接多种语类：
\[
\tag{2.25}\text{(sentences) John walks and Mary talks.}
\]
\[
\tag{2.26}\text{(verbs) John walks and talks.}
\]
\[
\tag{2.27}\text{(adjectives) Mary is pretty and smart.}
\]
\[
\tag{2.28}\text{(adverbs) The plant died slowly and agonizingly.}
\]
\[
\tag{2.29}\text{(quantified NPs) Every student and some professor came.}
\]
\[
\tag{2.30}\text{(quantifiers) Some but not all students got an A.}
\]
\[
\tag{2.31}\text{(proper names) John and Mary went to Italy.}
\]
\[
\tag{2.32}\text{(CNs) A friend and colleague came.}
\]

语义学上称这些类型“可并列”（conjoinable；Partee & Rooth 1983；Hoeksema 1998）。在本框架中，它们对应多种语义类型：句子对应 \(Prop\)；动词（以 \(A\) 为论域）对应 \(A\to Prop\)；普通名词对应 \(\mathsf{CN}\)；动词修饰副词对应 \(\Pi A:\mathsf{CN}.\ (A\to Prop)\to(A\to Prop)\)；等等。

我们以 **LTYPE** 收纳所有这些“可并列类型”为其对象：包括谓词的类型、表示 CN 的类型以及宇宙 \(\mathsf{CN}\) 本身（LTYPE 的引入/消除规则见附录 4）。利用与 LTYPE 相关的 \(\Pi\) 多态，可给出 “and” 的统一类型：
\[
\tag{2.33} And:\ \Pi A:\mathrm{LTYPE}.\ A\to A\to A.
\]
于是（2.25）（2.26）分别得：
\[
\tag{2.34} And(Prop,\ walk(j),\ talk(m))
\]
\[
\tag{2.35} And(Human\to Prop,\ walk,\ talk)(j)
\]
其中（2.34）先将 \(And\) 实例化到 \(Prop\)，（2.35）实例化到 \(Human\to Prop\)。

再定义各实例上的语义：
\[
\tag{2.36} And(Prop,\ P,\ Q)\ =\ P\wedge Q,
\]
由此推出
\[
\tag{2.37} And(Prop,\ walk(j),\ talk(m))\ =\ walk(j)\wedge talk(m).
\]
对 LTYPE 中其他类型亦可相应给出定义；各例（2.25–2.32）的具体语义见附录 4。

---

### Tarski-style and Russell-style universes

Martin-Löf（1984）提出两种宇宙风格：**塔斯基式**与**罗素式**。前者语义上更根本，后者实现友好。在 MTT（如 Martin-Löf 类型论或 UTT）里，常用一列**归谓**（predicative）宇宙 \(U_i\) 或 \(Type_i\)（\(i\in\omega\)），可承载 §2.2 的常规归纳构造；并满足分层：\(U_i\) 是 \(U_{i+1}\) 中的对象，且 \(U_i\) 中每个类型也在 \(U_{i+1}\) 中。两种风格的形式化如下[^14]。

[^14]: 本节参考 Luo（2012c，普林斯顿 IAS 演讲笔记）。其中指出罗素式宇宙在 MTT 中存在潜在问题（Luo et al. 2012），但其要点可用塔斯基式宇宙结合**强制子类型**来模拟（把“提升”视作强制转换）。该主题超出本书主线。

**塔斯基式（Tarski-style）宇宙。** 规则（略去 \(\Gamma,\Delta\)）：
\[
\frac{}{U_i\ \text{type}}
\qquad
\frac{a:U_i}{T_i(a)\ \text{type}}
\qquad
\frac{}{u_i:U_{i+1}}
\qquad
\frac{}{T_{i+1}(u_i)=U_i}
\qquad
\frac{a:U_i}{t_{i+1}(a):U_{i+1}}
\]
直观：\(U_i\) 中存放“类型**名称**”；\(T_i\) 将名称解读为其所命名的类型。并在 \(U_{i+1}\) 中引入名称 \(u_i\) 代表 \(U_i\) 本身（因而 \(T_{i+1}(u_i)=U_i\)）。操作符 \(t_{i+1}\) 实现“名称提升”。

以自然数为例：
\[
\frac{}{nat_i:U_i}
\qquad
\frac{}{T_i(nat_i)=Nat}
\qquad
\frac{}{t_{i+1}(nat_i)=nat_{i+1}:U_{i+1}}.
\]

**罗素式（Russell-style）宇宙。** 规则：
\[
\frac{}{U_i\ \text{type}}
\qquad
\frac{A:U_i}{A\ \text{type}}
\qquad
\frac{}{U_i:U_{i+1}}
\qquad
\frac{A:U_i}{A:U_{i+1}}
\qquad
\frac{}{Nat:U_0}
\]
其表达简洁：直接声明 \(U_i\in U_{i+1}\)，且 \(U_i\) 中每个类型亦在 \(U_{i+1}\)。但若**直接**用于 MTT，会破坏若干关键元性质[^15]；实践中常用塔斯基式宇宙并以“强制子类型/提升”模拟罗素式分层（Luo 2012c）。

[^15]: 例如会丧失**典范性**（canonicity）（Luo 1999；Luo et al. 2012）。

## Subtyping

子类型在类型理论的诸多应用中是关键机制，类型理论语义学尤甚。类似于集合论里的“子集”，在类型论中我们讨论“子类型”：记作 \(A \le B\)。直观含义由下面的原则给出。

**子类型基本原则 / Fundamental Principle of Subtyping**  
“\(A \le B\)”表示：每个 \(A\) 型对象都**可当作**（从而可**用作**）\(B\) 型对象。

因此，若 \(A \le B\)，凡需要 \(B\) 的地方都可放入 \(A\) 的对象。例：设 \(Man \le Human\)，且 \(j:Man\)。若 \(shout:Human\to Prop\)，则

(2.38) \(j:Man \le Human\)

(2.39) *John shouts.*

(2.40) \(\operatorname{shout}(j):Prop\)

是良好类型化的命题，因为 \(\,j:Man\,\) 可作为 \(Human\) 的实参使用。

### 包含式子类型 / Subsumptive subtyping

最直接的实现是**包含规则**（subsumption）：
\[
(*)\qquad \frac{a:A \quad A \le B}{a:B}
\]
它把“\(A \le B\)”理解为“\(A\) 的对象**就是** \(B\) 的对象”，与集合的“子集”极其相似，直观简洁。

然而，这种做法与现代类型理论的若干核心元性质不相容，尤其与**规范性**（canonicity）相冲突；规范性用于确保归纳类型的**消除/归纳原则**是充分的。包含规则 \((*)\) 引入的对象不被这些原则“看见”，会破坏一致性[^16]。

[^16]: 若熟悉通过**消除规则**陈述归纳原则的做法（见 §2.2 及附录 2 的正式规则），问题更直观：包含式子类型绕过了归纳消除的控制路径。详见 Luo et al.（2012）§4。

### 强制子类型 / Coercive subtyping

可与 MTT 协调的替代方案是**强制子类型**（coercive subtyping；Luo 1997；Luo et al. 2012）[^17]。要点：把子类型视为**省略记号**。若存在从 \(A\) 到 \(B\) 的**唯一**隐式强制 \(c:A\to B\)，则记 \(A \le_c B\)。在期望 \(B\) 的语境里，可直接放入 \(a:A\)；语义上等价于放入 \(c(a):B\)。强制可**隐去**（implicit），如图 2.2。

由此给出两条核心规则（为便于说明，写作**非依赖**情形）[^19]：

\[
\text{(CA)}\qquad
\frac{\Gamma \vdash_{\Delta} f:B\to C \quad \Gamma \vdash_{\Delta} a:A \quad \Gamma \vdash_{\Delta} A \le_c B:\text{Type}}
     {\Gamma \vdash_{\Delta} f(a):C}
\]

\[
\text{(CD)}\qquad
\frac{\Gamma \vdash_{\Delta} f:B\to C \quad \Gamma \vdash_{\Delta} a:A \quad \Gamma \vdash_{\Delta} A \le_c B:\text{Type}}
     {\Gamma \vdash_{\Delta} f(a)=f(c(a)):C}
\]

于是 (2.40) 可直接写 \(\operatorname{shout}(j)\)，而无需显式写 \(\operatorname{shout}(c(j))\)；由 (CA) 得其良型，由 (CD) 知二者判等。

> ![](https://gitee.com/grahlnn/typora_img/raw/master/20251001200919.png)
>
> 图 2.2. \(A \le_c B\) 的强制示意

[^17]: 强制子类型是现代类型论中的通用子类型理论；多款证明助手（Coq：Coq 2010；Saibi 1997；Lego：Luo & Pollack 1992；Bailey 1999；Matita：Mat 2008；Plastic：Callaghan & Luo 2001）已实现，并广泛用于交互式证明。其进入语义学的最早设想见 Luo & Callaghan（1998），系统应用见 Luo（2009c, 2012b）。“coercion/强制”一词在编程语言与语言学中也被使用；见 Asher & Luo（2013）与 Bassac et al.（2010）。

[^18]: **一致性/惟一性约束**：任意两类型之间至多允许一个强制（以保证推导与化简的**连贯性**）。形式细节见 Luo（2009c）；Luo et al.（2012）。

[^19]: 依赖型情形的完整推理与元理论见 Luo et al.（2012）。

强制子类型还能覆盖更丰富的情形，如**投影式**子类型（projective subtyping）。若把“男人”不当作基元类型，而定义为“具有男性属性的人类”：
\[
\tag{2.41} Man \;=\; \Sigma x:Human.\ male(x)
\]
则自然期望 \(Man \le Human\)；在强制框架下由第一投影给出：
\[
\tag{2.42} Man \le_{\pi_1} Human
\]
这是包含式子类型无法恰当表达的典型例子。

**元理论。** 对**一致**的强制族已证明：在 MTT 上加入强制子类型得到的系统是**保守扩展**，保留原理论的良性元性质（Soloviev & Luo 2002；Luo et al. 2012）。若原 MTT 强规范化（从而一致），扩展后仍然强规范化与一致。语义学中的应用因此是“安全”的；更多实例见 §3.2.2。

### 在签名中局部化子类型与“化身”条目

我们在**签名**（signature）中加入两类新条目，以便更灵活地描述“不完全世界”的复杂现象：

- **子类型条目**：\(A \le B\)；
- **化身条目**（manifest entries）：\(c \sim a:A\)。

早期工作将强制子类型作为**全局**的系统扩展处理[^20]。把子类型放入签名，可将其**局部化**：例如在某个具体情境的签名里声明
\[
\tag{2.43} Man \le Human
\]
写作
\[
\tag{2.44} \Delta = (\Delta_1,\ Man \le Human,\ \Delta_2)
\]
则在该签名下可推得
\[
\tag{2.45} \vdash_{\Delta} Man \le Human
\]
但在另一签名 \(\Delta'\) 下未必成立：
\[
\tag{2.46} \nvdash_{\Delta'} Man \le Human
\]

[^20]: 见 Luo（1999）；Luo et al.（2012）：以 \(T[C]\) 形式把强制族 \(C\) 加到类型理论 \(T\) 上，得到**全局**扩展。与本文在签名层进行**局部**假设形成对比。

这种“局部化”很适合只在特定语境成立的参照转移（reference shift）等现象[^21]。例：
\[
\tag{2.47} \text{The ham-sandwich left without paying the bill.}
\]
在餐馆场景的签名中加入
\[
\tag{2.48} Ham\mbox{-}sandwich \le Human
\]
即可如愿解释（2.47）；而在描述一般常识的签名中则不引入（2.48），保持语义区分。

[^21]: 参照 Nunberg（1995）；更多语义“强制”与类型强制的结合，见 Asher & Luo（2013）。

**化身条目** \(c \sim a:A\) 表示：常量 \(c\) **以** \(a:A\) 的身份行事；凡可用 \(A\) 型对象之处，皆可用 \(c\) 替代：
\[
\tag{2.49} c \sim a:A
\]
这大幅简化签名表达。以 §2.1 的例 2.1 为例，可压缩为：

*例 2.2.*  
\[
\tag{2.50}
D \sim a_D:\text{Type},\quad
B \sim a_B: D\to Prop,\quad
G \sim a_G: D\to Prop,\ \ldots
\]
其中：

- \(a_D=\{John, Paul, George, Ringo, Brian, Bob\}\) 是**有限类型**[^22]；
- \(a_B:D\to Prop\)（“是披头士成员”）归纳定义，满足  
  \(a_B(John)=a_B(Paul)=a_B(George)=a_B(Ringo)=\mathbf{true}\)，  
  \(a_B(Brian)=a_B(Bob)=\mathbf{false}\)；
- \(a_G:D\to Prop\)（“会弹吉他”）归纳定义，满足  
  \(a_G(John)=a_G(Paul)=a_G(George)=\mathbf{true}\)，  
  \(a_G(Ringo)=a_G(Brian)=a_G(Bob)=\mathbf{false}\)。

于是原先例 2.1 中的 \(\Delta_1\) 被（2.50）的第一项取代，\(\Delta_2\) 则由第二、三项承载。

[^22]: \(a_D\) 是有限**类型**（非“有限集合”）。形式化可取 \(Fin(6)\)（见附录 A2.4）：例如 \(John=\operatorname{zero}(5)\)，\(Paul=\operatorname{succ}(5,\operatorname{zero}(4))\)，依此编码。

化身条目还可用**有限**签名表达**无限**域。若域 \(D\) 实为无限，可设
\[
D \sim \operatorname{Inf}:\text{Type}
\]
其中 \(\operatorname{Inf}\) 为含可数/无限多对象的归纳类型；并设
\[
P \sim \text{P-defn}: D\to Prop
\]
其中 `P-defn` 为在 \(\operatorname{Inf}\) 上归纳定义的谓词。如此，签名保持有限，而语义域与谓词可表达无限结构。

## Formal presentation of type theories with signatures

类型理论可在逻辑框架中给出，例如 Martin-Löf 的逻辑框架（Nordström et al., 1990）或其带类型版本 LF（Luo, 1994）。本节形式化地介绍扩展了 LF 并引入**签名**（signatures）的逻辑框架 \(\mathrm{LF}_{\Delta}\)。带签名的现代类型理论最早由第二作者在 Luo（2014）提出，后续见 Luo（2019a）与 Lungu（2018）。以下叙述遵循 Luo（2019a）。

本节目标是**完整**呈现全书所用的类型理论；因此不以入门方式展开，部分概念与记号未在此处重复介绍。读者可参阅 Luo（1994）第 9 章以了解如何用 LF 指定类型理论，以及归纳类型的一般化规格。

### \(\boldsymbol{\mathrm{LF}_{\Delta}}\)：正规系统

\(\mathrm{LF}_{\Delta}\) 的断言形式与推理规则见附录 A5.1。

对熟悉 LF（Luo, 1994）的读者：\(\mathrm{LF}_{\Delta}\) 在 LF 的每一类判断上都加入了**签名**参数（如式 (2.1) 的写法），并将 LF 的所有推理规则（Luo 1994, Fig. 9.1–9.2）中的 \(\vdash\) 统一替换为 \(\vdash_{\Delta}\)（且将 “\(\Gamma\ \text{valid}\)” 的断言样式替换为 “\(\vdash_{\Delta}\ \Gamma\ \text{valid}\)”）。例如，LF 中的 \(\lambda\) 抽象规则
\[
\frac{\Gamma, x:K \vdash b:K'}{\Gamma \vdash [x:K]\,b : (x:K)\,K'}
\]
在 \(\mathrm{LF}_{\Delta}\) 中写作
\[
\frac{\Gamma, x:K \vdash_{\Delta} b:K'}{\Gamma \vdash_{\Delta} [x:K]\,b : (x:K)\,K'}.
\]

[^23]: 在 LF 中，\([x:K]\,b\) 记 \(\lambda x:K.\,b\)，\((x:K)\,K'\) 记 \(\Pi x:K.\,K'\)。

此外，\(\mathrm{LF}_{\Delta}\) 还包含关于**签名**与**语境**的形成与使用规则，详见附录 A5.1。

### 基于 \(\boldsymbol{\mathrm{LF}_{\Delta}}\) 的类型构造器与子类型

第 2.2 节介绍的各类类型构造器，可在 \(\mathrm{LF}_{\Delta}\) 中通过**声明常量**来指定（与 LF 相同，只是此处带签名）。例如，\(\Sigma\) 类型的规格见附录 A5.2。与第 2.2 节直接给出的自然演绎规则相比，\(\mathrm{LF}_{\Delta}\)（与 LF）风格更为**紧凑抽象**，但记号上略显繁复；读者可对照第 2.2.2 节与附录 A2.2 体会两种呈现的异同。

**强制子类型**的签名条目亦可在 \(\mathrm{LF}_{\Delta}\) 中声明。形式上，我们扩展判断形为
\[
\Gamma \vdash_{\Delta} A \le_{\kappa} B : \text{Type}
\quad\text{与}\quad
\Gamma \vdash_{\Delta} K \le_{\kappa} K'
\]
（后者用于更高层结构）。签名中引入子类型条目的规则为
\[
\frac{\vdash_{\Delta} A:\text{Type}\quad \vdash_{\Delta} B:\text{Type}\quad \vdash_{\Delta} \kappa:(A)\,B}
     {\Delta,\, A \le_{\kappa} B\ \text{valid}}
\]
在包含该条目的签名下，可据下式将其作为可推导判断使用：
\[
\frac{\vdash_{\Delta,\,A\le_{\kappa} B,\,\Delta'} \Gamma}
     {\Gamma \vdash_{\Delta,\,A\le_{\kappa} B,\,\Delta'} A \le_{\kappa} B : \text{Type}}.
\]
因此，强制子类型的推理（Luo et al., 2012）在此语境中仍然适用。例如，若在同一签名 \(\Delta\) 下有
\(\vdash_{\Delta} A \le_{\kappa} B\) 与 \(\vdash_{\Delta} B \le_{\kappa'} C\)，则可得
\[
\vdash_{\Delta} A \le_{\kappa'\circ \kappa} C,
\]
其中 \(\kappa'\circ \kappa\) 为函数复合。

需要强调：在**带子类型条目**的情形，签名的“有效性”不足以保证良好元性质，还需满足**连贯性**（coherence）：在适当子系统中，若
\(\Gamma \vdash_{\Delta} A \le_{\kappa} B\) 且 \(\Gamma \vdash_{\Delta} A \le_{\kappa'} B\)，则
\(\Gamma \vdash_{\Delta} \kappa = \kappa' : (A)\,B\)。

签名还可包含**化身条目**（manifest entries）：
\[
(*)\qquad
\frac{\vdash_{\Delta} A:\text{Type}\quad \vdash_{\Delta} a:A \quad c \notin \operatorname{dom}(\Delta)}
     {\Delta,\, c \sim a:A\ \text{valid}}
\]
事实上，此类化身可借助强制子类型，通过**特殊成员条目**来编码（Luo 2009b, 2014）。

### 元理论性质 / Meta-theoretic properties

下面给出带签名扩展的总体结果。其内容直述：在一致的签名下，扩展系统按预期保留原理论的良好性质。

**定理 2.1**  
设 \(T\) 为在 LF 中指定的类型理论，\(T_S\) 为用 \(\mathrm{LF}_{\Delta}\) 指定的、在 \(T\) 上加入签名（可含成员、子类型与化身条目）的扩展。则对一切**一致**的签名，\(T_S\) 保留 \(T\) 的元性质（如逻辑一致性、Church–Rosser、与**强归一化**）。

举例：以 \(\mathrm{SN}\) 表示强归一化性质[^24]。定理推出：若 \(T\) 具有 \(\mathrm{SN}\)，则对每个一致签名 \(\Delta\)，扩展 \(T_S\) 亦有 \(\mathrm{SN}\)：若 \(\Gamma \vdash_{\Delta} a:A\)，则 \(a\) 强归一。由此进一步得到，包括**逻辑一致性**在内的良性性质亦得以保留。证明层面上，由于化身条目可用成员与子类型条目精确刻画（Luo 2009b, 2014），仅需处理“带子类型条目”的情形即可[^25]。

[^24]: 技术上，强归一化保证一切良构项的归约计算终止。这是确保证明系统良好行为的基础结论，并常常蕴含所涉类型理论的逻辑一致性。

[^25]: 更完整的元理论细节参见 Lungu & Luo（2018）与 Lungu（2018，博士论文）。其中将 Luo et al.（2012）的保守性结果推广至**带签名**的演算。
