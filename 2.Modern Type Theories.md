## Modern Type Theories

现代类型理论（MTT）是一种计算形式系统，涵盖了对逻辑系统全新且实用的多种基本机制。例如，类型理论中的“断言”[judgments]概念，这种声明断言用于进行断言推导[assertions]，其中涉及的“语境”[context]机制可以有效地描述语言语义中的情境（或不完全的可能世界）。

MTT类型结构丰富，比蒙塔古箭头类型 $A \rightarrow B$ 要丰富得多。除了逻辑命题（即根据Curry-Howard命题即类型原理的命题证明类型（Curry和Feys 1958; Howard 1980）），它还有很多其他类型，可以在构建形式语义学时用于各种表现目的。在语言语义研究中，人们讨论过多序逻辑系统[many-sorted logical systems]或多序集合论域[multisorted set-theoretical domains]。正如Link所说：

> 语言对象涉及各种类型，在结构特性上各有不同。因此，语言和哲学话语的宇宙自然便是一个多元序域[multi-sorted domain]，所有这些对象都在其中。(Link 1998, 前言)。

MTTs 不仅仅是多序系统，而且这些“序[sorts]”或说是类型结构非常强大且丰富。包括可用于解释逻辑操作、名词、形容词修饰、副词修饰、协同[coordination]以及更高级的特性，例如子类型化、共指谓词和语言强制转换等等。除了功能强大之外，这些类型还很好管理；例如，在某种意义上，给定 $a$ 和 $A$ 可以决定 $a$ 的类型是否是 $A$ 这种类型检查。这样做的结果很好，诸如此类类型理论可基于命题即类型原则而具有逻辑。

上述两个方面，即语境机制和丰富的类型，对于MTT成为形式语义学强有力的基础性语言至关重要。本章中，我们将在第2.1节介绍断言概念及相关的语境机制，并在第2.2节和第2.3节中介绍几种类型构造器。MTT中现有的语境机制通过罗（2014年、2019年a）所引入新的签名[signature]概念而得到丰富，这能充分给出不完整世界的语义表示。另一个必不可少的机制是子类型：在第2.4节中，我们将研究MTT（因此也适用于MTT-语义学） 的强制子类型框架（Luo 1999；Luo等人2012）。第2.5节将给出MTTs 完整而正式的描述(Luo 2019a)，这主要是为了内容完备而非理解(因此大多数读者可以安全跳过)。

## Judgments and contextual mechanisms

在本节中，我们将介绍断言的概念和相关的语境机制，并且说明这种机制如何被用来描述情境。[^1]

[^1]: 对于对“断言”一词历史感兴趣的人来说，它在逻辑学中的使用可以追溯到弗雷格。马丁-勒夫（1975）在发展他的类型理论时引入了形为$\Gamma \vdash a: A$ 的断言，这将在本书中通过签名进行丰富。

**断言/Judgments**。在MTT中，最基本的概念是断言，它们是用来作出推导断言的陈述。典型的断言如(2.1)，它声明“ $a$ 对象在 $\Gamma$ 语境和 $\Delta$ 签名下类型为 $A$ （ps:在给定的语境$\Gamma$和签名$\Delta$下，对象$a$是类型$A$的成员）"。[^2]

(2.1) $\Gamma \vdash_{\Delta} a: A$

[^2]: 关于符号的注释：传统上用$\Sigma$来表示签名。我们选择使用$\Delta$而不是$\Sigma$，是以免与本书中经常使用的$\Sigma$类型混淆。

MTT中类型表示对象的集合。作为集合的一种表示，类型非常类似集合论中的集合，即便它是一个句法实体，通常通过证明理论规则归纳定义。直观地说，上述断言（2.1）说明，在环境 $\Delta$ 和 $\Gamma$ 假设下（有关签名和语境概念，请参见下文），$a$ 是 $A$ 集合的一个对象。例如，我们可以断定以下断言，暂时省略 $\Delta$ 和 $\Gamma$：

(2.2) $John : Man$

这句话表明 $John$ 是一个男人，其中“$Man$”类型表示所有男性的合集。

要注意，断言不是逻辑公式。我们不能对断言用否定[negation]和合取[conjunction]等逻辑算符。如果我们否定了（2.1）这个断言，则结果将不再是断言：（2.1）的“否定”，通常写作 $\Gamma \nvdash_{\Delta} a: A$，这并非断言，只是声明断言（2.1）不正确（或者在正式术语中说，(2.1) 是无法推导出来的）的元层次陈述[meta-level statement]。 （有关此方面进一步讨论，请参见第3.2.3节。）

MTT中的类型结构非常丰富，为语义学家提供了足够和有用的工具来构建形式语义。例如，类型可以是逻辑命题的证明（或证明对象）合集 - 这是命题即类型原理的基础。例如，如果$A$是一个逻辑命题的证明合集，则(2.1) $a$ 便是该命题的证明。这在类型论内部提供了一致性逻辑以用于语义构造。在接下来的几节中，我们将介绍几个类型构造器以说明如何在语义研究中使用它们。但在此之前，我们将解释断言中涉及到的其他概念 - 签名和语境这两种背景机制。

**签名和语境机制/Signatures and contextual mechanisms。**在逻辑术语中，MTT中的语境机制描述了基础环境和为做出断言而进行的假设。例如，在语义学研究中，一个人可能想要描述做出断言的情况（或不完整的可能世界）。在语言学中，“语境”一词用于指代那些围绕着交际事件的对象或实体，为其适当解释提供资源。在MTT-语义学中，我们可以使用语境机制作为某些语言背景的正式代表。[^3]

[^3]:目前尚不清楚签名和语境的正式概念在多大程度上接近于非正式的语言环境概念。这个问题超出了我们当前讨论的范围。

在类型理论的通常表述中，没有签名，并且断言只涉及语境，该语境由成员条目组成，形式为 $\Gamma \vdash a: A$，其中语境 $\Gamma$ 是变量-类型对的有限序列。

(2.3) $x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n}$

其中假设$x_{i}$是类型$A_{i}(i=1, \ldots, n)$的变量。注意语境中的这些类型可能取决于“先前”的变量：$x_{1}, \ldots, x_{i-1}$可能在$A_{i}$中自由出现。例如，语境$\Gamma$可以包含条目(2.4)：

(2.4) $x: Man,  y: handsome(x)$

假设 $x$ 是一个英俊的（任意）男人（通过假设 $y$ 是证明 $x$ 英俊的任意证据）。由于它们可以抽象为语境条目形成命题，所以假定实体 $x$ 和 $y$ 是变量，例如 $\forall x: Man \forall y: handsome (x).\neg ugly(x)$ 。[^4]

[^4]:从形式上讲，变量可以通过量化或$\lambda$抽象来进行抽象，如下所示的规则（参见第2.3.1节和附录A3.1）：$\frac{\Gamma \vdash_{\Delta} \text { A type } \Gamma, x: A \vdash_{\Delta} P: \text { Prop }}{\Gamma \vdash_{\Delta} \forall x: A . P: \text { Prop }}$ 当起始语境为(2.4)时，可以通过两次应用上述规则形成命题$\forall x: Man \forall y: handsome (x).\neg ugly(x)$ 。

在自然语言语义学中，人们可以使用语境来表示情境。但是，使用语境这样做存在问题。其中一个问题是应该通过假设常量[constants]而不是变量来表示情境。例如，我们可能有这样一种情况：约翰是男人。然而，将 $John: Man$ 作为语境条目会使得对 $John$ 进行抽象以形成 $\forall John:Man.P(John)$ 等式，显然这并不合适——约翰不是任意的男人。另一个问题是仅使用成员条目通常很难表示更复杂的情况，如无限情境（因为语境总是有限的）。[^5]

[^5]:如第1.4.2节所述，传统的语境概念被Ranta（1994）和其他人用来表示情境。在那里，不考虑变量和常量之间的区别。我们考虑声明常量的签名（Luo 2014），而不是声明变量的语境 - 我们的签名可能包含其他形式的条目，以允许灵活地表示复杂情况，如无限情况（请参见第2.4节和第2.5节）。然而，在语境中添加这些新形式的条目并不容易：特别是它们元理论研究相当复杂，并且一直是一个困难的开放性问题。相反，将它们作为签名中的条目添加更容易。签名概念最初在爱丁堡逻辑框架（Harper等人1993）发展引入类型理论中，其标记仅包含成员条目。本节我们只使用成员条目，并稍后研究具有新形式条目扩展功能的标记。

这就是为什么我们在断言形式（2.1）等中使用了签名 $\Delta$ 。签名类似于语境，但又有所不同。相似之处在于签名也是有限序列条目，就像（2.3）中的语境一样。不同之处在于，首先，除了形式为 $c:A$ 的成员条目之外，还可以有其他形式的条目（见下文），其次，签名中的条目引入的是常量而不是变量。一般而言，只包含成员条目的签名具有以下形式：

(2.5) $c_{1}: A_{1}, c_{2}: A_{2}, \ldots, c_{n}: A_{n}$

就像语境中的条目一样，在签名的条目中给定的假设在推理中都得到了考虑。然而，有一个关键的区别：签名中的成员条目 $c: A$ 声明 $c$ 是类型为 $A$ 的常量对象。这与上面所示的声明 $x: A$ 不同，后者声明 $x$ 是一个可以通过量化等方式抽象的变量。在签名中声明的常量永远不会被抽象化 - 这就是为什么它们被称为常量的原因。因此，签名能够充分表示语言意义上的情境，而语境则不能。[^6]

[^6]:另外，由于在签名中声明的常量不能被抽象化，从元理论的角度来看，向签名中添加新的条目形式比向语境中添加更容易（参见第2.5节）。

在语境和签名分别为(2.3)和(2.5)的情况下，判断(2.1)的一般形式如下(2.6)，其中我们的签名中只有成员项。

(2.6) $x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n} \vdash_{c_{1}: A_{1}^{\prime}, c_{2}: A_{2}^{\prime}, \ldots, c_{n}: A_{n}^{\prime}} a: A$

签名将在稍后正式介绍。在这里，我们举一个例子来展示如何通过仅使用传统成员条目来表示情况的方法。

**以签名表示情境/Representing situations by signatures：一个简单的例子**。这里，我们使用 Luo（2014）中给出的例子来说明如何使用签名来表示情境。我们的例子很简单，例如，该例子中的情境域是有限的。这将作为我们讨论的基础，探讨如何表示涉及无限或其他更复杂的特殊情境。

*例2.1- 该例子摘自Saeed（1997）的第10章，描述了1962年利物浦的Cavern Club里的一个（假想的）情境，当时披头士乐队正在为演出进行排练。这个情境可以如下所示：*

1. *情境的领域包括几个人，包括披头士乐队的成员（约翰、保罗、乔治和林戈）、他们的经理（布莱恩）和一位歌迷（鲍勃）。可以通过以下标记 $\Delta_{1}$ 来表示：*

$$
\begin{aligned}
\Delta_{1}= & D: \text { Type, } \\
& \text { John }: D, \text { Paul }: D, \text { George }: D, \text { Ringo }: D, \text { Brian }: D, \text { Bob }: D
\end{aligned}
$$

2. *赋值函数将谓词符号，如 $B$ 和 $G$ ，分别赋予表示“是一位披头士乐队成员”和“弹吉他”的命题函数。我们可以在我们的签名中引入以下内容来表示这样的赋值函数：*

$$
\begin{aligned}
\Delta_{2}= & B: D \rightarrow Prop , b_{J}: B( John ), \ldots, b_{B}: \neg B( Brian ), b_{B}^{\prime}: \neg B(Bob), \\
& G: D \rightarrow Prop , g_{J}: G(John ), \ldots, g_{G}: \neg G(Ringo), \ldots
\end{aligned}
$$

*代表这种情况的标记将采用形式 $\Delta \equiv \Delta_{1}, \Delta_{2}, \ldots$ 。例如，我们将有：*
$$
\vdash_{\Delta} G(J o h n)\ true \text { and } \vdash_{\Delta} \neg B(B o b) \ true
$$
*在这里，$G(John)$ 和 $B(Bob)$ 在语义上分别解释为约翰弹吉他和鲍勃是甲壳虫乐队成员。*[^7]

[^7]:严格地说，$\Gamma \vdash_{\Delta} A\ true$ 表示的是"对于某个 $a$，$\Gamma \vdash_{\Delta} a: A$ 成立"这一陈述。

在上面的例子中，我们使用签名来表达部分（或不完全）世界，就像人们通常在集合论模型中所做的那样。请注意，语言学中的语境概念（即语言语境）通常模糊地描述了前一句为解释后一句而设置了一个环境的连续句子。其中一些解释会涉及类型构造器，比如 $\Sigma$ — 在第2.2.2节末尾的示例中可以看到。

## Type constructors

在MTTs中，存在着多种归纳定义的类型构造器。在本节中，我们介绍了几种典型的类型构造器，包括本书中将要使用的构造器。

### $\Pi$-Types of dependent functions

现代类型理论包含依赖类型，典型为依赖函数的 $\Pi$ 类型。当 $A$ 是一个类型，$B$ 是依赖于 $A$ 对象的类型族[family of types]时，$\Pi x: A . B(x)$，有时写作 $\Pi(A, B)$，表示 $\lambda$-函数 $f$ 的类型，满足对于任意 $a: A$，应用 $f$ 到 $a$ 后的结果 $f(a)$ 是类型 $B(a)$ 的实例。

请注意，应用 $f(a)$ 的类型 $B(a)$ 取决于输入 $a$，这使得 $\Pi$ 类型成为一种依赖类型。例如，我们可以有一个族群 $C h i l d(x)$ — 对于每个 $x:Human$ ，$C h i l d(x)$ 是 $x$ 的子代类型 ，其中 $Human$ 类型是人类本身。那么，依赖函数 $f$ 的类型是 $\Pi x :Human.Child (x)$ ，对于任何 $h:Human$ ，$f(h)$ 的类型是 $Child (h)$ — $h$ 的一个子代。

型在非依赖情况下退化为普通的函数类型 $A \rightarrow B$ ，即第二个参数 $B$ 是常数类型时。更精确地说，当  $B(x)$ 是一个常数类型（即无论 $x$ 是什么，类型总是相同）时，$\Pi$ 型 $\Pi x: A . B(x)$ 就退化为我们熟悉的非依赖函数类型。例如，关于 $Man$ 的谓词类型就是函数类型 $Man \rightarrow Prop$，其中 $Prop$ 是所有逻辑命题的类型宇宙。

$\Pi$ 类型是归纳定义的。正式地说，每一个归纳类型构造器都是通过推理规则来指定的，这些推理规则采用自然演绎的方式，被称为形成规则[formation rule]、引入规则[introduction rules]、消除规则[elimination rules]以及计算规则[computation rules]。对于 $\Pi$ 类型，我们有以下形成规则，告诉我们如何合法地形成一个 $\Pi$ 类型：
$$
(\Pi)\qquad \frac{\Gamma \vdash_{\Delta} A \text { type }\quad \Gamma, x: A \vdash_{\Delta} B \text { type }}{\Gamma \vdash_{\Delta} \Pi x: A . B \text { type }}
$$
引入规则告诉我们， $\Pi$ 型对象是什么：
$$
(Abs)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B}{\Gamma \vdash_{\Delta} \lambda x: A . b: \Pi x: A . B}
$$
$\Pi$ 类型的消除规则指定了应用(application)运算符的行为，其中 $[a / x] B$ 表示通过"将 $B$ 中的 $x$ 替换为 $a$ "获得的项（即，将所有自由出现的 $x$ 替换为 $a$ ）：例如，如果 $B$ 是 $\operatorname{Child}(x)$ ，那么 $[h / x] B$ 就是 $\operatorname{Child}(h)$ 。
$$
(App)\qquad\frac{\Gamma \vdash_{\Delta} f: \Pi x: A . B\quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta} f(a):[a / x] B}
$$
应用操作符通过以下计算规则（通常称为 $\beta$ 规则）获得其含义，该规则规定了应用的行为：
$$
(\beta)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B \quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta}(\lambda x: A . b)(a)=[a / x] b:[a / x] B}
$$
请注意，如上所述，假设 $x: A$，那么lambda表达式的主体 $b$ 的类型就是 $B$ ，而 $b$ 和 $B$ 可能都依赖于 $x$（即，$x$ 可能在它们中出现自由）- 这就是类型依赖。关于 $\Pi$ 类型的上述推理规则也可以在附录A2.1中找到。

以上面的例子来解释，当一个类型为 $\Pi x : Human. Child (x)$ 的函数 $f$ （或者，用另一种记法，$\Pi (Human, Child)$ ）应用到一个人 $h$ 时，它的像[image] $f(h)$ 必须是 $h$ 的孩子，即类型 $Child (h)$，而不是其他东西。

当与宇宙一起使用时，$\Pi$ 类型还提供了多态性的机制 - 参见第2.3节。

### $\Sigma$-types of dependent pairs

另一个典型的依赖型构造器是 $\Sigma$ 类型。如果 $A$ 是一种类型，$B$ 是依赖于类型 $A$ 的对象的类型族，那么$\Sigma x: A . B(x)$，或有时写作 $\Sigma(A, B)$ ，也是一种类型，由满足 $a$ 是类型 $A$ ，$b$ 是类型 $B(a)$ 的对子 $(a, b)$ 构成。$\Sigma$-类型与投影操作符 $\pi_{1}$ 和 $\pi_{2}$ 相关联，因此，对于类型为 $\Sigma x: A . B(x)$ 的 $(a, b)$ ，有 $\pi_{1}(a, b)=a$ 和 $\pi_{2}(a, b)=b$。

让我们用一个例子来解释。如果 $M a n$ 是男性的类型，而 $handsome:Man \rightarrow Prop$ 是表示一个男人帅气的谓词，那么，$\Sigma x:Man.handsome(x)$ 就是帅气男人的类型，或者更准确地说，代表男人 $m$ 和证明 $m$ 帅气的证明 $p$ 的元组 $(m, p)$ 合集的类型。注意，帅气这个谓词是命题的一个家族（因此也是类型的一个家族，因为命题就是类型）：对每一个男人 $\Sigma x:Man.handsome(x)$ 是一个命题（因此也是一个类型）。注意， $handsome(x)$ 取决于 $x$ ，并且 $\Sigma x: Man. handsome(x)$ 是一个依赖类型。特别地，对于类型为 $\Sigma x: Man.  handsome(x)$ 的元组 $(m, p)$， $p$ 的类型 $handsome(m)$ 取决于 $m$。

非依赖的元组平庸乘积类型 $A \times B$ 是 $\Sigma$ 依赖类型的一个特例。例如，如果 $Woman$ 是女性类型，那么乘积类型 $Man\times Woman$ 就是平庸元组 $(m, w)$ 的类型，使得有 $m: M a n$ 和 $w: W o m a n$。乘积类型 $Man \times Woman$ 与 $\Sigma$ 类型 $\Sigma x: Man. W(x)$ 是相同的，其中类型的常数族 $W(x)= Woman$。

$\Sigma$ 类型是归纳定义的。我们有以下形成规则，告诉我们如何形成一个 $\Sigma$ 类型：
$$
(\Sigma)\qquad\frac{\Gamma \vdash_{\Delta} A \text { type }\quad \Gamma, x: A \vdash_{\Delta} B \text { type }}{\Gamma \vdash_{\Delta} \Sigma x: A . B \text { type }}
$$
引入规则告诉我们 $\Sigma$ 类型的对象是什么[^8]：
$$
(pair)\qquad\frac{\Gamma \vdash_{\Delta} a: A \quad \Gamma \vdash_{\Delta} b:[a / x] B \quad \Gamma, x: A \vdash_{\Delta} B \text { type }}{\Gamma \vdash_{\Delta}(a, b): \Sigma x: A . B}
$$

[^8]: 这里，为了便于理解，我们稍微简化了一些正式的细节：严格来说，对于 $(a, b)$ 这对元组元素，需要包含类型信息以便在类型推断过程中可以清晰地推断出它的类型。我们在这里省略了详细内容。

注意 $B$ 可能依赖于 $x$（即$x$可能在$B$中自由出现），并且配对的第二个组件 $b$ 的类型为 $[a / x] B$ ，即它依赖于第一个组件 $a$，这就是类型依赖。为了通过上述例子进行解释，在类型为 $\Sigma x : Man. handsome (x)$ 的对象元组 $(m, p)$ 中，$p$ 必须是对 $handsome (m)$ 的证明（而非其他内容）。$\Sigma$ 类型的消除规则指定了投影运算符：
$$
\frac{\Gamma \vdash_{\Delta} p: \Sigma x: A . B}{\Gamma \vdash_{\Delta} \pi_{1}(p): A} \quad \frac{\Gamma \vdash_{\Delta} p: \Sigma x: A . B}{\Gamma \vdash_{\Delta} \pi_{2}(p):\left[\pi_{1}(p) / x\right] B}
$$
投影算子通过以下的计算规则获得它们的意义，规定当应用于一个 $\Sigma$ 类型的元组时，投影一和二分别等于组件一和二：
$$
\frac{\Gamma \vdash_{\Delta} a: A \quad \Gamma \vdash_{\Delta} b:[a / x] B}{\Gamma \vdash_{\Delta} \pi_{1}(a, b)=a: A} \quad \frac{\Gamma \vdash_{\Delta} a: A\quad \Gamma \vdash_{\Delta} b:[a / x] B}{\Gamma \vdash_{\Delta} \pi_{2}(a, b)=b:[a / x] B}
$$
以上关于 $\Sigma$ 类型的推理规则[inference rules]，也可以在附录A2.2中找到。

一个 $\Sigma$ 型的 $\Sigma x: A . P(x)$ 可以被用来表示子集构造，当它的第二个参数 $P(x)$ 是一个逻辑命题时。这利用了命题作为类型的观念 - 对于任意的 $x: A, P(x)$ 是一个命题，因此也是一个类型[^9]。因此，根据以上的形成规则，$\Sigma x: A . P(x)$ 是一个类型。利用 $\Sigma$ 类型表示子集构造的方法，通过解释“英俊的男人”的例子进行了说明，因为像“英俊”这样的形容词被解释为谓词。总的来说，由交集形容词修饰的 $\mathrm{CN}$ 可以使用 $\Sigma$ 类型来赋予语义，这个观念由Ranta (1994)提出（详见3.3节以获取更多细节）。

[^9]: 每个逻辑命题都是一种类型。有关像UTT这样的非归纳性类型理论，请参阅2.3.1节。

总的来说，$\Sigma$ 类型可以被视为元组类型，因为它们的形成可以是嵌套的。嵌套的 $\Sigma$ 类型$\Sigma x_{1}: A_{1}\ \Sigma x_{2}: A_{2}\ \ldots\ \Sigma x_{n-1}: A_{n-1}$ 。 $A_{n}$可以用以下的记号来表示，并且直观地说，其对象是各自类型的$n$元组项。[^10]
$$
\left\{\begin{array}{lll}
x_{1} & : & A_{1} \\
x_{2} & : & A_{2} \\
\cdots & & \\
x_{n} & : & A_{n}
\end{array}\right\}
$$

[^10]: 这种用于记录类型（和记录）的符号在编程语言中被用于非依赖性记录类型。它们在罗的2009b研究中用于表示$\Sigma$-类型，在罗的2009a研究中用于表示依赖性记录类型。一种与此类似的符号也在依赖类型语义学（Bekki 2014）中被采用。

例如，$\Sigma$ 型的（2.7）可以被写作（2.8），其中 $name$ 和 $hproof$ 是绑定变量[bound variables]。[^11]

(2.7) $\Sigma x: Man. handsome (x)$

(2.8) $\left\{\begin{array}{ll}
\text { name } & : \text { Man } \\
\text { hproof } & : \text { handsome(name) }
\end{array}\right\}$

[^11]: 在实现了一种特殊的$\Sigma$记录类型的 Coq 证明助手（Coq 2010）中，像名字这样的标识符是通过投影操作符来定义的。

除了用于解释形容词修饰的 $\Sigma$ 类型外，它们也经常被用来组织MTT语义学中的语义表示。典型的例子涉及模拟一系列句子，其中前面的句子构成了对后句解释的语言环境。例如，(2.9)中的两个句子可以给出一个语义解释(2.10)。如果采用上述的记录式符号，(2.10)可以写成(2.11)，其中我们用 $s_{1}$ 和 $s_{2}$ 作为"名字"，表示它们的类型是(2.9)中的第一句和第二句的语义解释。在这里，第一句构成了第二句的语言环境，这由 $\Sigma$ 类型的类型依赖所捕获。

(2.9) A man walked in. He lit a cigarette.（男人走进来。点了根烟。）

(2.10) $\Sigma z:[\Sigma x: \text{Man}. \text{walk\_in} (x)] . \exists y: \text{Cigarette}. \operatorname{light}\left(\pi_{1}(z), y\right)$

(2.11) $\left\{\begin{array}{l}s_1:\left\{\begin{array}{l}x: \text {Man} \\ w: \text{walk\_in}(x)\end{array}\right\} \\ s_2: \exists y: \text{Cigarette.} \operatorname{light}(x, y)\end{array}\right\}$

请注意，我们已经同时使用了 $\Sigma$ 类型和存在量词 $\exists$（有时被称为弱和类型[weak sum types]；参见2.3.1节），因为它们都存在于类似UTT的不可辨识类型理论[impredicative type theories]中。这两种机制的存在为语义构造开辟了新的途径，而在过去是无法实现的 - 更多关于这个话题的讨论，请参见第16页的26号脚注和（Luo 2019b），其中提到了涉及回指[anaphora]和计数[counting]的驴句[donkey sentences]，由“most”引导，给出了新的、满意的解释。

### Disjoint union types, unit types and finite types

存在许多其他的归纳类型，包括无交联合类型：当 $A$ 和 $B$ 是类型时，他们的无交联合类型 $A+B$ 也是类型，其对象要么是$a: A$的 $\operatorname{inl}(a)$，要么是 $b: B$ 的 $\operatorname{inr}(b)$ 。请注意，在MTTs中，我们没有对应于集合上并集操作的并集类型[^12]。无交联合类型是在不破坏类型理论优良属性的情况下最好的类型组合方法。无交联合类型也是归纳定义的 - 请参见附录A2.3以获取他们的正式规则。

[^12]: 并集或交集类型的类型构造器是非常强大的构造器，它使类型理论失去了它所希望具有的属性，如可决定的类型检查。感兴趣的读者可以参阅 Hayashi（1991年）和其他资料，以了解更多关于它们的信息。在未类型化的$\lambda$-演算中交集类型的研究可以在Coppo和Dezani-Ciancaglini（1980年）以及Coppo等人(1980)的工作中找到。

无交联合类型，配合强制子类型化（参见第2.4节）已提出来解释否定形容词修饰的常见名词（参见 Luo 2011a；Chatzikyriakidis 和 Luo 2013, 2017a）：例如，对于类型 $G_{R}$ 真枪和类型 $G_{F}$ 假枪，我们可以使用无交联合类型 $G=G_{R}+G_{F}$ 来代表所有的枪的集合（详见第3.3.3节）。

包含有限个对象的有限类型[finite types]也可以归纳定义。特殊的例子是单位类型[unit types]，这种类型只有一个对象，我们为此采用了特殊的符号 $\mathbf{1}_{w}$ ：仅有一个对象 $w$ 的单位类型。关于它们的推理规则，请参阅附录A2.4。

## Universes

直观地说，宇宙（有时也被称为类型宇宙）是类型的类型。正如马丁-洛夫（1975）所指出的，他将宇宙的概念引入到类型理论中，宇宙的引入为我们提供了额外的力量，使我们能够在类型理论中形式化一些没有宇宙就不能完成的概念。例如，使用包含自然数的类型 $N a t$ [natural numbers]和用于乘积类型的构造函数 $\times$（特殊的非依赖性 $\Sigma$ 类型 - 见第2.2.2节）的宇宙，我们可以定义以下的类型值化[type-valued]函数：
$$
f(n)=N a t \times \ldots \times N a t
$$
对于任何自然数 $n: N a t$，返回将$\times$应用于 $N a t$ $(n-1)$次的积类型。没有类型宇宙的帮助，这种类型值函数将无法定义。[^13]

[^13]: 这种不可定义性是由于消除归纳类型（如Nat）的运算符涵盖了类型的事实。通常，类型本身不能包含类型作为对象，但在有一个本身就是类型的宇宙存在的情况下，可以定义类似上述 $f$ 的值为类型的函数。由于其技术性质，我们在此省略了详细的解释。

宇宙多种多样。我们首先在第2.3.1节介绍其中的两种：逻辑宇宙 $Prop$ 以及第2.3.2节用于语言语义的宇宙，然后在第2.3.3节中，简洁地阐述如何以两种不同的方式正式引入宇宙到类型理论中。

### $Prop$ and logical propositions

在像UTT这样的非指称类型理论中，逻辑命题构成了类型 $Prop$ - 类型理论中的内部总体。如果 $A$ 是一个类型，$P$ 是 $A$ 上的谓词（即 $P: A \rightarrow Prop$ ），那么 $\forall x: A . P(x)$ 是一个公式，有时写作 $\forall(A, P)$ ，代表全称量化的命题。当第一个参数也是命题（因此也是类型，因为每个命题都是类型），并且 $x$ 在第二个参数中不是自由出现的，那么公式 $\forall x: P . Q$ 代表命题 $P$ 蕴含 $Q$ ，可以写作 $P \Rightarrow Q$ 。例如，（2.12）的语义可以作为命题（2.13）给出，其中帅和丑是 $Man$ 的谓词：

(2.12) $\text{If a man is handsome, he is not ugly.}$ (若此人形貌昳丽，那他即非丑陋)

(2.13) $\forall x :Man. handsome (x) \Rightarrow \neg u g l y(x)$

基于Curry-Howard原则的命题作为类型，现代类型理论包含命题的证明对象。让我们考虑一个简单的例子：逻辑命题 $A$ 在 (2.14) 中可以被 (2.15) 中的术语 $p$ 证明；换句话说，(2.16) 是一个正确的判断，它声明 $p$ 是 $A$ 的证明对象（形式上，我们说判断 (2.16) 可以被推导出来）：

(2.14) $A=\forall P: N \rightarrow \operatorname{Prop} \forall x: N . P(x) \Rightarrow P(x)$

(2.15) $p=\lambda P: N \rightarrow \operatorname{Prop} \lambda x: N\ \lambda y: P(x) . y$

(2.16) $p: A$

如果且仅当存在公式的证明时，逻辑公式才为真：在上述例子中，$A$ 为真，因为存在证明 $A$ 的 $p$。

逻辑宇宙 $Prop$ 以及全称量词命题的推理规则在附录A3.1中给出。特别地，对于“ $\forall$ ”的形成规则如下：
$$
(\forall)\qquad\frac{\Gamma \vdash_{\Delta} A \text { type }\quad \Gamma, x: A \vdash_{\Delta} P: Prop }{\Gamma \vdash_{\Delta} \forall x: A . P: Prop }
$$
请注意，$Prop$ 是一个不可识别的宇宙，因为我们可以量化 $Prop$ 本身（甚至是“更大”的类型）来形成 $Prop$ 中的逻辑命题。例如，$\forall X:Prop$。$X$ 是 $Prop$ 类型的，并且，事实上，这个命题可以作为假公式[false formula]，因为它直观地意味着每个命题都是可证明的（根据逻辑一致性原则，并非所有的命题都是可证明的，因此，$X$ 是不可证明的）。

由于 $Prop$ 是非归约性的，我们可以使用 $\forall$ 来定义其他逻辑运算符，如合取[conjunction]、析取[disjunction]、否定[negation]和存在量化[existential quantification]（参见附录A3.2）。例如，合取和存在量化的连接词可以像（2.17）和（2.18）那样定义：

(2.17) $P \wedge Q=\forall X: Prop .(P \Rightarrow Q \Rightarrow X) \Rightarrow X$

(2.18) $\exists x: A . P(x)=\forall X: Prop. (\forall x: A .(P(x) \Rightarrow X)) \Rightarrow X$

也可以定义一种命题等式，称为莱布尼茨等式。对于任何类型 $A$ 和任意两个对象 $a, b: A$，声明 $a$ 和 $b$ 相等的命题可以按照如下方式定义：

(2.19) $\left(a={ }_{A} b\right)=\forall P: A \rightarrow Prop. P(a) \Rightarrow P(b)$

备注.- 正如读者可能已经注意到的，全称量词命题 "$\forall x: A . P(x)$" 与 $\Pi$ 类型非常相似。他们的差异在于，$\forall$ 的形成可以是非归约[impredicative]的，而 $\Pi$ 的形成总是以我们不能用 $\Pi$ 表达非归约量化的意义来说是归约[predicative]的。在一些类型理论中，实际上会对 $\Pi$ 进行重载以使其也能表示 $\forall$ ：也就是说，在那些类型理论如 ECC（Luo 1994）和 Coq 的类型理论（Coq 2010）中，"$\forall x: A . P(x)$" 也可以写作 "$\Pi x: A . P(x)$"。

### Universes in linguistic semantics

总的来说，宇宙是有用的，因为它们使得我们能够将各种类型的集合视为内部的整体，并结合 $\Pi$ 类型，它们有助于以多态或通用的方式表示概念，这可以被称为 $\Pi$ 多态。在MTT语义中，典型的宇宙示例包括 $\mathsf{CN}$ ，即常见名词的宇宙，以及LTYPE，即“语言类型”的宇宙：我们现在用它们作为例子，来解释宇宙和相关的 $\Pi$ 多态性如何在语义构建中被有效地使用。

![image-20230604230843879](2.Modern Type Theories.assets/image-20230604230843879.png)

> Figure 2.1. $\mathsf{CN}$ 宇宙的绘画描绘

**常用名词的宇宙 $\mathsf{CN}$ 。**如罗（Luo，2011b，2012b）所介绍， $\mathsf{CN}$ 是所有常用名词（或其解释）的宇宙。因此， $\mathsf{CN}$ 是一个类型，其对象包括例如解释“man”的 $Man$ ，解释“红色桌子”的 $\Sigma x :Table.red (x)$ ，以及许多其他解释常用名词的类型。（参见图2.1以获取图像说明。）$\mathrm{CN}$ 和相关的 $\Pi$ 多态机制在语义构建中非常有用。例如，它可用于给动词修饰副词（Luo 2012b; Chatzikyriakidis 和 Luo 2017a）、次切性形容词[subsective adjectives]（Chatzikyriakidis 和 Luo 2017a）和量词（Lungu 和 Luo 2014; Chatzikyriakidis 和 Luo 2018）赋予语义，这分别由（2.20）、（2.21）和（2.22）实例化。（有关更多详细信息，请参见第3.1节和第3.3.2节。）

(2.20) $quickly : \Pi A: \mathsf{CN}. (A \rightarrow Prop ) \rightarrow(A \rightarrow Prop )$

(2.21) $small :\Pi A: \mathsf{CN}. (A \rightarrow Prop )$

(2.22) $some : \Pi A: \mathsf{CN}. (A \rightarrow Prop ) \rightarrow Prop$

在上述例子中，宇宙 $\mathsf{CN}$ 使我们能够给出多态类型：例如，我们可以将句子（2.23）理解为（2.24），其中 $Student : \mathsf{CN}$ 和 $speak : Human \rightarrow Prop$ （并且 $Student$ 是 $Human$ 的子类型——参见第2.4节）。

(2.23) $\text{Some students spoke.}$

(2.24) $some(Student, speak)$

$\mathsf{CN}$ 的子宇宙也可以用于语义构建。典型的例子包括由一个常用名词子类型构成的宇宙（参见Maclean和Luo（2020）以及第4章）。

**用于协同的LType宇宙。**引入LType宇宙以研究MTT语义中的协同问题（Chatzikyriakidis和Luo 2012）。例如，"和"这个词可以用来连接许多不同类型的实体，包括句子、动词、形容词、副词、量化的名词短语、专有名词等等，如(2.25-2.32)所示。

(2.25) (sentences) John walks and Mary talks.

(2.26) (verbs) John walks and talks.

(2.27) (adjectives) Mary is pretty and smart.

(2.28) (adverbs) The plant died slowly and agonizingly.

(2.29) (quantified NPs) Every student and some professor came.

(2.30) (quantifiers) Some but not all students got an A.

(2.31) (proper names) John and Mary went to Italy.

(2.32) (CNs) A friend and colleague came.

从语义上讲，人们称这些不同类型为可并联[conjoinable]（Partee和Rooth 1983年；Hoeksema 1998年）。在我们的框架中，它们对应于各种广泛的语义类型，如 $Prop$（对于句子），$A \rightarrow Prop$（对于域为$A$的动词），$\mathsf{CN}$（对于$\mathrm{CNs}$），$\Pi A: \mathsf{CN} .(A \rightarrow Prop ) \rightarrow(A \rightarrow Prop)$（对于修改动词的副词），以及其他许多类型。

我们引入一个包含所有这些可联结类型的宇宙LTYPE作为其对象，包括谓词的类型、表示$ \mathrm {CNs}$的类型，以及宇宙$\mathsf{CN}$ 本身（参见附录4中LTYPE的引入规则）。然后，我们可以使用与LTYPE相关的 $\Pi$ 多态性来给出"和"在(2.33)中的通用语义类型，所有的协同情况都可以通用地处理。

(2.33) $And : \Pi A: \mathrm{LTYPE} . A \rightarrow A \rightarrow A$

例如，现在可以给予(2.25)和(2.26)分别对应(2.34)和(2.35)的语义。在这些示例中，$And$ 首先应用于(2.34)中的可并联类型 - $Prop$ 和(2.35)中的 $Human \rightarrow Prop$ 。这说明了在(2.33)的 $A n d$ 的类型设置中使用 $\Pi$ 多态性的机制。

(2.34) $And(Prop,\ walk (j),\ talk(m))$

(2.35) $And(Human \rightarrow Prop,\ walk,\ talk )(j)$

语义操作符 $A n d(A)$ 可以按照预期为每个可连接 $A$ 类型定义。例如，对于类型为 $Prop$ 的命题，其含义可以定义为 (2.36)，通过这个我们将得到 (2.37)，如预期。

(2.36) $\operatorname{And}(Prop, P, Q)=P \wedge Q$

(2.37) $\operatorname{And}( Prop, \operatorname{walk} (j), \operatorname{talk}(m))=\operatorname{walk}(j) \wedge \operatorname{talk}(m)$

一般来说，对于LTYPE中的每一种类型，都可以给出这样的特征描述 - 详见附录4，你也可以在那里找到每一个(2.25-2.32)例子的语义。

### Tarski-style and Russell-style universes
