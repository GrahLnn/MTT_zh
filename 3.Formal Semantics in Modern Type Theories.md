# Formal Semantics in Modern Type Theories

本章讨论现代类型理论中的形式语义（MTT-语义）。在第一章（尤其 §1.4.1）我们已粗略展示过如何在 MTT-语义中解释若干基本语言范畴。经过上一章对 MTT 的核心结构的铺垫，现可系统展开 MTT-语义的关键性质。安排如下：§3.1 承接 §1.4.1，细化基本范畴的解释；§3.2 提炼 MTT-语义相对于 Montague 语义的若干独到之处；§3.3 以形容词修饰为案例，展示类型构造器在自然语言语义建模中的具体运用。

§3.2 从 **CNs-as-types（名词即类型）** 范式讲起（Ranta 1994；Luo 2012a）。一个常用名词（CN），如 *student*，可被视为某个“集合”。在 Montague 语义中，这一集合由中介语言（intermediate language/IL）或简单类型理论中的谓词 \(\mathbf e\to\mathbf t\) 表示，进一步在集合论中解释为一类实体[^1]。而在 MTT-语义中，用**类型**承载其意义：*student* 被解释为类型 \(Student\)。该类型既可作为原生类型出现，也可按具体语义需要由其他类型构造定义成结构化类型。§3.2.1 将系统阐明名词即类型的做法，讨论 CN 的辨识准则与集合/类型的构造观，说明 MTT 丰富的类型结构在其中的作用，并对比传统的 **CNs-as-predicates（名词即谓词）** 范式，给出名词即类型的优势。

[^1]: 在 Montague 语义中，常用名词可在 IL 或简单类型理论中表示为 \(\mathbf e\to\mathbf t\) 的谓词；其**含义承载语言**是集合论，谓词再在集合论里解释为相应集合。

采用名词即类型范式后，一个**充足的子类型机制**变得不可或缺。Ranta（1994）已注意到这是基础语义解释的需要，但未提供恰当的子类型方案。§3.2.2 将专门讨论 MTT-语义中的子类型，展示 §2.4 简述的**强制子类型**（coercive subtyping；Luo 1999；Luo et al. 2012）如何起到核心作用。我们还会说明强制子类型如何为更高阶语义现象提供手段，如**意义转移**（meaning transfers；Nunberg 1995）与**语言强制**（linguistic coercions；Asher & Luo 2013）[^2]。

[^2]: 强制子类型在其它构造中同样有用，例如用于构造**点类型**处理共指（见第 5 章），以及与**无交联合类型**结合解释**缺失形容词**的修饰（见 §3.3）。

§3.3 以传统分类为线索，系统考察**形容词修饰**。一方面展示 MTT 的类型结构在表达力上的强度与细腻度；另一方面说明不同类型构造器如何落地到自然语言语义表示。此节也将给出名词即类型范式的实操图景；更多相关应用见第 4 章与第 5 章。

## Basic linguistic categories

在 §1.4.1 我们粗述了基础语言范畴在 MTT-语义中的解读。表 3.1 与表 1.3 相同（参看表 1.1 获取相应的 Montague 式解释）。本节给出更细化的说明。

|                      | Example      | MTT-semantics                                                |
| -------------------- | ------------ | ------------------------------------------------------------ |
| $\text{CN}$          | man, human   | $Man,\ Human : \text{Type}$                                  |
| $\text{IV}$          | talk         | $talk : Human \rightarrow Prop$                              |
| $\text{ADJ}$         | handsome     | $handsome : Man \rightarrow Prop$                            |
| $\text{ADV}_{VP}$    | quickly      | $quickly : \Pi A:\mathsf{CN}.\,(A \rightarrow Prop) \rightarrow (A \rightarrow Prop)$ |
| $\text{Quantifier}$  | some         | $some : \Pi A:\mathsf{CN}.\,(A \rightarrow Prop) \rightarrow Prop$ |
| $\text{Modified CN}$ | handsome man | $\Sigma m:Man.\,handsome(m): \text{Type}$                    |
| $\text{S}$           | A man talks  | $\exists m:Man.\,talk(m): Prop$                              |

> 表 3.1. Examples in MTT-semantics

在 MTT-语义中，普通名词（CN）解释为**类型**（详见 §3.2.1），动词与形容词解释为在其**可适用对象域**上的谓词。表 3.1 的前三行体现了这一点：

$$
\tag{3.1} Man : \text{Type}
$$

$$
\tag{3.2} talk : Human \rightarrow Prop
$$

$$
\tag{3.3} handsome : Man \rightarrow Prop
$$

将 CN 解释为类型而非谓词的直接收益，是能区分**无意义**与**错误**。在 Montague 语义里，动词 *talk* 被解释为谓词（3.4），其域是统一的实体类型 $\mathbf e$。句子（3.5）因此得到（3.6）的解释；在 MTT-语义中对应为（3.7）。其中 $table_M:\mathbf e\rightarrow \mathbf t$ 为 “table” 的谓词式解释，而 $Table$ 是类型式解释。

\[
\operatorname{talk}_M:\mathbf e\rightarrow \mathbf t
\tag{3.4}
\]

\[
\text{(\#) A table talks.}
\tag{3.5}
\]

\[
(?)\ \exists x:\mathbf e.\ \operatorname{table}_M(x)\ \wedge\ \operatorname{talk}_M(x)
\tag{3.6}
\]

\[
(\#)\ \exists t:Table.\ talk(t)
\tag{3.7}
\]

（3.6）类型良好，只是在预期模型下为假；这不足以捕捉（3.5）被普遍视为**无意义**的直觉。相反，在（3.7）中，$talk$ 的定义域为 $Human$，将其应用于 $t:Table$ 使表达式**失去良类型性**，从而反映了（3.5）的**范畴错误**。换言之，在 MTT-语义中，**选择性限制**由底层类型直接刻画：若仅人类会说话，则 $talk$ 不可作用于桌子。注意，这是因为 “human”“table” 分别解释为 $Human$、$Table$ 两个类型，它们没有公共对象[^3]。

[^3]: 更形式地，$Human$ 与 $Table$ **不相交**。见 §7.1 的定义 7.1。

即便在上述简单设置下，**子类型**已开始发挥作用。考虑（3.8）与其语义（3.9）：

\[
\text{A man talks.}
\tag{3.8}
\]

\[
\exists m:Man.\ talk(m)
\tag{3.9}
\]

为何 $\operatorname{talk}(m)$ 良类型？虽然 $m:Man$ 而 $talk$ 的定义域是 $Human$，但由 $Man\le Human$ 的子类型关系，$m$ 可被视作 $Human$；等价地，由函数类型的**逆变性**可得
\[
Human\rightarrow Prop\ \le\ Man\rightarrow Prop,
\]
于是 $talk$ 也可用作 $Man\rightarrow Prop$，从而可作用于 $m$。§3.2.2 将系统讨论 MTT-语义中的子类型与强制子类型。

第二章已给出构造语义所需的工具。表 3.1 中，“quickly” 与 “some” 展示了动词修饰副词与量词的类型化；两者均依赖宇宙 $\mathsf{CN}$ 与相应的 **$\Pi$-多态**（见 §2.3.2）。在 Montague 语义里，动词短语的一般类型为（3.10）：

\[
\tag{3.10} \text{quickly}_M:(\mathbf e\rightarrow \mathbf t)\ \rightarrow\ (\mathbf e\rightarrow \mathbf t)
\]
由于 Montague 仅有统一的实体域 $\mathbf e$，一切此类谓词同型。MTT-语义不同：CN 作为类型引入了多样的对象域（如 $Man,\ Table$ 等）。此时副词 “quickly” 的适当刻画为（3.11）：它在 $\mathsf{CN}$ 上量化，并将任意 $A:\mathsf{CN}$ 上的谓词闭包为同域谓词。例如若 $run:Human\rightarrow Prop$，则 “run quickly” 的语义为 $quickly(Human, run):Human\rightarrow Prop$。

$$
\tag{3.11} \text{quickly}:\Pi A:\mathsf{CN}.\,(A\rightarrow Prop)\ \rightarrow\ (A\rightarrow Prop)
$$
量词同理。可将 “some” 借助逻辑存在量词 $\exists$ 定义为（3.12），并据此获得类型（3.13）——与逻辑量词 $\exists$ 的全域可用不同，语言量词 “some” 仅对 $\mathsf{CN}$ 中的名词类型定义。

\[
\text{some} \;=\;\lambda A:\mathsf{CN}.\,\lambda P:A\rightarrow Prop.\ \exists(A,P)
\tag{3.12}
\]

\[
\text{some}:\Pi A:\mathsf{CN}.\,(A\rightarrow Prop)\ \rightarrow\ Prop
\tag{3.13}
\]

于是（3.14）解释为（3.15），其中 $speak:Human\rightarrow Prop$ 且 $Student\le Human$。反之，若类型不解释任何 CN（如 $Prop\rightarrow Student$），则超出 $\mathsf{CN}$ 的取值域，表达式失去良类型性（3.16）。

\[
\text{Some students spoke.}
\tag{3.14}
\]

\[
some(Student,\,speak)
\tag{3.15}
\]

\[
(\#)\ \text{some}(Prop\rightarrow Student,\ \ldots)
\tag{3.16}
\]

$\Pi$-多态提供了紧凑而强力的表达资源，使我们能在统一框架下处理动词修饰副词、量词等语义现象；其作用亦见于**次分形容词**（如 *large*）等结构（§3.3.2）。

## Several unique features of MTT-semantics

本节展开三项仅属 MTT-语义的要点：**CNs-as-types 范式**、**子类型**以及**断言式解释**。它们与传统的 Montague 语义显著不同[^4]。

[^4]: 另一个独特点是 MTT-语义同时具备模型论与证明论特征，详见 §1.4.3，此处不再赘述。

### common nouns as types

在现代类型理论（MTT）中，普通名词（CN）解释为**类型**，而非谓词。与之相对，在 Montague 语义中，CN 解释为 $\mathbf e\!\to\!\mathbf t$ 的谓词。例如 “book” 在 Montague 里是 $\operatorname{book}_M:\mathbf e\to\mathbf t$，在 MTT 中则是类型 $Book:\text{Type}$。

将名词范畴视作类型，契合 Geach（1962）关于**名词类（sortal）**的洞见：一个名词确立的不仅是**适用准则**（何时该概念适用于某对象），还包含**辨识准则**（何时两个该概念下的对象算同一）。常见观点认为动词、形容词并不自带这样的辨识准则（见 Baker 2003）。

辨识准则的思想可追溯至 Frege（1884）在讨论抽象对象时的处理。几何中“方向”的同一性由**平行**判定：两线平行则方向相同。Geach 指出，每个 CN 都有相应的辨识准则，它奠定了**计数**的基础。Gupta（1980）给出典型对比：
\[
\text{EasyJet has transported 1 million passengers in 2010.} \\ 2010 年，易捷承运了一百万人次。
\tag{3.17}
\]

\[
\text{EasyJet has transported 1 million persons in 2010.}\\2010 年，易捷承运了一百万人。
\tag{3.18}
\]

（3.17）并不推出（3.18）：同一人多次乘机会重复计入“passenger”，却不应重复计入“person”。差异源于两个 CN 的**辨识准则**不同（Geach 1962；Gupta 1980；Baker 2003）[^5]。

[^5]: 关于“辨识准则”的反对意见见 Gupta（1980）与 Barker（2008）等；也有人倾向用语用学解释此类差异。本文立场是：辨识准则提供了更简洁的机制性说明。

该观念与**构造性**集合/类型观紧密对应。在构造数学（Bishop 1967；Beeson 1985）中，一个集合由“载体”与其内在**等式**组成；等式即给出辨识准则。若采用 Martin-Löf 类型理论（1975，1984），每个类型都内置这样的等式。需要强调：辨识准则**依语境而变**。如“student”：
\[
\text{John taught 500 students last year.}\\约翰去年教授了五百名学生。
\tag{3.19}
\]

\[
\text{1,000 students have applied for campus cards last year.}\\去年，有一千名学生申请了校园卡。
\tag{3.20}
\]

因此，将 CN 形式化为**等价化集合（setoid）**最为贴切：一对 $(A,\!\sim)$，其中 $A$ 是类型，$\sim$ 是刻画该 CN 辨识准则的等价关系。该思路在 Luo（2012a）系统阐述。实践上，大多数现象可安全忽略多重辨识准则的复杂性，直接把 CN 当作类型使用（Chatzikyriakidis & Luo 2018）[^6]。

[^6]: 共指与量化交互时可能需要精细区分，见第 5 章。

要让 “CN 作为类型”可运作，需依赖 MTT **丰富的类型构造**与**子类型**（§3.2.2）。交集型形容词可用 $\Sigma$-类型给出：

$$
\tag{3.21} \text{handsome man}\;=\;\Sigma x:Man.\;handsome(x)
$$
这里我们直接得到“帅气男人”的类型。是否有足够的构造来覆盖多样的语言“集合”？§3.3 将作案例研究：  
— 交集型修饰：$\Sigma$；  
— 次分（subsective）修饰：在宇宙 $\mathsf{CN}$ 上的 $\Pi$-多态；  
— 排除性（privative）修饰：不相交并类型；  
— 非承诺性修饰：基于“信念集合”算子。  
这些展示 MTT 的表达力足以覆盖由 CN 引入的多种集合结构；更高阶现象见第 4、5 章。

相较 Montague 的 “CN 作为谓词” 范式，“CN 作为类型”有多项优势：用**可判定类型检查**刻画选择性限制；与**子类型**天然兼容；能与点类型等机制一起，良好处理**共谓词**等高级现象[^7]。也有方案主张两种表征并行（如 Retoré 2013），但需要一种严密的对应，典型期望是：

$$
(*)\ \ \forall x:\mathbf e.\ \operatorname{man}_M(x)\ \text{为真}\ \Longleftrightarrow\ x:Man.
$$

[^7]: 共谓词与点类型见第 5 章；参看 Luo（2009c, 2012b）与 Chatzikyriakidis & Luo（2018）。

实际中，要在不破坏 MTT 基本性质（如**类型检查可判定性**）前提下满足 $(*)$，几乎不可行[^8]。若坚持以谓词表示 CN，那么完全可以退回简单类型理论而无需 MTT 的类型资源，由此也失去上述优势。类型理论语义中的相关议题，是如何从**断言式**解释转换为命题形式，见 §3.2.3 与 §7.1。

[^8]: 如 Chatzikyriakidis & Luo（2017b）所述，并行采用“CN 做类型/谓词”要求两者以期望方式对齐，这与 MTT 的判定性等元性质难以兼容。DTS 等做法虽以 MTT 为基础语言，却仍采“CN 做谓词”，因此无法享受 “CN 做类型” 的结构性收益。

### Subtyping in MTT-semantics

如 §2.4 所述，**强制子类型化**（coercive subtyping；Luo 1997；Luo 等 2012）为 MTT 提供了可用、相容的子类型机制。本节说明两点：其一，子类型是 MTT-语义可运作的关键；其二，它同样为各种**语言强制**（linguistic coercion；Luo 2009c；Luo & Callaghan 1998）提供了形式化工具。

**子类型：MTT-语义的支点。** 假设 John 是男人，托尔斯泰的《战争与和平》（$W\&P$）是一部“重书”：
\[
j: Man
\tag{3.22}
\]

\[
W\&P:\ \textit{heavy book},\quad 
\textit{heavy book} \;\coloneqq\; \Sigma x:Book.\; heavy(x)
\tag{3.23}
\]

考察三句：

\[
\text{John read a book.}
\tag{3.24}
\]

\[
\text{Somebody read "War and Peace".}
\tag{3.25}
\]

\[
\text{John read "War and Peace".}
\tag{3.26}
\]

令动词解释为（柯里化）谓词 $read: Human \to Book \to Prop$，其对应的形式为：

\[
\exists b:Book.\ read(j,b)
\tag{3.27}
\]

\[
\exists h:Human.\ read(h,W\&P)
\tag{3.28}
\]

\[
read(j,W\&P)
\tag{3.29}
\]

表面看（3.27–3.29）并非良类型：$read$ 的第一个自变量需是 $Human$，第二个需是 $Book$。在（3.27）与（3.29）中，我们给出的是 $j:Man$；在（3.28）中，第二自变量是 $\Sigma$-型对象 $W\&P:\Sigma x:Book.\ heavy(x)$。问题由**子类型**消解。引入如下关系：

\[
Man \leq Human \quad \text{（男人是人）}
\tag{3.30}
\]

\[
\Sigma x:Book.\ heavy(x) \leq Book \quad \text{（重书是书）}
\tag{3.31}
\]

子类型通过类型构造器**传递**：对函数型，域**逆变**、值域**协变**。一般式：

若 $A' \leq A$ 且 $B \leq B'$，则 $A \to B \leq A' \to B'$。

于是得到：

$$
\tag{3.32} (Human \to Book \to Prop)\ \leq\ (Man \to \Sigma x:Book.\ heavy(x) \to Prop)
$$
因此 $read$ 可被视为类型右侧的函数，既能作用于 $j:Man$，也能作用于 $W\&P:\Sigma x:Book.\ heavy(x)$，从而（3.27–3.29）皆良类型，分别解释（3.24–3.26）。

上述子类型可由**强制子类型化**实现。若 $Man$ 是基础类型，可假定存在常量强制 $mh:Man\to Human$ 并记 $Man \leq_{mh} Human$。若改以定义

$$
\tag{3.33} \Sigma x:A.\ P(x)\ \leq_{\pi_1}\ A
$$
则由 $Man \;\coloneqq\; \Sigma x:Human.\ male(x)$ 立得 $Man \leq_{\pi_1} Human$；同理 $\textit{heavy book}=\Sigma x:Book.\ heavy(x) \leq_{\pi_1} Book$。注意，这类**投影子类型**（projective subtyping）依赖隐式强制（如 $\pi_1$），而**包容式子类型**（subsumptive）无法以同样方式安全达成。

**备注.** 由于 CN 解释为类型（含经 $\Sigma$ 修饰的 CN），动词的可用“视型”会随上下文而异。上例中，若无强制，似乎要为 “read” 同时赋予多种函数类型，才能令（3.27–3.29）良类型——这正是 Ranta（1994, pp. 62–64）提出的**动词多重分类**问题。Ranta 的方案（显式使用 $\pi_1$）未能完全解决。采用**强制子类型化**后，将 $\pi_1$ 等视为隐式强制，动词仅以最自然的类型 $Human \to Book \to Prop$ 给出，由（3.30）–（3.33）与（3.32）的传递律自动获得所需“视型”，问题即被系统性化解。

**强制子类型化：语义构造中的强大工具。**  
除了作为 MTT 语义中进行**基本解释**的必需机制，强制子类型化还是一把极其好用的“工程扳手”：它支撑了多种语义构造，例如对**剥夺性形容词**（见 §3.3.3）的处理，以及对涉及**共指述词**的句子的**点类型**建模（见下文与第 5 章）。下面通过两个例子展示它在构造层面的作用。

我们的第一个例子（Luo 2011b）涉及**多义词**（homonymy）。当不同义项能用类型区分时，可以把“义项枚举”编码为强制，从而实现**自动消歧**。众所周知，同一词形往往对应彼此无关的含义。例如 “run” 在下列两句中的义项分别不同：

\[
\text{John runs quickly.} \quad \text{约翰跑得快。}
\tag{3.34}
\]

\[
\text{John runs a bank.} \quad \text{约翰经营一家银行。}
\tag{3.35}
\]

\[
run_{1}: Human \rightarrow Prop
\tag{3.36}
\]

\[
run_{2}: Human \rightarrow Institution \rightarrow Prop
\tag{3.37}
\]

为了在解释句子时**自动选中**正确义项，我们需要一种词义选择机制。对“简单”的多义现象，可以使用**重载**（overloading，或“情景多态”；Strachey 2000）。这可由强制子类型化（Luo 1999；Bailey 1999）实现，如下。

设多义词 $w$ 拥有若干义项 $w_{i}: A_{i}\ (i=1,\dots,n)$，且 $A_{j}\neq A_{k}$（当 $j\neq k$）。引入仅含一个对象的**单位类型** $\mathbf{1}_{w}$，其唯一对象记为 $w:\mathbf{1}_{w}$（关于单位类型的形式细节见附录 A2.4）。将各义项封装为强制
$$
c_{i}:\ \mathbf{1}_{w} \rightarrow A_{i}\quad (i=1,\dots,n),\qquad c_{i}(w)=w_{i}:A_{i}.
$$

以 “run” 为例，对应两条强制（见图 3.1）：[^9]
$$
c_{1}(\text{run})=run_{1},\qquad c_{2}(\text{run})=run_{2}.
$$

<img src="https://gitee.com/grahlnn/typora_img/raw/master/20251001203029.png" alt="image-20230608211339657" style="zoom:50%;" />

> 图 3.1  用强制子类型为 “run” 建模重载

于是，在任一**需要** $Human\to Prop$ 的语境 $\mathcal{C}_{1}[\text{run}]$ 中，
$$
\mathcal{C}_{1}[\text{run}]=\mathcal{C}_{1}[c_{1}(\text{run})]=\mathcal{C}_{1}[run_{1}],
$$
而在任一**需要** $Human\to Institution\to Prop$ 的语境 $\mathcal{C}_{2}[\text{run}]$ 中，
$$
\mathcal{C}_{2}[\text{run}]=\mathcal{C}_{2}[c_{2}(\text{run})]=\mathcal{C}_{2}[run_{2}].
$$

因此，系统能按语境类型需求插入相应强制，自动得到（3.39）与（3.40）的解释：在（3.39）中，$quickly(Human)$（见（3.38））要求其参数是 $Human\to Prop$，从而选择 $run_{1}$；在（3.40）中，句式需要 $Human\to Institution\to Prop$，于是选择 $run_{2}$。

\[
quickly(Human):\ (Human\rightarrow Prop)\ \rightarrow\ (Human\rightarrow Prop)
\tag{3.38}
\]
依据强制的**定义规则**，等式成立：

\[
[[\text{John runs quickly}]]\;=\; quickly(\text{run},j)\;=\; quickly(run_{1},j)
\tag{3.39}
\]

\[
[[\text{John runs a bank}]]\;=\;\exists b:Bank.\; run(j,b)\;=\;\exists b:Bank.\; run_{2}(j,b)
\tag{3.40}
\]

我们在 Coq 证明助手（Coq 2010）中对上述词义选择模型做过实验（Luo 2011b）；（3.39）与（3.40）的 Coq 代码见附录 A7.2。

**注。** 若某些义项**类型相同**，仅靠归类无法区分（如名词视为类型时的同形同音词 “bank”）。这时需要更多语言信息（如金融语境），或借助**部强制**（local coercions）来给出形式处理（见 Luo 2011b）。

---

第二个例子（Asher & Luo 2013）来自语言学中的**语言强制**（linguistic coercion），这类现象在 Pustejovsky（1995）等文献中讨论已久。强制子类型在此格外有效；在复杂场景中，还常要借助**依赖类型**，例如下面用到的**参数化强制**（parameterized coercions）。我们采用 Davidson（1967）的事件语义，并使用 Luo & Soloviev（2017）以及 §7.2 所述的**依赖事件类型**（refined event types），记为 $Evt_{A}(h)$。

考虑涉及相态动词 “start/begin/finish” 和动词 “enjoy” 的例子。直观上，（3.41）与（3.42）等义，提示 “enjoy” 的直接宾语应为**事件**。令
$$
enjoy:\ Human \rightarrow Event \rightarrow Prop
$$
其中 $Event$ 是所有事件的类型，则（3.43）的 MTT 解释初看应为（3.44）：

\[
\text{Julie enjoyed (started/finished) a book.}\\朱莉喜欢读一本书。
\tag{3.41}
\]

\[
\text{Julie enjoyed doing something with (e.g. reading, writing, …) a book.}\\朱莉喜欢做一些事情，比如阅读、写作……，与一本书共度时光。
\tag{3.42}
\]

\[
\text{Julie enjoyed a book.}
\tag{3.43}
\]

\[
\exists x:Book.\ enjoy(j,x)
\tag{3.44}
\]

问题在于 $enjoy(j)$ 的**自变量类型**是 $Event$，而 $x:Book$。在强制子类型框架下，给出

$$
\tag{3.45} Book \leq_{\text{reading}} Event
$$
把 $reading:Book\to Event$ 作为强制，则 $enjoy(j,x)$ 被系统强制为 $enjoy(j,reading(x))$ 并与之**判等**。也就是说，（3.43）被强制为（3.46），其语义（3.47）与（3.44）在形式上等价：

\[
\text{Julie enjoyed reading a book.}
\tag{3.46}
\]

\[
\exists x:Book.\ enjoy(j,reading(x))
\tag{3.47}
\]

当然，强制并非唯一：也可能是 “enjoy writing a book”。不同强制的**作用域**可彼此交错（overlap），如（3.48）所示：

$$
\tag{3.48} \text{Julie just started War and Peace,}\\朱莉刚开始阅读《战争与和平》，\\
\text{which Tolstoy finished after many years of hard work.}\\这是托尔斯泰经过多年辛勤创作完成的巨著。\\
\text{But that will not last because she never gets through long novels.}\\但这不会持续太久，因为她从未能读完长篇小说。
$$
在此类情形中，**依赖类型**尤其有用。参照 Asher & Luo（2013），我们不再使用单一的 $Event$，而引入按**主题角色**（thematic roles）加索引的**精细事件类型**[^10]。例如，引入以施事者 $a$ 为索引的族 $Evt_{A}(a)$（$a:Agent$）。人类是施事者，故 $Human \leq Agent$；对任意 $h:Human$，$Evt_{A}(h)$ 表示由 $h$ 发出（参与）的事件。设相关动词类型为：
$$
\begin{aligned}
&start,\ finish,\ last:\ \Pi h:Human.\ (Evt_{A}(h)\rightarrow Prop)\\
&read,\ write:\ \Pi h:Human.\ (Book \rightarrow Evt_{A}(h))
\end{aligned}
$$
[^10]: 语言学中的“主题角色”（又称“主题关系”）是指名词短语在谓词事件中的角色，如施事、受事等。

进一步，引入**参数化强制**[^11]
$$
\tag{3.49} Book \leq_{c(h)} Evt_{A}(h)\quad (h:Human),
$$
并定义
$$
\tag{3.50} c(h,b)=
\begin{cases}
write(h,b) & \text{若 } h \text{写过 } b,\\
read(h,b)  & \text{否则。}
\end{cases}
$$
[^11]: 即以 $h:Human$ 为参数的强制。就我们所知，Asher & Luo（2013）是首次在语言实例中系统使用参数化强制的工作。

据此，可把（3.48）简化解释为（3.51）。其中 $j,t$ 分别解释为 “Julie”“Tolstoy”，而 $\Sigma b:Book.\ long(b)$ 是 “long book” 的解释。应用（3.49）插入强制，得到（3.52）；再按（3.50）部分化简为（3.53）：

$$
\tag{3.51}
\begin{aligned}
&\ \ start(j,W\&P)\\
&\wedge\ finish(t,W\&P)\\
&\wedge\ \neg\,last(j,W\&P)\\
&\wedge\ \forall lb:(\Sigma b:Book.\ long(b)).\ \neg\,finish\bigl(j,\pi_{1}(lb)\bigr)
\end{aligned}
$$

$$
\tag{3.52}
\begin{aligned}
&\ \ start\bigl(j,c(j,W\&P)\bigr)\\
&\wedge\ finish\bigl(t,c(t,W\&P)\bigr)\\
&\wedge\ \neg\,last\bigl(j,c(j,W\&P)\bigr)\\
&\wedge\ \forall lb:(\Sigma b:Book.\ long(b)).\ \neg\,finish\bigl(j,c\bigl(j,\pi_{1}(lb)\bigr)\bigr)
\end{aligned}
$$

$$
\tag{3.53}
\begin{aligned}
&\ \ start\bigl(j,read(j,W\&P)\bigr)\\
&\wedge\ finish\bigl(t,write(t,W\&P)\bigr)\\
&\wedge\ \neg\,last\bigl(j,read(j,W\&P)\bigr)\\
&\wedge\ \forall lb:(\Sigma b:Book.\ long(b)).\ \neg\,finish\bigl(j,c\bigl(j,\pi_{1}(lb)\bigr)\bigr)
\end{aligned}
$$

以第一行为例，有等式
$$
start(j,W\&P)=start\bigl(j,c(j,W\&P)\bigr)=start\bigl(j,read(j,W\&P)\bigr),
$$
第一步由 $start(j):Evt_{A}(j)\to Prop$ 和 $W\&P:Book \leq_{c(j)} Evt_{A}(j)$ 得出，第二步由 $c(j)$ 的定义给出。$finish$、$last$ 同理。

细看可知，（3.53）正是（3.48）的预期语义。注意最后一行中 $c\bigl(j,\pi_{1}(lb)\bigr)$ 仍保持抽象形态：因为 $lb$ 是变量，无法进一步化简。

### Judgmental interpretations and their propositional forms

在类型理论中，“断言”及其**可推导性**是基础概念：例如，断言 $a:A$ 表达“对象 $a$ 属于类型 $A$”[^12]；这样的断言要么可推导（正确），要么不可推导（错误）。在类型理论语义中，我们允许**断言式解释**与**命题式解释**并存：句子既可以解释为断言，也可以解释为 $Prop$ 中的逻辑命题。例如，(3.54) 可解释为断言 (3.55)，而 (3.56) 则解释为命题 (3.57)。

[^12]: 参见 §2.1 对“断言”的介绍。一般形式为 $\Gamma \vdash_{\Delta} a:A$。下文为简洁起见多省略 $\Gamma,\Delta$，直接写 $a:A$。

\[
\text{John is a human.}
\tag{3.54}
\]

\[
j : Human
\tag{3.55}
\]

\[
\text{John talks.}
\tag{3.56}
\]

\[
\operatorname{talk}(j)
\tag{3.57}
\]

许多场合下，我们需要把像 (3.55) 这样的**断言式解释**转成对应的**命题形式**。本节先做非正式说明：为什么要这样做、以及如何去做；更完整与严格的处理见 §7.1[^13]。

[^13]: 出于可读性考虑，正式论证放在 §7.1。那里将使用一个较技术性的工具——**异构等式**（heterogeneous equality）。

首先，看哪些断言是**可推导**的。比如当已知 $j:Man$ 且 $Man\leq Human$ 时，(3.55) 可推导。相反，有些断言不可推导，从而对应的句子在通常语境下**无意义**。例如，(3.58) 通常被视为无意义（除非在虚构或特殊语境中），其语义 (3.59) 就是不可推导的[^14]。

[^14]: (3.55) 的可推导性显而易见；(3.59) 的不可推导性依赖于一个事实：$Human$ 与 $Table$ **不相交**（没有共同对象）。形式化定义见 §7.1（Luo & Xue 2020）。

\[
\text{(\#) John is a table.}
\tag{3.58}
\]

\[
j:Table
\tag{3.59}
\]

再者，还有一些断言处于**待定**状态：是否可推导取决于具体语境是否给足信息。比如 (3.60) 的断言 (3.61) 可能可推导也可能不可推导：如果 $j$ 是**男学生**，则可推导；如果 $j$ 根本不是学生，则不可推导[^15]。

[^15]: 形式化地，例如 $j:\Sigma x:\!Student.\,male(x)$（该类型既是 $Student$ 的子类型，也是 $Man$ 的子类型），且 $Student\leq Human$、$Man=\Sigma x:\!Human.\,male(x)$ 时，(3.61) 可推导；在许多其他语境下则不可推导。

\[
\text{John is a student.}
\tag{3.60}
\]

\[
j:Student
\tag{3.61}
\]

关键点在于：**断言不是命题**，不能直接与其他命题组合。例如，处理含连词“and”的复句 (3.62) 时，若直接写 (3.63)，这是**不合法**的（就算强行当命题用也会类型错误），因为 $j:Human$ 不是命题，不能参与 $\wedge$。

\[
\text{John is a human and he is happy.}
\tag{3.62}
\]

\[
(\#)\ (j:Human)\ \wedge\ \operatorname{happy}(j)
\tag{3.63}
\]

因此需要把断言式解释转成**命题形式**。先从**可推导**的断言说起：若 $a:A$ 可推导，则可配一个恒真谓词
$$
p_A:A\to Prop,\quad\text{使得对任意 }x:A,\ p_A(x)=\mathbf{true}\tag{3.64}
$$
把 $a:A$ 的命题形式记为 $p_A(a)$。例如，$j:Human$ 的命题形式是 $p_{Human}(j)$，从而复句 (3.62) 可解释为 (3.65)；也就是把 (3.63) 中的 $(j:Human)$ 用 $p_{Human}(j)$ 取代。

$$
\tag{3.65} p_{Human}(j)\ \wedge\ \operatorname{happy}(j)
$$
注意，虽然 $p_A$ 是恒真的**常量谓词**，但它并不“空洞”：$p_A(a)$ 的**可类型化**前提正是 $a:A$ 成立。元层面上，$p_A(a)$ 为真当且仅当 $a:A$ 可推导。因此，用 $p_A(a)$ 作为可推导断言 $a:A$ 的命题形式是恰当的。

对于**不可推导**的断言，其对应句子通常无意义（如 (3.58)）。但它的**否定**、或把它置于**条件前件**中的用法，却往往是有意义的，如 (3.66) 与 (3.67)。

\[
\text{John is not a table.}
\tag{3.66}
\]

\[
\text{If John were a table, Mary would be happy.}\\如果约翰是一张桌子，玛丽一定会很高兴。
\tag{3.67}
\]

如何解释此类句子？我们有三条“不可行”的直觉路径：  
其一，不能直接写 $\neg(j:Table)$（见 (3.68)），因为 $j:Table$ 不是命题；  
其二，不能在**元层**说“$j:Table$ 不可推导”（见 (3.69)），那只是元陈述；  
其三，也不能写 $\neg p_{Table}(j)$（见 (3.70)），因为 $p_{Table}(j)$ 本身要求 $j:Table$ 可类型，从而**预设**了欲否定之事。

\[
(\#)\ \neg(j:Table)
\tag{3.68}
\]

\[
(\#)\ “j:Table \text{ 不可推导}”
\tag{3.69}
\]

\[
(\#)\ \neg\,p_{Table}(j)
\tag{3.70}
\]

解决之道是为断言 $t:A$ 引入一个**专门的命题形式**：写作 $\mathrm{\small IS}(A,t)$，直观含义是“$t$ 属于 $A$”。于是，
(3.66) 与 (3.67) 分别解释为 (3.71) 与 (3.72)。
\[
\neg\,\mathrm{\small IS}(Table, j)
\tag{3.71}
\]

\[
\mathrm{\small IS}(Table, j)\ \Rightarrow\ \operatorname{happy}(m)
\tag{3.72}
\]

总结一下：对任意 $t:T$ 与类型 $A$，若断言 $t:A$ 可推导，则用 $p_A(t)$ 作为命题形式；若 $t:A$ 不可推导、但在**负向语境**（如否定、条件前件）中有意义，则用 $\mathrm{\small IS}(A,t)$ 作为命题形式。

**备注。** 当断言尚处于**待定**（潜在可推导）状态时，可**临时**用 $\mathrm{\small IS}$-命题作为其命题形式。例如，(3.60) 的 $j:Student$ 可先记作 $\mathrm{\small IS}(Student,j)$；相应地：
\[
\text{John is a student and he is happy.}\\约翰是学生，他感到很开心。
\tag{3.73}
\]

\[
\text{John is not a student.}\\约翰不是学生。
\tag{3.74}
\]

\[
\text{If John is a student, he is happy.}\\如果约翰是学生，他会很高兴。
\tag{3.75}
\]

的解释分别为：

\[
\mathrm{\small IS}(Student, j)\ \wedge\ \operatorname{happy}(j)
\tag{3.76}
\]

\[
\neg\,\mathrm{\small IS}(Student, j)
\tag{3.77}
\]

\[
\mathrm{\small IS}(Student, j)\ \Rightarrow\ \operatorname{happy}(j)
\tag{3.78}
\]

但要注意：一旦语境补全、$j:Student$ **可推导**，则应把 $\mathrm{\small IS}(Student,j)$ 替换成 $p_{Student}(j)$（两者在逻辑上等价，见 §7.1）。若最终不可推导，则 (3.77)、(3.78) 仍恰当，而 (3.76) 就不合适了（常被称为“过度生成”）。

除了断言式解释外，还有一类麻烦来自**潜在类型错误**的谓词应用，常见于否定句或条件句。例如：(3.79) 是否定一般动词 “talk” 的句子。不同于肯定句 “Tables talk”（通常无意义），其否定句是有意义的。但不能像 (3.80) 那样处理，因为 $\operatorname{talk}(x)$ 在 $x:Table$ 下**类型错误**。为此我们引入命题算符 $\mathrm{\small DO}(p,x)$，其直觉是“$x$ 做（或处于）谓词 $p$ 所描述的事态”。于是，(3.79) 与 (3.82) 分别解释为 (3.81) 与 (3.84)。

\[
\text{Tables do not talk.}\\桌子不会说话。
\tag{3.79}
\]

\[
(\#)\ \forall x:Table.\ \neg\,\operatorname{talk}(x)
\tag{3.80}
\]

\[
\forall x:Table.\ \neg\,\mathrm{\small DO}(\operatorname{talk},x)
\tag{3.81}
\]

\[
\text{If a table talked, Mary would be surprised.}\\如果一张桌子会说话，玛丽一定会感到惊讶。
\tag{3.82}
\]

\[
(\#)\ \exists x:Table.\ \operatorname{talk}(x)\ \Rightarrow\ \operatorname{surprised}(m)
\tag{3.83}
\]

\[
\exists x:Table.\ \mathrm{\small DO}(\operatorname{talk},x)\ \Rightarrow\ \operatorname{surprised}(m)
\tag{3.84}
\]

从技术上，$\mathrm{\small IS}$ 与 $\mathrm{\small DO}$ 可统一经由一个更基本的算符 $\mathrm{\small NOT}$ 来定义。其类型与定义如下：

\[
\mathrm{\small NOT}:\ \Pi X:\mathsf{CN}\ \Pi p:X\!\to\!Prop\ \Pi Y:\mathsf{CN}\ \Pi y:Y.\ Prop
\tag{3.85}
\]

\[
\text{对任意 } X:\mathsf{CN},\ y:B,\ \text{定义}\quad
\mathrm{\small IS}(X,y)\;=\;\neg\,\mathrm{\small NOT}\bigl(X,\ p_X,\ B,\ y\bigr)
\tag{3.86}
\]

其中 $p_X$ 为 (3.64) 的恒真谓词。
\[
\text{对任意 } p:A\!\to\!Prop,\ y:B,\ \text{定义}\quad
\mathrm{\small DO}(p,y)\;=\;\neg\,\mathrm{\small NOT}(A,\ p,\ B,\ y).
\tag{3.87}
\]
算符 $\mathrm{\small NOT}$ 已在 Xue et al.（2018, 2020）与 Chatzikyriakidis & Luo（2017b）中提出并讨论，§7.1 将进一步给出其**正式引入**与**合理性证明**。尤其地，我们将通过对 MTT 进行以 $\mathrm{\small NOT}$ 为公理的扩展，并借助类型理论中的**异构等式**来证明该扩展的可接受性（Xue et al. 2018, 2020）。

## Adjectival modification: a case study

本节以一个经典框架为例，展示如何在 MTT-语义中为形容词修饰建立语义。我们沿用 Montague 传统下的基础分类（Kamp 1975），并借此说明：MTT 的**丰富类型结构**如何支撑一套既强大又实用的语义机制。

| 分类                      | 推论关系                                                     | 例子                             | 类型/机制     |
| ------------------------- | ------------------------------------------------------------ | -------------------------------- | ------------- |
| Intersective（交集型）    | $\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N}\ \&\ \mathrm{Adj}$ | handsome man（英俊的男人）       | $\Sigma$-类型 |
| Subsective（子集型）      | $\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N}$      | large mouse（大的老鼠）          | $\Pi$-多态    |
| Privative（否定/剥夺型）  | $\operatorname{Adj}[\mathrm{N}] \Rightarrow \neg \mathrm{N}$ | fake gun（假枪）                 | 无交联合类型  |
| Non-committal（非承诺型） | $\operatorname{Adj}[\mathrm{N}] \Rightarrow\ ?$              | alleged criminal（被指称的罪犯） | 信念合集算子  |

> 表 3.2  形容词分类

以上四类按“形容词+名词”可推出的基本推论来区分（见表第二列）[^17]。第三列给出典型例子，第四列标出我们在 MTT 中将使用的类型构造/机制。尽管整体思路延续了既有工作（Luo 2011a; Chatzikyriakidis & Luo 2013, 2017a），但对**否定/剥夺型**与**非承诺型**的处理有若干改进与推进。

交集型形容词（如“black/黑色的”“handsome/英俊的”“French/法国的”）与名词的组合等价于各自条件的合取：例如“black cat” 推出 “black” 与 “cat”，进而推出 “black mammal”“black animal”等。其关键特征是：形容词所表达的性质**不依赖**于被修饰的名词类。

子集型形容词则**依赖**名词类来确定含义与比较基准：一位“skilled surgeon（熟练的外科医生）”并不意味着在一切方面都熟练；“large mouse（大的老鼠）”是在“鼠”这一范畴内的大，而并非“巨型生物”。这类形容词的解释需要携带“所修饰 CN 的语境”信息[^18]。

否定/剥夺型（privative）修饰使结果**不属于**原名词类，如“fake gun（假枪）”并不属于“gun”。非承诺型（non-committal）则不对是否属于原类作承诺，如“alleged criminal（被指称的罪犯|所谓的罪犯）”既可能是罪犯，也可能不是[^19]。

在建模上，我们把形容词修饰视为**从 CN 到 CN 的变换**。在传统 Montague 语义中，CN 被解释为性质（$\mathbf{e}\!\to\!\mathbf{t}$），于是形容词修饰是“性质到性质”的函数。例如“handsome man”由“$handsome: (\mathbf{e}\!\to\!\mathbf{t})\!\to\!(\mathbf{e}\!\to\!\mathbf{t})$ 与 $man: \mathbf{e}\!\to\!\mathbf{t}$ 组合得到新的性质。而在 MTT-语义中，CN 被解释为**类型**：形容词修饰接收一个形容词（谓词）与一个 CN（类型），并产出**新的类型**。以“handsome man”为例，我们从 $handsome: Man\!\to\!Prop$ 与 $Man:\!Type$ 出发，得到一个代表“英俊的男人”的类型。

接下来的各小节将逐一给出四类形容词的 MTT 实现思路：  
— 交集型：用 $\Sigma$-类型实现交集；  
— 子集型：在宇宙 $\mathsf{CN}$ 上用 $\Pi$-多态表达对被修饰类的依赖；  
— 否定/剥夺型：用无交联合类型刻画“假/伪”等排除性构造；  
— 非承诺型：用“信念合集算子”建模据称/所谓等态度类修饰。

**备注。** 本章的建模一大优点在于：各类形容词的目标推论性质**由类型系统本身推出**，而无需额外语义公理或外加含义假设。这一点在实际推导与实现中尤显重要。

[^17]: “Subsective/子集型”在早期文献常被当作“非交集型”的统称；另一些文献把“否定/剥夺型”与“非承诺型”统称为“非子集型”。关于 privative 是否真正“排除原类”，存在分歧，参见 Partee (2007, 2010) 与 §3.3.3。  
[^18]: 有人主张真正的“交集型”很少，甚至不存在：即便是“black”，跨语境/社群也可能转为子集型解读（譬如“黑血”指深红）。我们在此采取操作性假设：交集型类别**存在且有动机**，以便开展系统建模。  
[^19]: 个别形容词在不同学者/语境下判断不一，例如 “former” 有时被归入 privative，有时被视作 non-committal。

### Intersective adjectives

用 $\Sigma$-类型刻画形容词修饰的想法可追溯至 Mönnich (1985)、Sundholm (1986) 与 Ranta (1994)。不过，早期方案并不完备：缺少**合适的子类型机制**，难以在类型层面支撑预期推理（参见第 68 页脚注 21）。本节先简述如何用 $\Sigma$-类型解释**交集型**形容词修饰，然后说明为何在配备强制子类型后，这一解释是充分的。

在 MTT-语义中，常名词（CN）解释为**类型**，形容词解释为**谓词**，即某个 $A:\mathsf{CN}$ 上的函数 $A \rightarrow Prop$。例如，“black”的语义类型是 (3.88)，其中 $Object$ 表示（物理）对象的类型；“black cat” 则由 (3.89) 的 $\Sigma$-类型给出，其中 $Cat$ 是猫的类型。

\[
\text{black} : Object \rightarrow Prop
\tag{3.88}
\]

\[
\text{black cat} = \Sigma x: Cat.\ \text{black}(x)
\tag{3.89}
\]

关键在于：子类型会**经由类型构造器**（如 $\Sigma$）向上传播。一只“black cat”当然也是“black object”。这对应于子类型关系 (3.91)：若 $Cat \leq Object$，则通过 $\Sigma$ 的传播[^20]可得

$$
\tag{3.91} \Sigma x: Cat.\ \text{black}(x) \leq \Sigma x: Object.\ \text{black}(x)
$$

[^20]: 子类型随构造器传播可由推导规则形式化（Luo 1999）。以 $\Sigma$ 为例（使用 $\mathrm{LF}_{\Delta}$ 记法）：$\frac{\Gamma \vdash_{\Delta} A \leq_{c} A'\quad\Gamma, x\!:\!A \vdash_{\Delta} B(x) \leq_{c'[x]} B'(c(x))} {\Gamma \vdash_{\Delta} \Sigma(A,B) \leq_{d_{\Sigma}} \Sigma(A',B')}$ 其中 $d_{\Sigma}$ 把 $(a,b)$ 映到 $\bigl(c(a),\ c'[a](b)\bigr)$。形式化地，对任意 $z:\Sigma(A,B)$，$d_{\Sigma}(z)=\bigl(c(\pi_1(z)),\ c'[\pi_1(z)](\pi_2(z))\bigr)$。
我们的主张（Luo 2009c）是：**在配备强制子类型**的前提下，用 $\Sigma$-类型能够**充分**解释交集型形容词修饰。充分性体现在两点。

**其一：导出交集型的两类标准推论。**  
交集型形容词满足 $\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N}$ 与 $\operatorname{Adj}[\mathrm{N}] \Rightarrow \operatorname{Adj}$（见表 3.2；Kamp 1975）。先看第一类（3.92–3.94）。(3.94) 成立的原因是我们始终把第一投影 $\pi_1$ 当作**强制子**：一般地，$\Sigma x:A.\ B(x) \leq_{\pi_1} A$。于是 $\Sigma x:[[N]].[[Adj]](x)$ 的每个对象都可当作 $[[N]]$ 的对象——这正是“black cat 是 cat”。

\[
\text{A black cat is a cat.}
\tag{3.92}
\]

\[
\operatorname{Adj}[\mathrm{N}] \Rightarrow \mathrm{N}
\tag{3.93}
\]

\[
\Sigma x:\ [[N]].\ [[Adj]](x)\ \leq\ [[N]]
\tag{3.94}
\]

第二类推论（3.95–3.97）对应 $\Sigma$ 的第二投影：若 $p:\Sigma x:[[N]].[[Adj]](x)$，则 $p$ 必为一对 $\bigl(n,\ p_n\bigr)$，其中 $n:[[N]]$ 且 $p_n:[[Adj]](n)$（注意 $\pi_1(p)=n$）。于是“black cat 是 black”成立。

\[
\text{A black cat is black.}
\tag{3.95}
\]

\[
\operatorname{Adj}[\mathrm{N}] \Rightarrow \operatorname{Adj}
\tag{3.96}
\]

\[
\text{若 } p:\Sigma x:[[N]].[[Adj]](x),\ \text{则 } [[Adj]]\bigl(\pi_1(p)\bigr)\ \text{为真}
\tag{3.97}
\]

**其二：两项必要条件。**  
上述 $\Sigma$-解释要奏效，至少需满足两点[^21]：

1) **合适的子类型机制。** 我们采用**强制子类型**（Luo 1999; Luo et al. 2012；见 §2.4 与 §3.2.2）。若无该机制，“$\Sigma$ 表示交集”将无法与整体推理系统顺畅对接。

2) **证明无关性（proof irrelevance）。** 若无此原则，$\Sigma$-解释会在“计数/同一性”上失真。以“black cat”为例，要让
$\Sigma x:Cat.\ \text{black}(x)$ 真的对应“黑猫”，须保证：两只“黑猫”只有在**猫相同**时才相同，和“如何证明它黑”无关。也就是：对同一只猫 $c$，$(c,p)$ 与 $(c,p')$ 应视为同一对象，不因 $p,\ p'$（对 $\text{black}(c)$ 的不同证明）而区分。再看 (3.98) 的句子，它涉及“多数计数”，更能看出证明无关性的必要

$$
\tag{3.98} \text{Most persons who traveled by plane are happy.}\\大多数乘坐飞机的人都感到满意。
$$

关于 (3.98) 以及“most”的计数问题，可参见 Luo (2012a, 2019b)，并对照第 15/16 页脚注 25/26 的讨论[^22]。

[^21]: Ranta 用 $\Sigma$-类型处理形容词修饰的早期设想之所以不充分，主要在于 Martin-Löf 类型理论中缺乏合适的子类型机制，且未解决计数问题。《Ranta 1994》§3.3 指出的“动词多重分类”难题给出了三种备选：其一回退到谓词逻辑（非组合性强，不可取）；其二使用 Nordström 等（1990）第 18 章的“子集”概念（已知会破坏规范化与类型检查的可判定性）；其三显式使用第一投影，虽接近但仍欠一步。我们的做法把 $\pi_1$ 纳入强制子类型框架中的**隐式强制**，从而得到完整解法。  
[^22]: 只有当类型理论在“逻辑命题”与“数据类型”之间做出区分时，才能实施**证明无关性**。例如在不可归谓的 UTT（Luo 1994）中可直接实现；而在可归谓的 MLTT（Nordström et al. 1990）中，命题与类型同构，若对“所有命题”实施证明无关性将导致整体坍缩，这显然不可行。Luo (2019b) 提议把 Voevodsky 的 h-逻辑（HoTT 2013）扩展到 MLTT，得到 $\mathrm{MLTT}_{h}$，以在可归谓环境中为 MTT-语义提供合适基础。

### Subsective adjectives

前面看到，交集型形容词可解释为谓词，配合带子类型的 $\Sigma$-类型即可刻画相应的修饰。但对**细分型**形容词，这套做法就不成立；若仍照搬，会产生过度推导。

以“small（小）”为例。若将“小象/小动物”分别解释为 (3.99) 与 (3.100)，再结合 $Elephant \leq Animal$，就会错误地推出每头小象都是小动物，如 (3.101) 所示。

\[
\Sigma x:\ Elephant.\ SMALL(x)
\tag{3.99}
\]

\[
\Sigma x:\ Animal.\ SMALL(x)
\tag{3.100}
\]

\[
(\#)\ \text{small elephant} \leq \text{small animal}
\tag{3.101}
\]

类似地，“skilled（熟练的）”只在所修饰的名词域内起作用：外科医生的“熟练”并不推出他在一切领域都熟练。也就是说，诸如 small、skilled 等形容词随所修饰的 CN 不同而**语义依赖**。

解决思路（Chatzikyriakidis & Luo 2013, 2017a）：借助宇宙 $\mathsf{CN}$（见 §2.3.2）上的 **$\Pi$ 多态性**。让细分型形容词在 $\mathsf{CN}$ 上多态：例如

\[
\Pi A:\mathsf{CN}.\ (A \rightarrow Prop)
\tag{3.102}
\]
于是对每个 $A:\mathsf{CN}$，都有专属谓词 $\text{small}(A):A\rightarrow Prop$。据此，

\[
\text{small elephant}=\Sigma x:\ Elephant.\ \text{small}(\!Elephant\!)(x)
\tag{3.103}
\]

\[
\text{small animal}=\Sigma x:\ Animal.\ \text{small}(\!Animal\!)(x)
\tag{3.104}
\]

此时 $\text{small}(Elephant)$ 与 $\text{small}(Animal)$ 是**不同谓词**，自然不会得到 (3.101) 那种不期望的结论。直观地说，细分型形容词只相对于所修饰的 CN 来判定：小象只是**相对大象而言**小；“熟练的外科医生”只是作为外科医生熟练。

总之：对细分型形容词，赋予其 $\Pi$ 多态类型（如 (3.102)），组合时仍用 $\Sigma$-类型形成修饰后的 CN（如 (3.103)(3.104)）。由此保持细分型修饰的基本推论：

$$
\tag{3.105} \operatorname{Adj}[N] \Rightarrow N
$$
而由于不存在一个“通用”的 $SMALL$ 谓词，像 (3.101) 这样的过度推导不再出现；我们只有各 CN 的实例化谓词（如 $\text{small}(Elephant)$、$\text{small}(Animal)$）。

---

### Privative adjectives

“fake（假）”“imaginary（虚构的）”“fictitious（杜撰的）”等通常被归为**剥夺性**（privative）形容词。直观上，人们常写作

\[
\operatorname{Adj}[N] \Rightarrow \neg N
\tag{3.106}
\]
例如：

\[
\text{A fake gun is not a (real) gun.}\\假枪并不是真枪。
\tag{3.107}
\]

不过，剥夺性是否真的总意味着 (3.106)，并无共识。Partee (2007, 2010) 主张，像 “fake” 的语义更适合与**类型转换/语言强制**联动理解：在 (3.108)(3.109) 的语境中，“fur” 的涵义似应扩展为“真皮毛 + 假皮毛”的并集。

$$
\tag{3.108} \text{I don't care whether that fur is fake fur or real fur.}\\我不在乎那是不是人造毛皮，还是天然毛皮。
$$

$$
\tag{3.109} \text{I don't care whether that fur is fake or real.}\\我不在乎那只毛皮是真还是假。
$$

与此思路一致，Luo (2011a) 在 MTT-语义中提出用**无交并和类型（disjoint union）**来建模剥夺性修饰（见 §2.2.3），随后在 Chatzikyriakidis & Luo (2013, 2017a) 进一步发展。以 “fake” 修饰 “gun” 为例：

设所有“枪”的类型 $G$ 是“真枪” $G_R$ 与“假枪” $G_F$ 的无交并和：

\[
G = G_R + G_F
\tag{3.110}
\]

于是 $G$ 的对象或为 $\operatorname{inl}(r)$（$r:G_R$），或为 $\operatorname{inr}(f)$（$f:G_F$）。在 $G$ 上定义谓词：

\[
\operatorname{real}_g(\operatorname{inl}(r))=\mathbf{true},\quad \operatorname{real}_g(\operatorname{inr}(f))=\mathbf{false}
\tag{3.111}
\]

\[
\operatorname{fake}_g(\operatorname{inl}(r))=\mathbf{false},\quad \operatorname{fake}_g(\operatorname{inr}(f))=\mathbf{true}
\tag{3.112}
\]

再把“fake/real”做成在 $\mathsf{CN}$ 上的 $\Pi$ 多态家族（与细分型处理保持一致）：

\[
\textit{fake},\ \textit{real}:\Pi A:\mathsf{CN}.\ (A\rightarrow Prop)
\tag{3.113}
\]

对具体 $A$ 取实例。若 $A$ 由上面的 $G$ 解释，则

\[
\textit{fake}(G)=\operatorname{fake}_g
\tag{3.114}
\]

\[
\textit{real}(G)=\operatorname{real}_g
\tag{3.115}
\]

据此，用 $\Sigma$-类型形成修饰后的 CN：

\[
\text{fake gun}=\Sigma g:\ G.\ \textit{fake}(G,g)
\tag{3.116}
\]

\[
\text{real gun}=\Sigma g:\ G.\ \textit{real}(G,g)
\tag{3.117}
\]

该设置给出预期推论。例如：

$$
\tag{3.118} \text{That gun is either real or fake.}\\那把枪要么是真枪，要么是假枪。
$$

$$
\tag{3.119} \text{A fake gun is not a (real) gun.}\\假枪并不是真枪。
$$

可分别解释为：

\[
\operatorname{real}(G,g)\ \vee\ \operatorname{fake}(G,g)
\tag{3.120}
\]

\[
\forall f:\bigl[\Sigma g:\ G.\ \operatorname{fake}(G,g)\bigr].\ \neg\operatorname{real}(G,f)
\tag{3.121}
\]

注意 (3.121) 中 $\neg\operatorname{real}(G,f)$ 之所以类型良好并为真，关键是子类型 $\Sigma g:\ G.\ \operatorname{fake}(G,g) \leq G$（由 $\Sigma$ 的第一投影作为强制子而得）。相关 Coq 代码见附录 A7.4，用以形式化验证 (3.118) 的正确性。

### Non-committal adjectives

**非承诺**形容词指那些本身不导出任何确定蕴含的形容词，如 (3.122) 所示。典型例子有 “alleged（所谓的）”“predicted（预测的）”“potential（潜在的）”“arguable（存疑的）”“disputed（有争议的）”“questionable（成问题的）”。以 “所谓的罪犯” 为例，它既可能真是罪犯，也可能不是。

\[
\operatorname{Adj}(\mathrm{N}) \Rightarrow\ ?
\tag{3.122}
\]

如何为这类形容词及其修饰赋义？以 “alleged（所谓的）” 为例：“所谓的凶手”可理解为“有人指称他/她是凶手”。我们据此提出：**被指控为凶手的人**就是“所谓的凶手”。

这一思路源自第一作者对 Ranta（1994）“信念语境（belief contexts）”的借用，用以刻画 *alleged* 的“他人所言/主张”。但正如 Chatzikyriakidis & Luo（2013, 2017a）指出，该思路存在问题[^23]。我们改采 Luo（2019a）的做法：以**模态集合算子（modal collection operators）**为基础，给出一套形式化方案，从而妥当地刻画非承诺形容词。

[^23]: Chatzikyriakidis 和 Luo（2013, 2017a）指出两点问题：其一，Ranta 的“信念语境”把**逻辑等价**的命题当作同一对象，这不适合刻画如“信念/主张”之类的模态概念，因此不宜直接用于非承诺形容词；其二，他们当时用 $B_h(\textit{Criminal})$ 表“$h$ 认为……是罪犯”，这在类型层面实际等价于“类型 $Criminal$ 非空”，也就是“存在罪犯”，几乎恒真，显然偏离了“某人被指称为罪犯”的本义。

考虑下列句子，并以模态算子表述：

\[
\text{John is an alleged murderer.}\\约翰被指控为一名涉嫌谋杀者。
\tag{3.123}
\]

\[
\text{Mary hates every alleged murderer.}\\玛丽讨厌所有被指控的谋杀犯。
\tag{3.124}
\]

我们形式化为：

\[
\exists h:\ Human.\ H_{h,\ \textit{alleged}}\!\big(\mathrm{\small IS}(Murderer,\ j)\big)
\tag{3.125}
\]

\[
\forall x:\ Human.\ \Big[\exists h:\ Human.\ H_{h,\ \textit{alleged}}\!\big(\mathrm{\small IS}(Murderer,\ x)\big)\Big]\ \Rightarrow\ hate(m,\ x)
\tag{3.126}
\]

其中，$H_{h,\ \textit{alleged}}(P)$ 直观读作“$h$ 声称/指控命题 $P$ 为真”；$\mathrm{\small IS}(Murderer,\ j)$ 是判断 $j: Murderer$ 的**命题形式**（见 §3.2.3 与 §7.1）。于是 (3.125) 表示“存在某个人 $h$ 指称 John 是凶手”；(3.126) 表示“对任意人 $x$，若存在某个 $h$ 指称 $x$ 是凶手，则 Mary 憎恨 $x$”。

把视野从 *alleged* 推广到一般非承诺形容词。对每个这类形容词（其语义行为由**人类主体**施加），引入相应的模态算子 $H_{h,\ Adj}$：例如 *disputed* 用 $H_{h,\ \textit{disputed}}(P)$ 表“$h$ 质疑/争议 $P$”。统一地，

\[
H_{h,\ Adj}:\ Prop \rightarrow Prop
\tag{3.127}
\]

可把 $H_{h,\ Adj}$ 看作“$h$ 给出的命题族/断言集”。在此框架中，“非承诺”体现在：修饰后的表达并不对 $N$ 或 $\neg N$ 作出承诺，而是将相关断言（指称、质疑、预测等）收集到相应的模态层里。我们认为，这一**模态集合算子**方案，能为非承诺形容词提供充分且可计算的语义解释。