# Formal Semantics in Modern Type Theories

本章研究现代类型理论中的正式语义（MTT-语义）。在第一章，尤其是1.4.1节，我们简要描述了如何在MTT-语义中解释一些基本的语言类别。现在，在上一章介绍了MTTs的一些基本结构后，我们处于更好的位置来研究MTT-语义的各种关键特性。我们将在以下几节中这样做：其中第一节，即3.1节，将继续1.4.1节的内容，详细解释如何解释一些基本的语言类别。

然后，在3.2节中，我们将阐述MTT语义学的几个与蒙塔古语义学不同的独特特点，从CNs-as-types范式开始（Ranta 1994; Luo 2012a）。一个常用名词（CN）例如"student"，可以解释为一个集合。在蒙塔古语义学中，用一个集合作为其解释来代表这个集合（例如，"student"被解释为表示学生的实体集合）[^1]，而在MTT语义学中，一个类型被用来表示其含义（例如，"student"解释为 $Student$ 类型，这个类型可以是一个基础类型，也可以是由其他类型定义的结构类型，这取决于当前的语义解释）。这个CNs-as-types（名词即类型）范式在3.2.1节中被介绍和详细阐述：它将该范式与CNs的辨识准则和集合/类型的建构概念联系起来，展示了MTTs的丰富类型结构在这个endeavor中发挥了关键的作用，并解释了这个范式相比传统的蒙塔古CNs-as-predicates（名词即谓词）范式有几个优点。

[^1]: 在蒙塔古语义学中，我们可以在中间语言 [intermediate language/IL] 或简单类型理论中使用类型为 $\mathbf{e} \rightarrow \mathbf{t}$ 的谓词，它进一步在集合论中解释为一个集合，这是蒙塔古语义学的含义承载语言。

在MTT语义学中采用CNs作为类型的范例，拥有一个充足的子类型机制变得至关重要。如Ranta（1994）所承认，这已经是基础语义解释所必需的，尽管他的解决方案不完整，因为没有提出适当的子类型机制。在第3.2.2节中，我们将讨论MTT语义学中的子类型，并展示强制子类型（Luo 1999；Luo等人2012），如在2.4节中简要介绍的，在MTT语义学中起着重要的作用。我们还将考虑强制子类型如何提供有用的手段来处理语义解释中更高级的语言特性，如意义转移[meaning transfers]（Nunberg 1995）和语言强制[lingusistic coercions]（Asher和Luo 2013）。[^2]

[^2]: 强制子类型化在其他语义构造中也发挥了有用的作用，包括例如在定义点类型以处理共指（参见第5章）以及在提出使用不相交联合类型对缺失形容词的修饰进行语义解释的建议中的应用（参见第3.3节）。

在3.3节中，以一个案例研究，我们将以传统分类法研究形容词修饰，展示各种形容词修饰如何在MTT语义学中建模。一方面，这显示了相当强大又丰富的类型结构，另一方面，说明了各种类型构造器如何在NL语义表示中应用。它还演示了如何在实践中应用CNs-as-types范式（此外，具体请参阅第4章和第5章）。

## Basic linguistic categories

在1.4.1节中，我们简要地提到了基础语言类别在MTT-语义学中是如何被解读的，如表3.1所示，这与表1.3相同（请参见表1.1，了解示例的蒙塔古式语义）。在此，我们将更详细地解释这些内容。

|                      | Example      | MTT-semantics                                                |
| -------------------- | ------------ | ------------------------------------------------------------ |
| $\text{CN}$          | man, human   | $Man, Human : Type$                                          |
| $\text{IV}$          | talk         | $talk : Human \rightarrow Prop$                              |
| $\text{ADJ}$         | handsome     | $handsome : Man \rightarrow Prop$                            |
| $\text{ADV}_{VP}$    | quickly      | $quickly : \Pi A:\mathsf{CN}. (A \rightarrow Prop) \rightarrow (Arop)$ |
| $\text{Quantifier}$  | some         | $some : \Pi A:\mathsf{CN}. (A \rightarrow Prop) \rightarrow Prop$ |
| $\text{Modified CN}$ | handsome man | $\Sigma m: Man. handsome (m) : Type$                         |
| $\text{S}$           | A man talks  | $\exist m: Man.talk (m) : Prop$                              |

> 表 3.1. Examples in MTT-semantics

在MTT-语义学中，常见名词解读为类型（详见3.2.1节），而动词和形容词解读为谓词，其作用域为动词或形容词可以有意义应用的对象。例如，正如表3.1的前三行所总结的，我们可以将“man”解释为一种类型（3.1），将“talk”解释为一种谓词（3.2），其作用域是人类，而将“帅气(handsome)”解释为一种谓词（3.3），其作用域是男人。

(3.1) $Man : Type$

(3.2) $talk : Human \rightarrow Prop$

(3.3) $handsome : Man \rightarrow Prop$

首先要注意的是，将CNs解读为类型而非谓词，其优势在于有效区分无意义和错误的表达。例如，在蒙塔古语义中，动词“talk”解释为谓词 $t a l k_{M}$ ，如（3.4）所示，其领域是所有实体的类型 $\mathbf{e}$（如表1.1）。考虑句子（3.5），在蒙塔古语义中被赋予了（3.6）的解释，在MTT语义中则被赋予了（3.7）的解释，其中  $table _{M}: \mathbf{e} \rightarrow \mathbf{t}$ 是一个谓词，而 $Table$ 是一个类型。

(3.4) $\operatorname{talk}_{M}: \mathbf{e} \rightarrow \mathbf{t}$

(3.5) $\text{(\#) A table talks.}$

(3.6) $(?) \exists x: \mathbf{e}. \operatorname{table}_{M}(x) \& \operatorname{talk}_{M}(x)$

(3.7) $(\#) \exists t: \operatorname{Table}. \operatorname{talk}(t)$

公式（3.6）是类型正确的，尽管在预期的模型中它是错误的，但这并不意味着（3.5）就毫无意义。另一方面， $talk (t)$ 的类型是错误的，因此公式（3.7）的类型也是错误的，这表明（3.5）是无意义的。我们认为，在这方面，MTT-语义学能更好地把握含义：通常情况下，句子（3.5）被视为无意义（除非在某些虚构的世界中），这正好被其在 MTT-语义学解释（3.7）中的类型错误所捕捉。这可以用稍微不同的方式来表述，即在 MTT-语义学中，选择性限制[selectional restriction]通过底层类型理论中的类型来捕捉：假设只有人类可以说话，$talk$ 不能应用于非人类的参数，如一张桌子 $t$，即在（3.7）中的 $talk(t)$ 的类型是错误的。注意，这是因为像 "$human$" 和 "$table$" 这样的名词短语解释为像 $Human$ 和 $Table$ 这样的类型，直观上是没有共同对象[common objects]的。[^3]

[^3]: 更正式地说，我们称人[Human]和桌子[Table]为不相交类型 - 请参阅第7.1节的定义7.1以了解类型不相交的定义。

另一个有趣的观察是，即使在如此简单的语义解释中，子类型化也已经发挥作用。例如，考虑例子（3.8）及其语义（3.9），如表3.1的最后一行所示。

(3.8) $\text{A man talks.}$

(3.9) $\exists m: \text{Man}. \text{talk}(m)$

有人会问：术语 $\operatorname{talk}(m)$ 及其公式（3.9）如何能被正确地类型化呢？$m$ 的类型是 $Man$ ，但 $talk$ 的定义域是 $Human$ ，而不是 $Man$ ！正如我们在2.4节简要讨论的，子类型在这里拯救了我们：$\operatorname{talk}(m)$ 是正确类型化的，因为 $Man$ 是 $Human$ 的子类型，因此 $m$ 可以视为一个能 $talk$ 的人类。另一种理解方式是，因为 $Man \leq H u m a n$ ，我们得出 $Human \rightarrow Prop \leq Man \rightarrow Prop$（通过逆变性[contravariance]），因此 $talk$ 的类型是 $Man \rightarrow Prop$ ，可以应用到 $m$ 上。在3.2.2节中，我们将更详细地讨论MTT语义中的子类型。

如第二章所示，MTT为语义构造提供了有用的工具。例如，在表3.1中，"快速[quickly]"和"一些[some]"分别示例了动词修饰副词和量词的解释。这两者都使用了解释 $\mathrm {CN}$ 的宇宙 $\mathsf{CN}$ 上的 $\Pi$ 多态性，如2.3.2节所解释的。例如，在蒙塔古语义中，我们可以给出修饰动词的副词的语义类型，如(3.10)所示：它接收一个类型为 $\mathbf{e} \rightarrow \mathbf{t}$ 的谓词，并返回同类型的谓词。

(3.10) $\text{quickly}_{M}:(\mathbf{e} \rightarrow \mathbf{t}) \rightarrow(\mathbf{e} \rightarrow \mathbf{t})$

在蒙塔古语义学中，每个谓词都具有相同的类型 $\mathbf{e} \rightarrow \mathbf{t}$ ，因为只有一个实体域 $\mathbf{e}$ 。MTT语义学与此不同，其中CN解释为类型；实体类型不止一种，还有许多类型，例如Man、Table等。那么，像"quickly"这样的修饰动词的副词的类型是什么呢？在这里，类型宇宙和与之相关的 $\Pi$ 多态性机制变得有用：例如，"quickly"可以被赋予多态类型（3.11），它在 $\mathrm{CN}$ 的宇宙 $\mathsf{CN}$ 中量化，当应用到任何 $\mathrm{CN}\ A$ 时，$quickly (A):(A \rightarrow Prop ) \rightarrow (A \rightarrow Prop )$ 。举例来说，假设 $run : Human \rightarrow Prop$ ，那么"run quickly"类型为 $Human \rightarrow Prop$ 的 $quickly(Human, run)$ 。

(3.11) $\text{quickly} : \Pi A:\mathsf{CN}. (A \rightarrow Prop ) \rightarrow(A \rightarrow Prop )$

同样，量词也可以通过在宇宙 $\mathsf{CN}$ 上的 $\Pi$ 多态性进行类型化。以一个简单的例子来说，量词"some"可能通过逻辑量词 $\exists$ 在(3.12)中定义，以 $\mathsf{CN}$ 作为其限定的域，其类型化为(3.13)，如表3.1所示，即与可以应用到任何类型的逻辑量词 $\exists$ 不同，"some"只能解释 $\mathrm{CN}$ 。

(3.12) $\text{some} =\lambda A: \mathsf{CN}\ \lambda P: A \rightarrow Prop. \exists(A, P)$

(3.13) $\text{some} : \Pi A : \mathsf{CN}. (A \rightarrow \operatorname{Prop}) \rightarrow \operatorname{Prop}$

例如，（3.14）可以理解为（3.15），其中 $speak : Human \rightarrow Prop$ 且 $Student \leq Human$ 。换句话说，一些可以应用到 $Student$ ，如（3.15）。然而，一些不能应用到不解释 $\mathrm{CN}$ 的类型：例如，类型 $Prop \rightarrow Student$ 不解释任何 $\mathrm{CN}$ ，因此，（3.16）是类型错误的，因为 $Prop \rightarrow Student$ 不在 $\mathsf{CN}$ 的领域内。

(3.14) $\text{Some students spoke.}$

(3.15) $some(Student, speak)$

(3.16) $(\#) some ( Prop \rightarrow Student, ...)$

$\Pi$ 多态性为我们提供了一种非常有用的表达工具，可以用来处理语义学研究中的各种语言现象。如果没有它，则很难看出如何在MTT语义中解读修饰动词的副词或量词。 $\Pi$ 多态性也用于其他语义结构中，包括例如次分形容词[subsective adjectives]如"大[large]"的构造（参见第3.3.2节）。

## Several unique features of MTT-semantics

在这个部分，我们将详细阐述MTT语义学中的CNs-as-types范例以及另外两个相关特性（子类型和断言性解释）。这些特性是MTT语义学独有的，与传统的蒙塔古语义学有所不同。[^4]

[^4]: MTT语义学的另一个独特特征是：它既是模型论的，也是证明论的，这一点在1.4.3节中已经详细解释过，因此在本章中不再详述。

### common nouns as types

当现代类型理论用于形式语义时，CNs解释为类型，而不是谓词。换句话说：MTT-语义学采用的是CNs-作为类型的范例，这与Montague语义学中的CNs-作为谓词的范例不同。例如，考虑CN "book"：在Montague语义学中，它解释为谓词 $\operatorname{book}_{M}: \mathbf{e} \rightarrow \mathbf{t}$ ，而在现代类型理论中，它为 $B o o k$ 类型。

这种将名词类别视为类型的观念与Geach（1962）观察到的名词类别具有特殊性的观点密切相关。直观地说，一个名词类别确定了一个概念，这个概念不仅有一个应用准则，用来确定该概念是否适用于一个对象，还有一个辨识准则，用来确定该概念的两个对象是否相同。有人争论说，名词类别在这方面具有独特性，因为其他的词汇项，如动词和形容词，似乎没有这样的辨识准则（参见Baker（2003）等人的论证）。

辨识[identity]准则的概念起源可以追溯到弗雷格（1884）考虑抽象的数学对象，如数字或线条时。例如，在几何学中，方向的辨识准则是线条的平行性：线条 $A$ 的方向等于线条 $B$ 的方向，当且仅当 $A$ 和 $B$ 是平行的。吉奇注意到，这样的辨识准则存在于每一个$\mathrm{CN}$中，并且是计数的基础。古普塔（1980）对此进行了系统的研究，并给出了一些非常有趣的例子。例如，考虑以下两句话：

(3.17) $\text{EasyJet has transported 1 million passengers in 2010.}$ （2010年，易捷航空运送了一百万乘客。）

(3.18) $\text{EasyJet has transported 1 million persons in 2010.}$ （2010年，易捷航空运送了一百万人次。）

很容易看出，句子（3.17）并不暗示（3.18），因为有些人可能在2010年乘坐EasyJet旅行了不止一次。有人争论说，这是因为“乘客”和“人”这两个概念名词有着不同的辨识准则，这些标准是进行计数的基础，导致了这种现象（Geach 1962; Gupta 1980; Baker 2003）。[^5]

[^5]: 针对辨识准则的观念，历来有人提出反驳。例如，古普塔（1980年）提到我们或许可以考虑一些本体论的论证，巴克（2008年）反驳，理由是语言现象可以更好地用语用学来解释。然而，我们依然坚信，辨识准则的概念提供了最佳解释。

辨识准则的概念和构造性的集合（类型）概念之间可以建立紧密的联系。在构造数学中，一个集合是一个"预设集"，它给出了其应用准则，同时还有一个等式，它给出了其辨识准则，用来确定集合中的两个对象是否相同（Bishop 1967；Beeson 1985）。一些现代类型理论，如Martin-Löf的类型理论（Martin-Löf 1975, 1984），最初是为了形式化构造数学而开发的，在这些理论中，每种类型都与这样的等式或辨识准则相关联。此外，值得注意的是，辨识准则的概念是对上下文敏感的。换句话说，名词类别的含义取决于其使用的上下文。例如，考虑"学生"这个词。在以下句子中，相关的辨识准则可能会有所不同，因为在（3.19）中，约翰可能教过几个班级，我们可能会合理地将在两个不同班级的学生计数两次，而在（3.20）中，我们会说在那种情况下"学生"与"人"有相同的辨识准则。

(3.19) $\text{John taught 500 students last year.}$ （去年，约翰教了500名学生。）

(3.20) $\text{1,000 students have applied for campus cards last year.}$ （去年有1,000名学生申请了校园卡。）

总的来说，一个CN应理解为一个集合等价类[setoid]，即一个类型和一个代表其相关辨识准则的等价关系的配对。CN与辨识准则相关并被形式解释为集合等价类的这一想法已在Luo(2012a)中被研究和发展。Chatzikyriakidis和Luo(2018)还指出，需要考虑不同辨识准则的更复杂情况相当罕见，在大多数现象中，相关CN的辨识准则基本相同，可以安全地忽略[^6]。换句话说，在大多数情况下，我们只需将CN视为类型，因此可以谈论他们在CN作为类型范例中的解释。

将CNs解释为类型只有在MTTs具有丰富的类型结构时才可行（而且，它们配备了适当的子类型概念 - 请参阅第3.2.2节关于子类型的内容）。例如，被交集形容词修饰的CNs可以通过 $\Sigma$ 类型来解释，如（3.21）所示（有关$\Sigma$类型，请参阅第2.2.2节）。

(3.21) $\text{handsome man} =\Sigma x :Man.handsome (x)$

注意，我们需要一种类型来代表“帅气男人”的语义 - 在（3.21）中，$\Sigma$类型起到了这个作用。我们是否有足够的类型构造器来解释各种语言合集？作为研究案例，在3.3节中，我们将考虑各种类别的形容词，并演示如何通过MTTs中的不同类型构造器来建模形容词的修饰：通过 $\Sigma$ 类型来实现交叉修饰[intersective modifications]，通过 $\Pi$ 多态性在宇宙 $\mathsf{CN}$ 上进行子集修饰[subsective modifications]，通过不相交联合类型进行负面修饰[privative modifications]，以及通过信念合集运算符[belief collection operator]进行非承诺性修饰[non-committal modifications]。这表明，MTTs具有足够且强大的类型构造器，用于表示可能由诸如CNs之类的语言实体引入的各种合集。换句话说，CNs-as-types范式在MTTs中是可行的，一般来说，MTTs通过强大的工具支持语义构造，如3.3节以及第4章和第5章所示。

[^6]: 涉及到共指和量化的复杂情况，请参阅第五章以获取详细讨论。

有人认为，与Montagovian的CNs作为谓词范式相比，CNs作为类型范式具有若干优点，例如，通过可判定类型化来更好地处理选择限制、在语义解释中兼容使用子类型，以及对共谓词等高级语言特性的满意处理[^7]。值得注意的是，有人发现将$\mathrm{CNs}$解释为类型有很多优点，一些研究者建议同时考虑这两种范式，例如，Retoré在这方面的想法 (Retoré 2013)。这种提议需要进一步的研究[^8]。在类型理论语义学中，一个相关问题是如何将断言性解释转变为相应的命题形式——请参阅第3.2.3节和第7.1节的讨论。

[^7]: 关于并列谓词及其通过开发点类型的 MTT 语义，详见第五章，以及 (Luo 2009c, 2012b; Chatzikyriakidis 和 Luo 2018) 中的进一步细节。
[^8]: 正如Chatzikyriakidis和Luo（2017b）所指出的，同时采用类型和谓词作为CNs的表示，需要假设它们按照预期的方式相关联：例如，CN "man"既可以被解释为类型$M a n$，也可以被解释为谓词$\operatorname{man}_{M}：\mathbf{e} \rightarrow \mathbf{t}$。然后，不清楚这两种解释如何以预期的方式关联，如所描述的$(*)$：「$(*)$ 对于任何 $x: \mathbf{e}$，当且仅当 $\operatorname{man}_{M}(x)$ 为真，那么 $x:Man$ 。」不幸的是，这样的要求 $(*)$ 似乎在不违反MTTs中类型检查的决定性等关键必要属性的情况下无法实现（或者合理地假设）。人们可能会使用现代类型理论作为基础的语义语言，但仍然采用CNs作为谓词范例（例如，在DTS中 - 参见第16页的脚注27）；但这意味着我们将失去上述CNs作为类型范例的优势，而根本不需要用MTTs的丰富类型结构 - 直接用像蒙塔古语义这种简单类型理论就行。

### Subtyping in MTT-semantics

如2.4节所介绍，强制子类型化（Luo 1997；Luo等人 2012）为MTTs提供了一个适当的子类型化机制。在本节中，我们展示了子类型化是MTT语义成为一个可行的语义框架的关键机制，另一方面，它提供了强大的机制来形式化各种语言强制转换（Luo 2009c；Luo和Callaghan 1998）。

**子类型化：对MTT语义学至关重要。**我们首先解释子类型化在基本语义解释中的重要性。例如，假设约翰是个男人，而《战争与和平》$(W \& P)$ 是一本沉重的书，如(3.22)和(3.23)所示。

(3.22) $j: Man$

(3.23) $W \& P : heavy\ book$ ，其中 $\text{heavy book} =\Sigma x :Book.heavy (x)$

那么，我们应该如何解读（3.24-3.26）中的句子呢？假设"read"解释为谓词 $read : Human \rightarrow Book \rightarrow Prop$ ，那么（3.24-3.26）将分别被解释为（3.27-3.29）。但显然，乍看之下（3.27-3.29）中的任何公式都不是类型良好的：$read$ 需要其第一个参数为 $Human$ 类型，第二个参数为 $Book$ 类型，因此，在（3.27）和（3.29）中，我们不能把 $read$ 应用于 $j: Man$ ，而在（3.28）中，我们不能把 $read(h)$ 应用于 $W \& P: \Sigma x: Book.heavy (x)$ 。

(3.24) $\text{John read a book.}$

(3.25) $\text{Somebody read "War and Peace".}$

(3.26) $\text{John read "War and Peace".}$

(3.27) $\exists b: B o o k . \operatorname{read}(j, b)$

(3.28) $\exists h: Human. \operatorname{read}(h, W \& P)$

(3.29) $\operatorname{read}(j, W \& P)$

子类型化将解决上述问题。对于上述示例，我们需要将子类型关系（3.30）和（3.31）纳入考虑，以使（3.27-3.29）类型正确。要理解这一点，只需注意子类型化通过像 $\Pi$ 和 $\Sigma$ 这样的类型构造器传播（在非依赖性情况下，还包括 $\rightarrow$ 和 $\times$）。例如，子类型化会逆变地[contravariantly]通过函数类型传播：如果 $A^{\prime} \leq A$ 和 $B \leq B^{\prime}$，那么 $A \rightarrow B \leq A^{\prime} \rightarrow B^{\prime}$。因此，我们有（3.32）这意味着 $read$ 可以应用于 $j: M a n$，而 $\operatorname{read}(h)$ 可以应用于 $W \& P: \Sigma x :Book.heavy (x)$ ，从而（3.27-3.29）语义是类型正确的。

(3.30) $Man \leq Human$  (Every man is a human.「男人都是人」)

(3.31) $\Sigma x :Book.heavy (x) \leq Book$  (Every heavy book is a book.「重书都是书」)

(3.32) $( Human \rightarrow Book \rightarrow Prop ) \leq( Man \rightarrow \Sigma x: Book.heavy (x) \rightarrow Prop )$

子类型关系（3.30）和（3.31）可以通过强制子类型化来表示。如果 $M a n$ 是一个常量类型，我们可以假设存在一个常量强制子 $m h$ 使得 $Man \leq_{m h} Human$。如果将其定义为通过 $Man =\Sigma x :Human.male (x)$ 的 $\Sigma$ 类型，则根据（3.33），$Man$ 是 $Human$ 的子类型：第一投影是从 $\Sigma x: A . P(x)$ 到 $A$ 的强制子[coercion]，对于每个类型 $A$ 和谓词 $P: A \rightarrow Prop$ 。

(3.33) $\Sigma x: A . P(x) \leq_{\pi_{1}} A$

同样，厚重的书也是书，这也是由于(3.33)，我们有 $heavy\ book=\Sigma x :Book.heavy (x) \leq Book$ 。子类型关系(3.30)和(3.31)被实现后，公式(3.27-3.29)类型正确且它们分别解释了(3.24-3.26)中的句子。注意，尽管在强制子类型[coercive subtyping]中可以使用投影子类型关系[projective subtyping relation]（如公式3.33所示），但在传统的包容子类型[subsumptive subtyping]中，这种关系是不可用的。

备注.— 由于CNs解释为类型（例如，一些修饰的CNs视为$\Sigma$类型），一个动词可能需要有多种不同的类型。例如，在上面，"read" 需要同时具有（3.32）中的两种类型，以便语义（3.27-3.29）可以被正确类型化。这对于MTT语义来说是一个非常基本的问题，解决它是必要的。这个问题被Ranta（1994）（第62-64页）认识到，其中它称为"动词的多重分类[multiple categorization of verbs]"问题，并考虑了三种可能的解决方案，但没有一种是满意的。有一个最接近我们，它明确地使用第一投影 $\pi_{1}$  - 但这离一个完整的解决方案还差一步。使用强制子类型化（例如，将 $\pi_{1}$ 作为隐式强制），我们设法找到了一个解决方案，能够捕捉到预期的现象。

**强制子类型化：语义构造中的强大工具。**除了在MTT语义中进行基本解释的必要工具外，强制子类型化还提供了各种语义构造的强大工具，包括例如对剥夺性形容词修改的解释（参见第3.3.3节）以及对涉及共指述词的句子进行解释的点类型的规定（参见下文和第5章）。在这里，我们给出两个例子，展示如何将强制子类型化用作语义构造的有用工具。

我们的第一个例子，如Luo (2011b)所提出的，关注的是同音异义词[homonymy]问题，我们展示了当同音异义词的含义可以通过类型进行区分时，其义项枚举[sense enumeration]可以用强制子类型表示，这使得自动消歧[automated disambiguation]如预期那样进行。我们知道，一个词可能有几个不相关的含义。例如，"run"这个词在句子(3.34)和(3.35)中使用时，其含义在(3.36)和(3.37)中各不相同。

(3.34) $\text{John runs quickly.}$ （约翰跑得快。）

(3.35) $\text{John runs a bank.}$ （约翰经营一家银行。）

(3.36) $run _{1} : Human \rightarrow Prop$

(3.37) $run _{2}: Human \rightarrow Institution \rightarrow Prop$

为了表示一种词义选择模型，我们需要一个机制，能在解读句子时自动选择正确的含义。例如，当解读(3.35)时，应自动选择(3.37)中的 $run_{2}$ 。对于简单的同音异义词，可以通过重载（或特定场景的多态性）（Strachey 2000）来进行这样的表示。直观地说，在上述例子中，"run" 这个词被重载[overloaded]，因为它关联了不止一种含义。重载可以通过强制子类型化（Luo 1999; Bailey 1999）来支持，如下文所述。

假设"w"是一个同音异义词 $w_{i}: A_{i}(i=$ $1, \ldots, n$ ) ，如果 $j \neq k$ 则 $A_{j} \neq A_{k}$。让 $\mathbf{1}_{w}$ 表示只有一个对象 $w: \mathbf{1}_{w}$ 的归纳单元类型[inductive unit type]（有关单元类型的形式细节，请参见附录A2.4）。然后，同音词"w"的含义可以表示为强制转换子 $c_{i}: \mathbf{1}_{w} \rightarrow A_{i} (i=1, \ldots, n)$ ，定义如下：
$$
c_{i}(w)=w_{i}: A_{i}
$$
<img src="3.Formal Semantics in Modern Type Theories.assets/image-20230608211339657.png" alt="image-20230608211339657" style="zoom:50%;" />

> 图 3.1. 使用强制子类型重载“ run”的语义

例如，单词 "run" 在 (3.36) 和 (3.37) 中分别具有两种含义，即 $run_{1}$ 和 $run_{2}$ 。这两种 "run" 的意义选择模型由以下两种强制性给出，即如图3.1所示：[^9]
$$
c_{1}(\text {run})=\operatorname{run}_{1}\ \text{和}\ c_{2}(\text {run})=\operatorname{run}_{2}
$$

[^9]: 如果考虑"run"的其他含义，相应地将定义更多的强制子。

例如，在任何需要 $Human \rightarrow Prop$ 类型的对象 $run$ 的语境 $\mathcal{C}_{1}[ run ]$ 中，我们有
$$
\mathcal{C}_{1}[run]=\mathcal{C}_{1}\left[c_{1}(r u n)\right]=\mathcal{C}_{1}\left[run_{1}\right]
$$
并且，在任何需要 $Human \rightarrow Institution \rightarrow Prop$ 的对象 $run$ 的上下文 $\mathcal{C}_{2}[run]$ 中，我们有
$$
\mathcal{C}_{2}[run]=\mathcal{C}_{2}\left[c_{2}(run)\right]=\mathcal{C}_{2}\left[ run _{2}\right]
$$
因此，通过自动插入强制性操作，句子(3.34)和(3.35)都将按照(3.39)和(3.40)正确解读，分别根据每个情况下的上下文类型要求选择预期的 $run_{i} (i=1,2)$ 。在(3.39)中，选择了 $run_{1}$ ，因为 $quickly (Human)$（其类型在(3.38)中给出）要求其参数 $run$ 为 $Human \rightarrow Prop$ 类型的函数。在(3.40)中，选择了 $run_{2}$ ，因为 $run$ 需要一个 $Human \rightarrow Institution \rightarrow Prop$ 类型的函数。

(3.38) $quickly ( Human ):( Human \rightarrow Prop ) \rightarrow( Human \rightarrow Prop )$

因此，我们有(3.39)和(3.40)中的等式，它们根据强制子类型的强制定义规则而成立。

(3.39) $[[\text{John runs quickly}]]=q u i c k l y( run, j)= quickly (run_1, j)$

(3.40) $[[\text{John runs a bank} ]]=\exists b: Bank . run(j, b)=\exists b: Bank. run_{2}(j, b)$

我们使用了Coq证明助手(Coq 2010)来试验上述的感知选择模型[sense selection model]（Luo 2011b）：以上述的简单示例（3.39）和（3.40）为例，Coq代码可以在附录A7.2中找到。

注释：对于某些多义词，其不同的含义可能具有相同的类型，因此无法通过归类来区分。例如，当名词视为类型时，同音名词（例如"bank"）的消歧可能需要更多的语言信息（例如，在"bank"的情况下，它可能指的是一些金融事务）。为了做到这一点，我们可能需要借助部强制子[local coercions]以给出形式解释（有关更多信息，请参见罗（2011b））。

我们下一个例子取自Asher和Luo（2013），涉及到语言学上讨论的语言强制性，包括Pustejovsky（1995）等人在内的语言学文献中有详尽的讨论。它演示了强制子类型能有效应用于表示语言强制性，并且，有时候，依赖类型，如在以下例子中使用的参数化强制[parameterized coercions]，可以在表示复杂情况时发挥非常有帮助的作用。此外，我们将使用Davidson（1967）提出的事件语义框架[event semantics]，而在这些例子中，我们也将使用如Luo和Soloviev（2017）及第7.2节中研究的精细化事件类型[refined event types]，称为依赖事件类型，例如 $E v t_{A}(h)$ 。

请考虑以下涉及到"开始[start]"、"起始[begin]"和"结束[finish]"等时态动词，以及像"享受[enjoy]"这样的英文动词的例子：直观上，(3.41)与(3.42)在意义上是等价的，这说明"享受"需要一个事件作为其直接宾语。从语义上，我们将“享受”的定义为 $enjoy：Human \rightarrow Event \rightarrow Prop$ ，其中 $Event$ 是所有事件的类型，(3.43)的MTT语义解释应为(3.44)。

(3.41) $\text{Julie enjoyed (started/finished) a book.}$ （朱莉喜欢（开始/结束）一本书。）

(3.42) $\text{Julie enjoyed doing something with (e.g. reading, writing, ...) a book.}$ （朱莉喜欢做一些与书有关的事情（例如阅读、写作等）。）

(3.43) $\text{Julie enjoyed a book.}$ （朱莉喜欢一本书。）

(3.44) $\exists x: Book.enjoy(j, x)$

然而，$enjoy(j)$ 的领域类型是 $Event$ ，这与 $x$ 的类型 $Book$ 不同——那么在（3.44）中的 $enjoy (j, x)$ 如何能被正确地类型化呢？答案是，在强制子类型化的框架中，特别是在（3.45）中的子类型关系下，它声明 $reading : Book \rightarrow Event$ 作为一个强制转换，$enjoy (j, x)$ 被强制转换成（并且，从形式上讲，等同于） $enjoy (j, \operatorname{reading}(x))$ ，从而得到了正确的类型化。非正式地说，句子（3.43）被强制转换成（3.46），其语义（3.47）从形式上等同于（3.44）。

(3.45) $Book \leq_{\text {reading }} Event $

(3.46) $\text{Julie enjoyed reading a book.}$ （朱莉喜欢读书。）

(3.47) $\exists x: Book. enjoy (j, reading (x))$

注意，在以上内容中，我们只考虑了一种可能的强制子（3.45）：从“enjoy a book”到“enjoy reading a book”。然而，可能存在多种强制子：例如，（3.43）可能意味着“Julie enjoyed writing a book”，这些多重强制子可能具有不同的范围，甚至可能交织或重叠，如（3.48）所示，阅读和写作的强制范围交错重叠。

(3.48) $\text{Julie just started War and Peace,}\\ \text{which Tolstoy finished after many years of hard work.}\\ \text{But that will not last because she never gets through long novels.}$ 
（朱莉刚开始读《战争与和平》，这是托尔斯泰经过多年辛勤努力才完成的作品。但这种状况不会持久，因为她从未读完过长篇小说。）

在这样的情况下，依赖类型证明非常有用，实际上，它在Asher和Luo（2013）的研究中首次在文献中被用于形式化语言强制子。现在我们将使用Luo和Soloviev（2017）以及第7.2节研究的依赖事件类型的符号表示。我们不再考虑所有事件的单一类型 $Event$ ，而是考虑由各种“主题角色[thematic roles]”如动作者和受事者索引的精细事件类型[^10]。例如，对于上述在（3.48）的句子，我们可能考虑由动作者 $a$ 索引的系列事件类型 $\operatorname{Evt}_{A}(a)$，其中 $a$ 的类型是动作者。人类是动作者：$Human \leq Agent$ ，对于任何 $h: Human$ ，${E v t_{A}}(h)$ 是由 $h$ 进行的事件的类型。现在，我们可以假设在（3.48）的动词有以下类型：
$$
\begin{aligned}
& \text {start, finish, last}:\Pi h:Human.\left(\operatorname{Evt}_{A}(h) \rightarrow\right. \text { Prop) } \\
& \text { read, write : } \Pi h: Human. \left(\text { Book } \rightarrow \operatorname{Evt}_{A}(h)\right)
\end{aligned}
$$

[^10]: 在语言学中，主题角色，也被称为主题关系，是指名词短语在与句子主要动词描述的行为或状态相关的各种角色。例如，在句子 "苏珊吃了一个苹果"中，"苏珊"是吃的行动者，因此她是一个施事者；苹果是被吃的物品，因此它是受事者。

此外，请考虑在(3.49)中的强制操作[^11]，其中强制操作$c(h)$是从Book到$E v t_{A}(h)$的函数，在(3.50)中为 $b: B o o k$ 定义。我们简化了第二种情况，假设如果他/她没有写这本书，我们会阅读这本书（我们可以考虑其他行动来考虑更多的子情况）。

(3.49) $Book \leq_{c(h)} \operatorname{Evt}_{A}(h)$ 其中 $h: Human$

(3.50) $c(h, b)= \begin{cases}\text {write}(h, b) & \text {if } h \text { wrote } b, \\ \operatorname{read}(h, b) & \text {otherwise.}\end{cases}$

[^11]: 这是一种由$h: Human$参数化强制[parameterized coercion]操作。据我们所知，Asher和Luo（2013）在语言例子中首次使用参数化强制操作的例子就在这里。

有了以上内容，我们现在可以将（3.48）解释为（3.51）（简化形式），其中 $j$ 和 $t$ 分别解释 "Julie" 和 "Tolstoy"，而 $\Sigma b: Book.long (b)$ 是解释"长篇书[long book]"的 $\Sigma$-类型。在强制子类型中，（3.51）被强制转换并等同于（3.52），它在插入（3.49）中指定的强制转换后，变成了（3.53）。

(3.51) 
$$
\begin{align}
&\ \ \operatorname{start}(j, W \& P)\\
&\wedge \operatorname{finish}(t, W \& P)\\
&\wedge \neg \operatorname{last}(j, W \& P)\\
&\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, \pi_{1}(l b)\right)
\end{align}
$$
(3.52) 
$$
\begin{align}
&\ \ \operatorname{start}(j, c(j, W \& P))\\
&\wedge \operatorname{finish}(t, c(t, W \& P))\\
&\wedge \neg \operatorname{last}(j, c(j, W \& P))\\
&\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, c\left(j, \pi_{1}(l b)\right)\right)
\end{align}
$$
(3.53) 
$$
\begin{align}
&\ \ \operatorname{start}(j, \operatorname{read}(j, W \& P))\\
&\wedge \operatorname{finish}(t, \operatorname{write} (t, W \& P))\\
&\wedge \neg \operatorname{last}(j, \operatorname{read}(j, W \& P))\\
&\wedge \forall l b:(\Sigma b: Book.long (b)) . \neg \operatorname{finish}\left(j, c\left(j, \pi_{1}(l b)\right)\right)
\end{align}
$$
为了更详细地解释，我们有关于 $start$（每个上述公式的第一行）的以下等式：
$$
\operatorname{start}(j, W \& P)=\operatorname{start}(j, c(j, W \& P))=\operatorname{start}(j, \operatorname{read}(j, W \& P))
$$
第一个等式成立是因为 $\operatorname{start}(j): \operatorname{Evt}_{A}(j) \rightarrow \operatorname{Prop}$ 和 $W \& P: B o o k \leq_{c(j)} Evt_{A}(j)$，而第二个等式则根据 $c(j)$ 的定义。对于 $finish$ 和 $last$ 来说也是类似的。

如果仔细阅读，(3.53)就是(3.48)的预期语义。注意，在(3.53)的最后一个连词中，强制子 $c$ 仍然存在， $c\left(j, \pi_{1}(l b)\right)$ 无法进一步简化，因为 $l b$ 是一个变量。