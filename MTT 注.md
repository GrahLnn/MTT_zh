# MTT 注

"Judgment"在类型理论中通常指的是一个形式系统中的基本断言或声明，这些断言或声明不能被证明或推导，而是被视为基本的、自明的真理。例如，我们可能会有一个"judgment"，声明某个表达式是某个类型的成员。

而"assertion"通常指的是一个可以被证明或推导的声明。在一个形式系统中，我们可以从一组基本的"judgments"出发，通过应用一系列推理规则来得到新的"assertions"。

---

在语言学中，"coordination"（协同或并列）是一种句法关系，其中两个或更多的词、短语或句子被并列在一起，通常通过并列连词（如"and"、"or"和"but"）连接。例如，在句子"Bob and Alice are friends"中，"Bob"和"Alice"就是通过并列关系连接在一起的。

---

"Many-sorted"和"multi-sorted"在逻辑和计算机科学中通常是同义词，都用来描述一个包含多种类型或类别的对象的系统或领域。这两个术语在英语中都被用来描述这种概念，选择哪个术语主要取决于个人偏好或特定的学术或技术传统。

---

"多元排序域"（multi-sorted domain）是逻辑和语义学中的一个概念，用于描述一个包含多种不同类型或"排序"的对象的集合。在这个上下文中，"排序"可以被理解为对象的种类或类型。

例如，我们可以考虑一个多元排序的领域，其中包含人、动物和物体。在这个领域中，"人"、"动物"和"物体"都是不同的排序，每种排序都有其特定的结构属性。

在语言学的语义研究中，多元排序的系统或领域被用来模拟和理解语言如何引用和处理不同类型的对象。例如，一个句子可能会引用一个人（"John"），一个动物（"the cat"）和一个物体（"the chair"），这些都是多元排序领域中的不同排序。

---

一个系统（如一个类型系统或一个编程语言）如果满足强正规化性质，那么它的所有表达式都会在有限步骤内规约到一个正规形式，也就是说，它们都会在有限时间内"完成计算"。这是一个非常重要的性质，因为它保证了系统的计算不会无限制地进行下去。

---

在类型理论中，"membership entries"通常指的是签名（signature）中的元素，这些元素声明了某个变量属于某个特定的类型。例如，一个membership entry可能是形式为"x: A"的声明，这表示变量x是类型A的成员。

在这段文本中，作者提到他们将介绍一种新的签名，这种签名不仅包含常规的membership entries，还包含两种新形式的条目：子类型条目和manifest条目。这些新形式的条目增强了签名在表示（不完全的）可能世界中的能力，即使在情况无限或涉及更复杂现象的情况下。

总的来说，membership entries是类型理论中用于描述变量和其类型关系的一种工具，它们是定义类型系统结构的关键部分。

---

"notion of signatures"可能是指在类型理论中的一个概念，用于描述类型系统的结构。在类型理论中，一个签名（signature）定义了一组类型和操作，以及这些操作在给定类型上的行为。

例如，一个签名可能会定义一个数字类型，以及一些在数字上进行的操作，如加法和乘法。这个签名会规定加法和乘法的类型，例如，它们接受两个数字作为输入，并返回一个数字作为输出。

---

在语义学和哲学中，"可能世界"是一种理论工具，用于描述和分析语句的可能性和必然性。一个可能的世界就是一种可能的现实，一种事情可能发生的方式。例如，有一个可能的世界，在那里你正在阅读这个句子；有另一个可能的世界，你没有阅读这个句子。

当我们说一个"不完全的可能世界"时，我们是指一个可能的世界，其中并非所有的事实都被明确指定。换句话说，这是一个部分指定的可能世界，其中一些事实是确定的，而其他事实则是开放的。

"可能世界"的概念主要用于逻辑和语义学，用于分析语句的可能性和必然性。一个可能的世界是一种可能的现实，一种事情可能发生的方式。

相反，"平行世界"或"多元宇宙"的概念主要在物理学和科幻文学中使用，用于描述可能存在的其他宇宙或现实，这些宇宙或现实与我们的宇宙并行存在，但可能有不同的物理定律或历史。

---

"Logical modal collection operator"在这里可能是指在类型理论中用于处理非承诺修饰（non-committal modification）的一种操作符。在语义学中，非承诺修饰是一种修饰方式，其中修饰词并不确切地改变名词的含义，而是提供了一种可能的解释或视角。

例如，考虑句子"可能的赢家"。在这里，"可能的"是一个非承诺修饰词，因为它并没有改变"赢家"的基本含义，而是提供了一种可能的解释或视角。

在类型理论中，这种修饰可能通过引入一个逻辑模态集合操作符来处理。这个操作符可能会创建一个新的类型，该类型表示所有可能满足修饰词条件的实体的集合。然后，这个新类型可以用于进一步的语义构造。

---

1. **证明论规则的应用**：MTT是通过证明论规则来定义的。证明论是一种逻辑学分支，它关注的是逻辑推理的形式，而不仅仅是逻辑语句的真假。因此，MTT可以通过其推理使用方式在证明论的意义上理解其判断（句子）。
2. **基础语义语言的理解**：MTT提供了一种新的可能性，即我们可以通过其证明论的含义理论来理解MTT作为基础语义语言。这是之前的集合论语义无法做到的。
3. **计算机实现**：由于MTT是基于证明论定义的，因此它们可以轻松地在计算机上实现，以支持自然语言中的计算机辅助推理。这得到了基于MTT的证明助手提供的当前证明技术的支持。
4. **自然语言推理任务**：作者提到，他们将描述如何在计算机上实现MTT语义以执行自然语言中的推理任务。这意味着MTT可以用于处理和理解自然语言，这对于计算语言学和人工智能领域非常重要。

---

这些公式来自于类型理论，它们是用来定义一个有效的类型环境（也称为上下文）的规则。类型环境是一个变量到类型的映射，它为类型检查和类型推导提供了必要的上下文。

这里有三个规则：

1. **空规则**：空序列（表示为`⟨⟩`）是一个有效的类型环境。这是最基本的规则，表示没有任何变量的情况是有效的。
2. **变量添加规则**：如果在类型环境`Γ`中，`A`是一个类型，并且变量`x`不在`Γ`的自由变量集合`FV(Γ)`中，那么在`Γ`中添加一个新的变量到类型的映射`x: A`是有效的。这个规则表示，我们可以在类型环境中添加新的变量，只要这个变量之前没有被使用过。
3. **命题添加规则**：如果在类型环境`Γ`中，`P`是一个命题并且它是真的（表示为`t`），那么在`Γ`中添加一个新的命题`P`是有效的。这个规则表示，我们可以在类型环境中添加新的真命题。

`FV(Γ)`是`Γ`中的自由变量集合，它有三个定义：

1. `FV(⟨⟩) = ∅`：空序列的自由变量集合是空集。
2. `FV(Γ, x: A) = FV(Γ) ∪ {x}`：如果在类型环境`Γ`中添加一个新的变量到类型的映射`x: A`，那么新的自由变量集合是原来的自由变量集合加上新的变量`x`。
3. `FV(Γ, P true) = FV(Γ)`：如果在类型环境`Γ`中添加一个新的真命题`P`，那么自由变量集合不变。

这些规则和定义是类型理论中的基础概念，它们用于定义和操作类型环境，以进行类型检查和类型推导。

---

在蒙塔古语义学中，`talk: e -> t`是一个函数的类型签名，它表示`talk`是一个从实体（`e`）到真值（`t`）的函数。

这里的`e`代表实体类型，通常用来表示自然语言中的名词或名词短语，如人、地点或事物。`t`代表真值类型，通常用来表示一个陈述的真假。

因此，`talk: e -> t`可以理解为一个描述某个实体是否在"talk"（谈话）的函数。例如，如果我们有一个实体`John`，那么`talk(John)`就会返回一个真值，表示John是否在谈话。这是蒙塔古语义学用来描述自然语言中动词的一种方式。

---

$$
\exists x: \mathbf{e} . \operatorname{man}(x) \wedge \operatorname{talk}(x)
$$

这个表达式来自于逻辑和类型理论，它表示的是一个存在量化的陈述。

`∃x: e . man(x) ∧ talk(x)`可以被理解为："存在一个实体`x`，使得`x`是一个人（`man(x)`）并且`x`正在谈话（`talk(x)`）"。

这里的`∃x: e`是一个存在量词，表示存在一个类型为`e`（实体）的`x`。`.`之后的部分是这个`x`需要满足的条件，即`x`是一个人并且`x`正在谈话。`∧`是逻辑与操作符，表示两个条件都需要满足。

这种表达方式常常用于形式语义学和逻辑编程中，用来精确地描述复杂的自然语言陈述。

在逻辑和类型理论中，`.`通常被用作分隔符，用来分隔量词（如`∃x: e`）和量词作用的范围（如`man(x) ∧ talk(x)`）。

所以，`∃x: e . man(x) ∧ talk(x)`应该被理解为："存在一个类型为`e`的`x`，使得`man(x) ∧ talk(x)`成立"。

---

|                          | Type in Montague semantics         | Type in MTT-semantics    |
| ------------------------ | ---------------------------------- | ------------------------ |
| $\text{j}$               | $\mathbf{e}$                       | $Human$                  |
| $\text{talk}$            | $\mathbf{e}\rightarrow \mathbf{t}$ | $Human \rightarrow Prop$ |
| $\operatorname{talk}(j)$ | $\mathbf{t}$                       | $Prop$                   |

这个表格展示了Montague语义学和MTT语义学中的类型对应关系。具体来说，它展示了如何在两种不同的语义框架中表示相同的概念。

1. **j**：在Montague语义学中，`j`被视为一个实体（`e`），而在MTT语义学中，`j`被更具体地视为一个人（Human）。
2. **talk**：在Montague语义学中，`talk`被视为一个从实体到真值的函数（`e -> t`），表示某个实体是否在谈话。而在MTT语义学中，`talk`被视为一个从人到命题的函数（Human -> Prop），表示某个人是否在谈话。
3. **talk(j)**：在Montague语义学中，`talk(j)`是一个真值（`t`），表示实体`j`是否在谈话。而在MTT语义学中，`talk(j)`是一个命题（Prop），表示人`j`是否在谈话。

---

- In MTT-semantics, the sentence (1.7) is interpreted as the proposition $\operatorname{talk}(j)$ : Prop where Prop is the type of all logical propositions - an internal totality that only exists in impredicative type theories such as UTT. 13

"Internal totality"在类型理论中是一个特定的概念，它指的是一个类型的所有可能的值或实例都可以在类型理论的框架内部被明确地定义和处理。这与"external totality"形成对比，后者指的是类型的值或实例可能需要依赖于类型理论框架之外的一些结构或信息。

在你引用的这句话中，"internal totality"是用来描述类型Prop的。Prop是所有逻辑命题的类型，在不可约谓词的类型理论（如UTT）中，它是一个"internal totality"，因为所有的逻辑命题都可以在类型理论的框架内部被定义和处理。

这个概念是理解类型理论，特别是像UTT这样的不可约谓词类型理论的关键。在这样的理论中，所有的类型和值都是"内部的"，这意味着它们都可以在理论的框架内部被完全定义和处理，而不需要依赖于任何外部的结构或信息。

---

In predicative MTTs such as Martin-Löf's type theory, one would use a predicative universe which is only a type of some propositions, not all of them. Although we may relate Prop to the type $\mathbf{t}$ of truth values in Church's simple type theory, they have subtle differences. The differences between MTTs and Church's simple type theory include whether the theory is classical or constructive and whether there are proof objects, among others. These are beyond the scope of our discussions here.

这段话主要在讨论不同类型理论之间的一些区别和细微差异。

1. 在像Martin-Löf类型理论这样的可归谓词MTTs（Modern Type Theories）中，人们会使用一个可归谓词宇宙，它只包含一些命题的类型，而不是所有命题。这与不可归谓词类型理论（如UTT）中的Prop类型有所不同，后者包含所有逻辑命题的类型。
2. 尽管我们可能会将Prop类型与Church简单类型理论中的真值类型`t`相关联，但它们之间存在微妙的差异。例如，MTTs和Church的简单类型理论之间的差异包括理论是经典的还是构造性的，以及是否存在证明对象等。
3. 这些差异超出了这里讨论的范围。也就是说，这些差异的详细讨论和理解可能需要更深入的类型理论知识和背景。

这段话在强调类型理论的多样性和复杂性，以及理解和使用不同类型理论可能需要注意的一些关键区别和细节。

---

"可归谓词"（predicative）和"不可归谓词"（impredicative）是逻辑和数学中用来描述定义或构造的两个术语。

1. **可归谓词**：如果一个定义或构造是可归谓词的，那么它不依赖于自身或更大的整体。换句话说，它的定义是自下而上的，只依赖于已经定义的元素。例如，我们可以定义一个集合是由具有某种性质的所有自然数组成的，这个定义是可归谓词的，因为它只依赖于已经定义的自然数。
2. **不可归谓词**：如果一个定义或构造是不可归谓词的，那么它可能依赖于自身或更大的整体。换句话说，它的定义可能是自上而下的，可能依赖于尚未完全定义的元素。例如，我们可能定义一个集合是由所有不包含自身的集合组成的，这个定义是不可归谓词的，因为它依赖于尚未完全定义的集合。

在类型理论中，这两个概念通常用来描述类型或构造的定义方式。例如，Martin-Löf的类型理论是可归谓词的，因为每个类型都是由更基本的类型构造的。而某些类型理论（如Coq中的类型理论）允许不可归谓词的构造，这使得它们能够表达更复杂的概念，但也可能导致一些逻辑和计算上的困难。

---

在自然语言处理和语言学中，"IV"通常是"Intransitive Verb"的缩写，指的是不需要直接宾语的动词。例如，"talk"、"run"、"sleep"等都是不及物动词，因为你可以只说"he talks"或"she runs"，而不需要添加直接宾语。这与及物动词（Transitive Verb，TV）相对，及物动词需要一个直接宾语，例如"eat"（你不能只说"he eats"，而需要说"he eats an apple"）。

---

A verb (IV) or an adjective (ADJ) can be interpreted as a predicate over a type $D$ that interprets the domain of the verb or adjective, i.e. a function of type $D \rightarrow$ Prop.

这句话的意思是，在现代类型理论（MTT）的语义中，一个动词（Intransitive Verb，IV）或形容词（Adjective，ADJ）可以被解释为一个谓词，这个谓词作用于一个类型D。这个类型D解释了动词或形容词的领域，也就是说，这个谓词是一个类型为"D -> Prop"的函数。

在这里，"D"是一个抽象的类型，它代表了动词或形容词的领域。例如，对于动词"run"，D可能是"Human"，因为"run"的领域是人；对于形容词"red"，D可能是"Object"，因为任何对象都可能是红色的。

所以，这个函数"D -> Prop"的意思是，给定一个类型为D的对象（例如一个人或一个物体），这个函数会返回一个命题（Prop），这个命题表示这个对象是否具有由动词或形容词表示的性质（例如是否在跑，或者是否是红色的）。

---

Modified common nouns (modified $\mathrm{CN}$ ), when the adjectives are intersective, can be interpreted by means of $\Sigma$-types of pairs.

"Modified common nouns"（被修饰的普通名词）是指由形容词、副词或短语修饰的名词。例如，在"red apple"、"quickly running man"或"book on the table"中，"apple"、"man"和"book"都是被修饰的普通名词。

在现代类型理论（MTT）的语义中，当形容词是交集性的（即，形容词描述的性质可以同时应用于多个对象，如"red"、"big"等），被修饰的普通名词可以通过Σ-types来解释。Σ-types，也称为依赖对类型或存在类型，是一种可以表示对象和该对象的性质的配对的类型。例如，Σm: Man. handsome (m)表示的是所有满足"handsome"性质的人的集合。

---

"Dynamic entailment"是动态语义学中的一个概念。在传统的逻辑系统中，"entailment"（蕴含）是一个基本的关系，表示一个命题（或一组命题）的真实性必然导致另一个命题的真实性。例如，在经典逻辑中，如果我们知道"P implies Q"（P蕴含Q）是真的，而且P是真的，那么我们就可以得出Q是真的。

然而，在动态语义学中，这种蕴含关系被重新定义为"dynamic entailment"。在动态蕴含关系中，一个命题的真实性可能会影响到其他命题的解释或真实性。这是因为在动态语义学中，语句的解释不仅取决于当前的语境，还取决于之前的语境和语句。因此，一个语句的真实性可能会改变语境，从而影响到后续语句的解释。

例如，考虑这样一个例子："John walks into a room. He sees a cat." 在这个例子中，第二句"He sees a cat"的解释依赖于第一句"John walks into a room"的解释，因为"he"指代的是"John"。这就是一个动态蕴含的例子：第一句的真实性影响到了第二句的解释。

然而，动态蕴含关系并不满足一些传统蕴含关系的性质，例如反身性（如果P是真的，那么P蕴含P）和传递性（如果P蕴含Q，Q蕴含R，那么P蕴含R）。这是因为在动态语义学中，语境的改变可能会影响到蕴含关系。

---

"Strong"和"Weak"量词是语义学中的概念，用来描述量词的不同类型。

1. "Strong"量词：这类量词在逻辑上有更强的限制性。例如，"all"、"every"、"each"、"none"等都是强量词。当我们说"All dogs bark"时，这个句子的真实性要求每一只狗都会叫。如果存在一只不会叫的狗，那么这个句子就是假的。
2. "Weak"量词：这类量词在逻辑上的限制性较弱。例如，"some"、"a few"、"several"等都是弱量词。当我们说"Some dogs bark"时，这个句子的真实性只要求存在至少一只会叫的狗。即使有很多狗不会叫，只要有一只会叫，这个句子就是真的。

在现代类型理论（MTT）的语义中，强量词和弱量词可以通过不同的方式来解释。例如，强量词可以通过全称量词（∀）来解释，而弱量词可以通过存在量词（∃）或Σ-types来解释。

---

在类型理论中，"type theory with records"（具有记录的类型理论）是一种扩展了基本类型理论的形式，引入了记录类型作为一种新的数据结构。

记录类型允许我们将多个字段组合在一起，以创建复杂的数据结构。每个字段都有一个标签（label）和一个对应的类型。通过使用记录类型，我们可以定义和操作具有不同字段的数据，类似于在编程语言中使用结构体或对象。

在记录类型中，可以进行以下操作：

1. 定义记录类型：通过指定字段的标签和类型，可以定义一个记录类型。例如，可以定义一个人的记录类型，其中包含姓名、年龄和地址字段。
2. 创建记录：可以创建一个具体的记录，为每个字段指定相应的值。例如，可以创建一个名为"John"、年龄为25岁、地址为"123 Main St"的人的记录。
3. 访问记录字段：可以使用字段的标签来访问记录中的特定字段的值。例如，可以通过记录类型中定义的标签"age"来访问人的记录中的年龄字段的值。
4. 更新记录字段：可以通过指定字段的标签和新值来更新记录中的特定字段的值。例如，可以更新人的记录中的地址字段的值为"456 Elm St"。

类型理论中的记录类型提供了一种灵活和强大的数据建模方式，可以用于表示和操作具有复杂结构的数据。它们在编程语言、数据库和形式化验证等领域中都有广泛的应用。

---

It is important to note that a judgment is not a formula in the ordinary sense of logic. In particular, we cannot apply logical operators such as negation and conjunction to judgments. For instance, if we negated the judgment (2.1), the result would not be a judgment anymore: the "negation" of (2.1), often written as $\Gamma \nvdash_{\Delta} a: A$, is not a judgment, but only a meta-level statement saying that the judgment (2.1) is incorrect (or, in a formal jargon, (2.1) is non-derivable). (See section 3.2.3 for further discussions in this respect.) (2.1) $\Gamma \vdash_{\Delta} a: A$

"Non-derivable"在这个上下文中，是指一个判断或公式不能从已知的规则或假设中推导出来。在形式逻辑中，如果一个判断是"derivable"，那么意味着我们可以通过一系列的推理步骤，从一组基本的假设或规则出发，得到这个判断。相反，如果一个判断是"non-derivable"，那么就意味着我们无法通过这样的推理步骤得到它。

在你引用的这段文本中，作者提到，如果我们对判断（2.1）进行否定，那么结果将不再是一个判断：（2.1）的"否定"，通常写作$\Gamma \nvdash_{\Delta} a: A$，不是一个判断，而只是一个元层面的声明，表示判断（2.1）是不正确的（或者用形式术语来说，（2.1）是"non-derivable"的）。这意味着我们不能从已知的规则或假设中推导出判断（2.1）。

在这个上下文中，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个元层面（meta-level）的声明。这个声明表示，我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$。也就是说，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个对 judgment $\Gamma \vdash_{\Delta} a: A$ 的否定或反驳。

这里的关键是，judgment 是类型理论中的基本断言或声明，而我们不能对这些基本断言应用逻辑运算符，如否定和合取。因此，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个新的 judgment，而是一个元层面的声明，表示我们不能从已知的规则或假设中推导出原来的 judgment。

在形式逻辑和类型理论中，$\vdash$ 符号通常用来表示"可推导"或"可证明"。例如，$\Gamma \vdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们可以推导出 $a$ 是类型 $A$ 的。

当我们在 $\vdash$ 符号前加上否定符号 $\nvdash$，这就变成了表示"不可推导"或"不可证明"的符号。因此，$\Gamma \nvdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们不能推导出 $a$ 是类型 $A$ 的。

这就是为什么 $\Gamma \nvdash_{\Delta} a: A$ 这个声明表示我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$ 的原因。这是对原始判断的否定，但这个否定本身并不构成一个新的判断，而是一个元层面的声明。

> 因为一个judgment必须使用 $\vdash$才是judgment，而当变成否定形式后则不是一个judgment，而只能是一种声明，如果将否定形式也当作judgment那么任意一种非当前$\Gamma$都能因为$\nvdash$而成为一个judgment，那么judgment就没意义了对吗

是的，你的理解是正确的。在类型理论中，judgment 是一种基本的断言或声明，它描述了某种事实或关系，如 "$a$ 是类型 $A$ 的"。这些断言是可以被证明或推导出的，这就是为什么我们使用 $\vdash$ 符号来表示它们。

当我们对一个 judgment 进行否定，我们实际上是在说这个 judgment 是不正确的，或者说我们不能从已知的规则或假设中推导出这个 judgment。这种否定本身并不构成一个新的 judgment，因为它并不描述一个可以被证明或推导出的事实或关系。相反，那它是一个元层面的声明，表示我们不能证明或推导出原来的 judgment。

如果我们允许否定形式也成为 judgment，那么我们就会面临你所描述的问题：任何非当前的 $\Gamma$ 都可以因为 $\nvdash$ 而成为一个 judgment，这将使得 judgment 的概念失去意义。因此，我们只将那些可以被证明或推导出的断言视为 judgment，而将否定形式视为元层面的声明。

在类型理论中，"语境"（context）通常指的是一组变量和它们的类型。这些变量和类型为我们提供了一种环境或背景，我们可以在这个环境中进行推理和证明。

例如，如果我们有一个语境 $\Gamma = {x: A, y: B}$，那么我们可以在这个语境中推导出一些 judgment，如 "$x$ 是类型 $A$ 的" 或 "$y$ 是类型 $B$ 的"。这些 judgment 是在给定的语境 $\Gamma$ 下成立的。

因此，你可以把语境看作是一种前提条件。它为我们提供了一种环境，我们可以在这个环境中进行推理和证明。

---

语境（context）和签名（signature），并对它们在类型理论中的应用进行了比较。

1. 传统的语境概念已经被Ranta等人用来表示情境，但在这种表示中，变量和常量之间的区别并未被考虑。
2. 作者提出，他们考虑的是声明常量的签名，而不是声明变量的语境。他们的签名可能包含其他形式的条目，这些条目允许以灵活的方式表示复杂的情境，比如无限的情境。
3. 然而，将这些新形式的条目添加到语境中并不容易：特别是，其元理论研究相当复杂，一直是一个困难的未解问题。相反，将它们作为签名中的条目添加起来更容易。
4. 签名的概念首次在爱丁堡逻辑框架的发展中被引入到类型理论中，其签名只包含成员条目。在本节中，我们将仅使用成员条目，并在后面研究包含新形式条目的扩展签名。

简单来说，这段文字主要讨论了如何更好地在类型理论中表示和处理复杂的情境，特别是无限的情境。作者提出，使用签名（特别是包含新形式条目的签名）比使用传统的语境更为灵活和有效。

---

这段文字进一步解释了签名（signature）和上下文（context）之间的区别，以及它们在类型理论中的作用。

1. 签名（Signature）和上下文（Context）都是一系列的条目（entries），这些条目都在推理过程中起作用。然而，它们的条目类型和作用有所不同。签名中的条目（例如$c: A$）声明了$c$是类型$A$的一个常量对象，而上下文中的条目（例如$x: A$）声明了$x$是一个可以被抽象的变量，比如可以被量化。签名中声明的常量不能被抽象，这就是它们被称为常量的原因。
2. 作者认为，签名更适合于表示语言学意义上的情境（situations），而上下文则不适合。这是因为在表示情境时，我们通常关注的是特定的值（即常量），而不是可能变化的值（即变量）。
3. 在公式(2.6)中，作者给出了包含上下文和签名的判断（judgment）的一般形式。在这个形式中，签名只包含成员条目（membership entries）。这种形式的判断可以表示为：在上下文$x_{1}: A_{1}, x_{2}: A_{2}, \ldots, x_{n}: A_{n}$和签名$c_{1}: A_{1}^{\prime}, c_{2}: A_{2}^{\prime}, \ldots, c_{n}: A_{n}^{\prime}$下，$a$是类型$A$的一个对象。
4. 作者提到，他们将在后面正式介绍签名。但在这里，他们给出了一个例子，展示了如何使用只包含传统成员条目的签名来表示情境。

总的来说，这段文字主要讨论了类型理论中的两个重要概念：上下文和签名，以及它们在表示和处理情境时的作用和区别。

---

在类型理论中，依赖类型（Dependent Type）是一种类型，它的定义依赖于某个值。例如，在上述例子中，我们有一个类型家族 $C h i l d(x)$，其中 Child $(x)$ 是每个 $x : Human$ 的孩子的类型，这里的 Human 是人类的类型。然后，$\Pi x :Human.Child (x)$ 是依赖函数的类型 $f$，对于任何 $h:$ Human，$f(h)$ 是类型 Child $(h)$ - $h$ 的一个孩子。

这里的关键是，函数 $f$ 的输出类型（即 $f(a)$ 的类型 $B(a)$）依赖于输入 $a$。这就使得 $\Pi$-类型成为了依赖类型。换句话说，依赖类型允许我们根据输入的值来改变输出的类型，这在传统的函数类型中是不可能的。

$\Pi x :Human.Child (x)$ 这个表达式表示的是所有从 Human 类型到 Child 类型的依赖函数的类型。这里的 Child 类型是依赖于 Human 类型的，因为 Child(x) 的类型取决于 x 的值。

具体来说，如果你有一个函数 f，它的类型是 $\Pi x :Human.Child (x)$，那么这意味着对于任何人 h（即，对于所有 h:Human），f(h) 是 h 的一个孩子，类型为 Child(h)。换句话说，f 是一个函数，它接受一个人作为输入，并返回这个人的一个孩子作为输出。输出的类型（即孩子的类型）依赖于输入的值（即父母的身份）。

---

$$
(Abs)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B}{\Gamma \vdash_{\Delta} \lambda x: A . b: \Pi x: A . B}
$$

在这里，"Abs" 是 "Abstraction" 的缩写，表示抽象。这是 $\lambda$ 演算中的一个基本概念，用于创建匿名函数（也就是没有名字的函数）。在这个规则中，如果在增加了变量 $x: A$ 的上下文 $\Gamma$ 下，我们可以推导出 $b: B$，那么在上下文 $\Gamma$ 下，我们可以定义一个函数 $\lambda x: A . b$，其类型为 $\Pi x: A . B$。这个函数接受一个类型为 $A$ 的输入 $x$，并返回 $b$，$b$ 的类型是 $B$。

在这里，$\lambda x: A . b$ 表示一个函数，它接受一个类型为 $A$ 的输入 $x$，并返回 $b$。这是 λ-演算中的一种表示法，也被称为 λ-抽象。这个函数是匿名的，也就是说，它没有具体的名字。

$\lambda x: A . b$ 可以被理解为 "一个函数，它接受一个类型为 $A$ 的输入 $x$，并返回 $b$". 这里的 $b$ 是一个表达式，它可能依赖于 $x$。例如，如果 $b$ 是 $x + 2$，那么 $\lambda x: A . b$ 就表示一个函数，它接受一个输入 $x$，并返回 $x + 2$。

---

$$
(App)\qquad\frac{\Gamma \vdash_{\Delta} f: \Pi x: A . B\quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta} f(a):[a / x] B}
$$

在这里，"application" 是函数应用的意思。在函数式编程和 λ-演算中，函数应用是一个基本操作，表示将函数应用到一个或多个参数上。

在这个规则中，$f: \Pi x: A . B$ 是一个函数，$a: A$ 是一个参数，$f(a)$ 就是将函数 $f$ 应用到参数 $a$ 上。$[a / x] B$ 表示将 $B$ 中所有自由出现的 $x$ 替换为 $a$，这就是函数应用的结果的类型。

例如，如果我们有一个函数 $f: \Pi x: \text{Int} . \text{Int}$，表示 $f$ 是一个接受整数输入并返回整数的函数，那么如果我们有一个整数 $a: \text{Int}$，那么 $f(a)$ 就是将函数 $f$ 应用到整数 $a$ 上，结果也是一个整数。

---

$$
(\beta)\qquad\frac{\Gamma, x: A \vdash_{\Delta} b: B \quad \Gamma \vdash_{\Delta} a: A}{\Gamma \vdash_{\Delta}(\lambda x: A . b)(a)=[a / x] b:[a / x] B}
$$

这是 λ-演算中的一个基本规则，称为β-规约。β-规约描述了函数应用的行为：当一个函数 $\lambda x: A . b$ 应用于一个参数 $a$ 时，结果是将函数体 $b$ 中所有自由出现的 $x$ 替换为 $a$。

在这个规则中，$\Gamma, x: A \vdash_{\Delta} b: B$ 表示在给定 $x: A$ 的情况下，$b$ 是类型 $B$ 的一个项。$\Gamma \vdash_{\Delta} a: A$ 表示 $a$ 是类型 $A$ 的一个项。然后，规则的结论是 $(\lambda x: A . b)(a)=[a / x] b:[a / x] B$，表示将函数 $\lambda x: A . b$ 应用于 $a$ 的结果是将 $b$ 中所有自由出现的 $x$ 替换为 $a$，并且结果的类型是 $[a / x] B$，即将 $B$ 中所有自由出现的 $x$ 替换为 $a$。

例如，如果我们有一个函数 $\lambda x: \text{Int} . x + 1$，那么应用这个函数到整数 $2$ 上，即 $(\lambda x: \text{Int} . x + 1)(2)$，根据β-规约，结果是将函数体 $x + 1$ 中的 $x$ 替换为 $2$，得到 $2 + 1$，即 $3$。

---

> 请注意，如上所述，假设 $x: A$，那么lambda表达式的主体 $b$ 的类型就是 $B$ ，而 $b$ 和 $B$ 可能都依赖于 $x$（即，$x$ 可能在它们中出现自由）- 这就是类型依赖。关于 $\Pi$ 类型的上述推理规则也可以在附录A2.1中找到。

在计算机科学和数学中，"free" 是一个术语，用来描述在某个表达式或公式中的变量，这些变量没有被绑定到特定的值或表达式。在这个上下文中，如果 $x$ 在 $b$ 或 $B$ 中自由出现，那么意味着 $x$ 在 $b$ 或 $B$ 中的出现并没有被某个特定的值或表达式所绑定。

例如，考虑一个函数定义 $\lambda x . x + y$。在这个函数体中，$x$ 是一个绑定变量，因为它被 $\lambda$ 表达式所绑定。然而，$y$ 是一个自由变量，因为它在函数体中出现，但并没有被绑定到任何特定的值。这就意味着，如果我们想要计算这个函数的值，我们需要知道 $y$ 的值。

在这个段落中，当说 $b$ 和 $B$ 可能依赖于 $x$ 时，意思是 $x$ 可能在 $b$ 或 $B$ 中自由出现，即 $b$ 或 $B$ 的值可能取决于 $x$ 的值。

---

> To explain in terms of the above example, when a function $f$ of type $\Pi x$ : Human. Child $(x)$ ) (or, $\Pi$ (Human, Child) in another notation) is applied to a human $h$, its image $f(h)$ has to be a child of $h$, i.e. of type Child $(h)$, not something else.

在这个上下文中，"image" 是数学术语，指的是函数作用于其定义域中的元素后得到的结果。换句话说，如果你有一个函数 $f$，并且你将它应用于某个元素 $x$，那么 $f(x)$ 就是 $x$ 在函数 $f$ 下的像（image）。这个术语来自于函数映射的概念，即函数将其定义域中的每个元素 "映射" 到其值域中的某个元素。

在你提供的这段文本中，当函数 $f$（类型为 $\Pi x$ : Human. Child $(x)$）应用于一个人 $h$ 时，它的像 $f(h)$ 必须是 $h$ 的一个孩子，即类型为 Child $(h)$，而不是其他的什么。

---

> 非依赖对的平庸乘积类型 $A \times B$ 是依赖的 $\Sigma$ 类型的一个特例。例如，如果 $Woman$ 是女性的类型，那么乘积类型 $Man\times Woman$ 就是普通对 $(m, w)$ 的类型，使得 $m: M a n$ 和 $w: W o m a n$。乘积类型 $Man \times Woman$ 与 $\Sigma$ 类型 $\Sigma x: Man. W(x)$ 是相同的，其中类型的常数族 $W(x)= Woman$。

"Ordinary product"在这里指的是非依赖性的乘积类型。在类型理论中，乘积类型（也称为元组类型或对类型）是一种复合类型，它的值是两个类型值的对。例如，如果A和B是类型，那么A×B就是乘积类型，它的值是形如(a, b)的对，其中a是A的值，b是B的值。

当我们说"ordinary product"时，我们是在区分它和依赖性乘积类型（在这个上下文中，是Σ类型）。依赖性乘积类型是一种更一般的乘积类型，它的第二个组成部分可以依赖于第一个组成部分的值。在你的例子中，Σx: Man. W(x)就是一个依赖性乘积类型，因为W(x)（即Woman）是依赖于x的类型。

所以，当我们说Man × Woman是一个"ordinary product"时，我们的意思是，它是一个非依赖性的乘积类型，它的值是形如(m, w)的对，其中m是Man的值，w是Woman的值，而且w的类型（Woman）并不依赖于m的值。

"Constant family"是指一个类型族，其中每个类型都是相同的，不依赖于索引。在类型理论中，类型族是一种类型的集合，其中每个类型都与一个或多个索引值相关联。例如，我们可以有一个类型族，其中每个自然数n都有一个对应的类型，如"长度为n的整数列表"。

然而，如果我们有一个"constant family"，那么每个索引值都关联到相同的类型。在你的例子中，"W(x) = Woman"就是一个常数族，因为无论x的值是什么（在这种情况下，x是Man的一个值），W(x)的类型都是Woman。换句话说，这个类型族是"常数的"，因为它不依赖于索引x。

---

> In general, $\Sigma$-types can be regarded as types of tuples since their formation can be nested. A nested $\Sigma$-type $\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$ can be written by means of the following notation and, intuitively, its objects are $n$-tuples of terms of the respective types.  $\left\{\begin{array}{lll} x_{1} & : & A_{1} \\ x_{2} & : & A_{2} \\ \cdots & & \\ x_{n} & : & A_{n} \end{array}\right\}$

在这个例子中，$\Sigma$-类型被视为元组的类型，因为它们的形成可以是嵌套的。这里的嵌套$\Sigma$-类型$\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$可以被写成这样的形式，直观上，它的对象是各自类型的$n$元组。

这个表示法的意思是，我们有一个$n$元组，其中每个元素$x_i$都有一个对应的类型$A_i$。这个表示法省略了$\Sigma$符号，因为它的目的是强调这个类型的元素是元组，而不是强调这个类型是通过$\Sigma$类型构造的。

在这个表示法中，$\Sigma$符号被省略了，因为这个表示法的目的是强调元组的结构，而不是$\Sigma$类型的结构。这个表示法是一种方便的方式，用来描述一个类型的元素是如何组织成元组的。

这个嵌套的$\Sigma$-类型$\Sigma x_{1}: A_{1} \Sigma x_{2}: A_{2} \ldots \Sigma x_{n-1}: A_{n-1} . A_{n}$可以被视为元组$(x_1, (x_2, ..., (x_{n-1}, x_n)...))$的类型，其中每个$x_i$都有对应的类型$A_i$。这种表示方式强调了元组的结构，即元素的顺序和层级关系。

---

> Note that Prop is an impredicative universe because we can quantify over Prop itself (or even "larger" types) to form logical propositions in Prop. For example, $\forall X$ : Prop. $X$ is of type Prop and, in fact, this proposition can serve as the false formula since it intuitively means that every proposition is provable (and by logical consistency, this is not the case and, hence, the formula is not provable).

括号中的注释是在解释为什么公式 $\forall X : Prop$ . $X$ 可以被视为 "假" 公式。这个公式的意思是 "对于所有的命题 X，X 是可证明的"。然而，根据逻辑一致性原则，我们知道并非所有的命题都是可证明的。有些命题是假的，因此不能被证明。因此，公式 $\forall X$ : Prop. $X$ 本身就是不可证明的，因此可以被视为 "假" 公式。

---

> REMARK.- As the reader may have noticed, the universally quantified proposition $\forall x: A . P(x)$ is very similar to a П-type. Their difference is that $\forall$-formation can be impredicative, while $\Pi$-formation is always predicative in the sense that we cannot use $\Pi$ for impredicative quantification. In some type theories, one actually overloads $\Pi$ to allow it to express $\forall$ as well: that is, in those type theories such as ECC (Luo 1994) and Coq's type theory (Coq 2010), $\forall x: A . P(x)$ is also written as $\Pi x: A . P(x)$.

这段话主要在讨论全称量词 $\forall$ 和 Π 类型之间的相似性和差异。

首先，作者指出全称量词 $\forall x: A . P(x)$ 和 Π 类型在形式上非常相似。这两者都表示了对于所有的 $x$ 属于类型 $A$，有某个性质 $P(x)$ 成立。

然后，作者指出这两者的主要区别在于，全称量词 $\forall$ 可以是不可约化的（impredicative），而 Π 类型则总是可约化的（predicative）。这里的 "可约化" 和 "不可约化" 是指在定义类型或性质时，是否可以引用到包含自身的更大的类型或集合。如果可以，那么就是不可约化的；如果不可以，那么就是可约化的。

最后，作者提到在一些类型理论中，例如 ECC（Luo 1994）和 Coq 的类型理论（Coq 2010），允许使用 Π 来表示全称量词 $\forall$。也就是说，这些理论中的 $\forall x: A . P(x)$ 也可以写作 $\Pi x: A . P(x)$。这种情况下，Π 类型被 "重载" 了，它既可以表示 Π 类型，也可以表示全称量词。

"可约化"（predicative）和"不可约化"（impredicative）是逻辑和类型理论中的概念，主要用来描述定义的自指性质。

在可约化（predicative）的定义中，我们不能引用到包含定义自身的更大的类型或集合。例如，我们可以定义一个集合，它包含所有的自然数。这个定义是可约化的，因为在定义这个集合时，我们并没有引用到包含这个集合本身的更大的集合。

相反，在不可约化（impredicative）的定义中，我们可以引用到包含定义自身的更大的类型或集合。例如，我们定义一个集合，它包含所有不包含自身的集合。这个定义是不可约化的，因为在定义这个集合时，我们引用了包含这个集合本身的更大的集合（即所有的集合）。

这个概念在类型理论和逻辑中非常重要，因为它关系到定义的合理性和一致性。在某些类型理论和逻辑系统中，不可约化的定义可能会导致悖论，因此被禁止。

---

> Each universe $U_{i}$ contains names of the types in the universe and $T_{i}$ is the function that maps a name to the named type. For instance, for each $U_{i}$, we introduce a name $u_{i}$ in $U_{i+1}$ and $u_{i}$ is a name of $U_{i}$ because $T_{i+1}\left(u_{i}\right)=U_{i}$. Furthermore, (a name of) each type in $U_{i}$ is lifted to the higher universe $U_{i+1}$ by introducing lifting operators $t_{i+1}(i \in \omega)$

在类型理论中，"宇宙"（Universe）是一种特殊的类型，它的成员本身也是类型。这种结构允许我们在类型理论中谈论和操作类型。这是一种处理类型的元理论（metatheory）问题的方式，比如允许我们定义取决于类型的函数。

在你引用的段落中，每个宇宙 $U_{i}$ 包含了它所包含的类型的名称，而 $T_{i}$ 是一个函数，它将一个名称映射到被命名的类型。例如，对于每个 $U_{i}$，我们在 $U_{i+1}$ 中引入一个名称 $u_{i}$，并且 $u_{i}$ 是 $U_{i}$ 的一个名称，因为 $T_{i+1}(u_{i}) = U_{i}$。此外，$U_{i}$ 中每个类型的名称都被提升到更高的宇宙 $U_{i+1}$，通过引入提升操作符 $t_{i+1}(i \in \omega)$。

这里的 "提升" 是指将类型从一个宇宙转移到另一个更大的宇宙。这是一种处理类型的层次结构的方式，允许我们在不同的 "级别" 上操作类型。

---

> 在签名中可以声明强制子类型化条目。正式来说，系统 $\mathrm{LF}_{\Delta}$ 通过子类型化的断言形式 $\Gamma \vdash_{\Delta} A \leq_{\kappa} B:\text{Type}$ 和子类型化 $\Gamma \vdash_{\Delta} K \leq_{\kappa} K^{\prime}$ 进行了扩展。通过以下规则，可以在签名中引入子类型化条目：
> $$
> \frac{\vdash_{\Delta} A: \text { Type }\quad \vdash_{\Delta} B: \text { Type }\quad \vdash_{\Delta} \kappa:(A) B}{\Delta, A \leq_{\kappa} B\ \text{ valid}}
> $$
> 在签名中假定的子类型关系是可推导的，如以下规则所反映：
> $$
> \frac{\vdash_{\Delta, A\leq_{\kappa} B, \Delta^{\prime}} \Gamma}{\Gamma \vdash_{\Delta, A \leq_{\kappa} B, \Delta^{\prime}} A \leq_{\kappa} B: \text{Type}}
> $$
> 那么，虽然扩展了带有签名的断言，但是强制子类型化的规则（Luo等人，2012）都是适用的。例如，如果在签名 $\Delta$ 下，可以证明 $A \leq_{\kappa} B$ 和 $B \leq_{\kappa^{\prime}} C$ ，那么我们就可以推导出在 $\Delta$ 下$A \leq_{\kappa^{\prime} \circ \kappa} C$，其中 $\kappa^{\prime} \circ \kappa$ 是 $\kappa$ 和 $\kappa^{\prime}$ 的函数组合[functional composition]。

在数学中，"函数组合"（function composition）是一种操作，它将两个函数连接在一起，形成一个新的函数。给定两个函数 $\kappa$ 和 $\kappa^{\prime}$，它们的组合 $\kappa^{\prime} \circ \kappa$ 是一个新的函数，这个新函数首先应用函数 $\kappa$，然后将结果输入到函数 $\kappa^{\prime}$ 中。

在这个上下文中，$\kappa$ 和 $\kappa^{\prime}$ 是类型转换函数，它们描述了如何从一个类型转换到另一个类型。函数组合 $\kappa^{\prime} \circ \kappa$ 描述了一个复合的类型转换：首先应用 $\kappa$，然后应用 $\kappa^{\prime}$。

例如，假设我们有两个类型转换函数 $\kappa$ 和 $\kappa^{\prime}$，其中 $\kappa$ 将类型 A 转换为类型 B，$\kappa^{\prime}$ 将类型 B 转换为类型 C。那么，函数组合 $\kappa^{\prime} \circ \kappa$ 将描述一个从类型 A 直接转换到类型 C 的过程。

---

> 同样，量词也可以通过在宇宙 $\mathsf{CN}$ 上的 $\Pi$ 多态性进行类型化。以一个简单的例子来说，量词"some"可能通过逻辑量词 $\exists$ 在(3.12)中定义，以 $\mathsf{CN}$ 作为其限定的域，其类型化为(3.13)，如表3.1所示，即与可以应用到任何类型的逻辑量词 $\exists$ 不同，"some"只能解释 $\mathrm{CN}$ 。
>
> (3.12) $\text{some} =\lambda A: \mathsf{CN}\ \lambda P: A \rightarrow Prop. \exists(A, P)$
>
> (3.13) $\text{some} : \Pi A : \mathsf{CN}. (A \rightarrow \operatorname{Prop}) \rightarrow \operatorname{Prop}$

在这个例子中，"some" 被定义为一个函数，这个函数接受两个参数：一个类型 A（在这里，A 是 CN，表示一类事物，如 "man" 或 "table"）和一个谓词 P（这是一个从 A 到 Prop 的函数，表示 A 的某种属性或条件）。

这个函数的定义是通过 lambda 表达式给出的，这是一种在函数式编程中常用的表示匿名函数（即没有名字的函数）的方式。在这个表达式中，"λA: CN" 表示 "对于所有的类型 A 在 CN 中"，"λP: A -> Prop" 表示 "对于所有的谓词 P，它是一个从 A 到 Prop 的函数"。

然后，"∃(A, P)" 表示存在一个 A 类型的对象，它满足谓词 P。所以，整个表达式的意思是 "对于所有的类型 A 和所有的谓词 P，存在一个 A 类型的对象满足 P"，这就是 "some" 的含义：存在某种类型的对象满足某种条件。

在 (3.13) 中，"some" 的类型是 "对于所有的类型 A，从 A 到 Prop 的函数到 Prop"，这表示 "some" 是一个函数，它接受一个类型 A 和一个从 A 到 Prop 的函数，然后返回一个 Prop。这就是说，"some" 是一个量词，它可以应用于一个类型和一个谓词，然后返回一个命题。