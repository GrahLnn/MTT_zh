# MTT 注

"Judgment"在类型理论中通常指的是一个形式系统中的基本断言或声明，这些断言或声明不能被证明或推导，而是被视为基本的、自明的真理。例如，我们可能会有一个"judgment"，声明某个表达式是某个类型的成员。

而"assertion"通常指的是一个可以被证明或推导的声明。在一个形式系统中，我们可以从一组基本的"judgments"出发，通过应用一系列推理规则来得到新的"assertions"。

---

在语言学中，"coordination"（协同或并列）是一种句法关系，其中两个或更多的词、短语或句子被并列在一起，通常通过并列连词（如"and"、"or"和"but"）连接。例如，在句子"Bob and Alice are friends"中，"Bob"和"Alice"就是通过并列关系连接在一起的。

---

"Many-sorted"和"multi-sorted"在逻辑和计算机科学中通常是同义词，都用来描述一个包含多种类型或类别的对象的系统或领域。这两个术语在英语中都被用来描述这种概念，选择哪个术语主要取决于个人偏好或特定的学术或技术传统。

---

"多元排序域"（multi-sorted domain）是逻辑和语义学中的一个概念，用于描述一个包含多种不同类型或"排序"的对象的集合。在这个上下文中，"排序"可以被理解为对象的种类或类型。

例如，我们可以考虑一个多元排序的领域，其中包含人、动物和物体。在这个领域中，"人"、"动物"和"物体"都是不同的排序，每种排序都有其特定的结构属性。

在语言学的语义研究中，多元排序的系统或领域被用来模拟和理解语言如何引用和处理不同类型的对象。例如，一个句子可能会引用一个人（"John"），一个动物（"the cat"）和一个物体（"the chair"），这些都是多元排序领域中的不同排序。

---

一个系统（如一个类型系统或一个编程语言）如果满足强正规化性质，那么它的所有表达式都会在有限步骤内规约到一个正规形式，也就是说，它们都会在有限时间内"完成计算"。这是一个非常重要的性质，因为它保证了系统的计算不会无限制地进行下去。

---

在类型理论中，"membership entries"通常指的是签名（signature）中的元素，这些元素声明了某个变量属于某个特定的类型。例如，一个membership entry可能是形式为"x: A"的声明，这表示变量x是类型A的成员。

在这段文本中，作者提到他们将介绍一种新的签名，这种签名不仅包含常规的membership entries，还包含两种新形式的条目：子类型条目和manifest条目。这些新形式的条目增强了签名在表示（不完全的）可能世界中的能力，即使在情况无限或涉及更复杂现象的情况下。

总的来说，membership entries是类型理论中用于描述变量和其类型关系的一种工具，它们是定义类型系统结构的关键部分。

---

"notion of signatures"可能是指在类型理论中的一个概念，用于描述类型系统的结构。在类型理论中，一个签名（signature）定义了一组类型和操作，以及这些操作在给定类型上的行为。

例如，一个签名可能会定义一个数字类型，以及一些在数字上进行的操作，如加法和乘法。这个签名会规定加法和乘法的类型，例如，它们接受两个数字作为输入，并返回一个数字作为输出。

---

在语义学和哲学中，"可能世界"是一种理论工具，用于描述和分析语句的可能性和必然性。一个可能的世界就是一种可能的现实，一种事情可能发生的方式。例如，有一个可能的世界，在那里你正在阅读这个句子；有另一个可能的世界，你没有阅读这个句子。

当我们说一个"不完全的可能世界"时，我们是指一个可能的世界，其中并非所有的事实都被明确指定。换句话说，这是一个部分指定的可能世界，其中一些事实是确定的，而其他事实则是开放的。

"可能世界"的概念主要用于逻辑和语义学，用于分析语句的可能性和必然性。一个可能的世界是一种可能的现实，一种事情可能发生的方式。

相反，"平行世界"或"多元宇宙"的概念主要在物理学和科幻文学中使用，用于描述可能存在的其他宇宙或现实，这些宇宙或现实与我们的宇宙并行存在，但可能有不同的物理定律或历史。

---

"Logical modal collection operator"在这里可能是指在类型理论中用于处理非承诺修饰（non-committal modification）的一种操作符。在语义学中，非承诺修饰是一种修饰方式，其中修饰词并不确切地改变名词的含义，而是提供了一种可能的解释或视角。

例如，考虑句子"可能的赢家"。在这里，"可能的"是一个非承诺修饰词，因为它并没有改变"赢家"的基本含义，而是提供了一种可能的解释或视角。

在类型理论中，这种修饰可能通过引入一个逻辑模态集合操作符来处理。这个操作符可能会创建一个新的类型，该类型表示所有可能满足修饰词条件的实体的集合。然后，这个新类型可以用于进一步的语义构造。

---

1. **证明论规则的应用**：MTT是通过证明论规则来定义的。证明论是一种逻辑学分支，它关注的是逻辑推理的形式，而不仅仅是逻辑语句的真假。因此，MTT可以通过其推理使用方式在证明论的意义上理解其判断（句子）。
2. **基础语义语言的理解**：MTT提供了一种新的可能性，即我们可以通过其证明论的含义理论来理解MTT作为基础语义语言。这是之前的集合论语义无法做到的。
3. **计算机实现**：由于MTT是基于证明论定义的，因此它们可以轻松地在计算机上实现，以支持自然语言中的计算机辅助推理。这得到了基于MTT的证明助手提供的当前证明技术的支持。
4. **自然语言推理任务**：作者提到，他们将描述如何在计算机上实现MTT语义以执行自然语言中的推理任务。这意味着MTT可以用于处理和理解自然语言，这对于计算语言学和人工智能领域非常重要。

---

这些公式来自于类型理论，它们是用来定义一个有效的类型环境（也称为上下文）的规则。类型环境是一个变量到类型的映射，它为类型检查和类型推导提供了必要的上下文。

这里有三个规则：

1. **空规则**：空序列（表示为`⟨⟩`）是一个有效的类型环境。这是最基本的规则，表示没有任何变量的情况是有效的。
2. **变量添加规则**：如果在类型环境`Γ`中，`A`是一个类型，并且变量`x`不在`Γ`的自由变量集合`FV(Γ)`中，那么在`Γ`中添加一个新的变量到类型的映射`x: A`是有效的。这个规则表示，我们可以在类型环境中添加新的变量，只要这个变量之前没有被使用过。
3. **命题添加规则**：如果在类型环境`Γ`中，`P`是一个命题并且它是真的（表示为`t`），那么在`Γ`中添加一个新的命题`P`是有效的。这个规则表示，我们可以在类型环境中添加新的真命题。

`FV(Γ)`是`Γ`中的自由变量集合，它有三个定义：

1. `FV(⟨⟩) = ∅`：空序列的自由变量集合是空集。
2. `FV(Γ, x: A) = FV(Γ) ∪ {x}`：如果在类型环境`Γ`中添加一个新的变量到类型的映射`x: A`，那么新的自由变量集合是原来的自由变量集合加上新的变量`x`。
3. `FV(Γ, P true) = FV(Γ)`：如果在类型环境`Γ`中添加一个新的真命题`P`，那么自由变量集合不变。

这些规则和定义是类型理论中的基础概念，它们用于定义和操作类型环境，以进行类型检查和类型推导。

---

在蒙塔古语义学中，`talk: e -> t`是一个函数的类型签名，它表示`talk`是一个从实体（`e`）到真值（`t`）的函数。

这里的`e`代表实体类型，通常用来表示自然语言中的名词或名词短语，如人、地点或事物。`t`代表真值类型，通常用来表示一个陈述的真假。

因此，`talk: e -> t`可以理解为一个描述某个实体是否在"talk"（谈话）的函数。例如，如果我们有一个实体`John`，那么`talk(John)`就会返回一个真值，表示John是否在谈话。这是蒙塔古语义学用来描述自然语言中动词的一种方式。

---

$$
\exists x: \mathbf{e} . \operatorname{man}(x) \wedge \operatorname{talk}(x)
$$

这个表达式来自于逻辑和类型理论，它表示的是一个存在量化的陈述。

`∃x: e . man(x) ∧ talk(x)`可以被理解为："存在一个实体`x`，使得`x`是一个人（`man(x)`）并且`x`正在谈话（`talk(x)`）"。

这里的`∃x: e`是一个存在量词，表示存在一个类型为`e`（实体）的`x`。`.`之后的部分是这个`x`需要满足的条件，即`x`是一个人并且`x`正在谈话。`∧`是逻辑与操作符，表示两个条件都需要满足。

这种表达方式常常用于形式语义学和逻辑编程中，用来精确地描述复杂的自然语言陈述。

在逻辑和类型理论中，`.`通常被用作分隔符，用来分隔量词（如`∃x: e`）和量词作用的范围（如`man(x) ∧ talk(x)`）。

所以，`∃x: e . man(x) ∧ talk(x)`应该被理解为："存在一个类型为`e`的`x`，使得`man(x) ∧ talk(x)`成立"。

---

|                          | Type in Montague semantics         | Type in MTT-semantics    |
| ------------------------ | ---------------------------------- | ------------------------ |
| $\text{j}$               | $\mathbf{e}$                       | $Human$                  |
| $\text{talk}$            | $\mathbf{e}\rightarrow \mathbf{t}$ | $Human \rightarrow Prop$ |
| $\operatorname{talk}(j)$ | $\mathbf{t}$                       | $Prop$                   |

这个表格展示了Montague语义学和MTT语义学中的类型对应关系。具体来说，它展示了如何在两种不同的语义框架中表示相同的概念。

1. **j**：在Montague语义学中，`j`被视为一个实体（`e`），而在MTT语义学中，`j`被更具体地视为一个人（Human）。
2. **talk**：在Montague语义学中，`talk`被视为一个从实体到真值的函数（`e -> t`），表示某个实体是否在谈话。而在MTT语义学中，`talk`被视为一个从人到命题的函数（Human -> Prop），表示某个人是否在谈话。
3. **talk(j)**：在Montague语义学中，`talk(j)`是一个真值（`t`），表示实体`j`是否在谈话。而在MTT语义学中，`talk(j)`是一个命题（Prop），表示人`j`是否在谈话。

---

- In MTT-semantics, the sentence (1.7) is interpreted as the proposition $\operatorname{talk}(j)$ : Prop where Prop is the type of all logical propositions - an internal totality that only exists in impredicative type theories such as UTT. 13

"Internal totality"在类型理论中是一个特定的概念，它指的是一个类型的所有可能的值或实例都可以在类型理论的框架内部被明确地定义和处理。这与"external totality"形成对比，后者指的是类型的值或实例可能需要依赖于类型理论框架之外的一些结构或信息。

在你引用的这句话中，"internal totality"是用来描述类型Prop的。Prop是所有逻辑命题的类型，在不可约谓词的类型理论（如UTT）中，它是一个"internal totality"，因为所有的逻辑命题都可以在类型理论的框架内部被定义和处理。

这个概念是理解类型理论，特别是像UTT这样的不可约谓词类型理论的关键。在这样的理论中，所有的类型和值都是"内部的"，这意味着它们都可以在理论的框架内部被完全定义和处理，而不需要依赖于任何外部的结构或信息。

---

In predicative MTTs such as Martin-Löf's type theory, one would use a predicative universe which is only a type of some propositions, not all of them. Although we may relate Prop to the type $\mathbf{t}$ of truth values in Church's simple type theory, they have subtle differences. The differences between MTTs and Church's simple type theory include whether the theory is classical or constructive and whether there are proof objects, among others. These are beyond the scope of our discussions here.

这段话主要在讨论不同类型理论之间的一些区别和细微差异。

1. 在像Martin-Löf类型理论这样的可归谓词MTTs（Modern Type Theories）中，人们会使用一个可归谓词宇宙，它只包含一些命题的类型，而不是所有命题。这与不可归谓词类型理论（如UTT）中的Prop类型有所不同，后者包含所有逻辑命题的类型。
2. 尽管我们可能会将Prop类型与Church简单类型理论中的真值类型`t`相关联，但它们之间存在微妙的差异。例如，MTTs和Church的简单类型理论之间的差异包括理论是经典的还是构造性的，以及是否存在证明对象等。
3. 这些差异超出了这里讨论的范围。也就是说，这些差异的详细讨论和理解可能需要更深入的类型理论知识和背景。

这段话在强调类型理论的多样性和复杂性，以及理解和使用不同类型理论可能需要注意的一些关键区别和细节。

---

"可归谓词"（predicative）和"不可归谓词"（impredicative）是逻辑和数学中用来描述定义或构造的两个术语。

1. **可归谓词**：如果一个定义或构造是可归谓词的，那么它不依赖于自身或更大的整体。换句话说，它的定义是自下而上的，只依赖于已经定义的元素。例如，我们可以定义一个集合是由具有某种性质的所有自然数组成的，这个定义是可归谓词的，因为它只依赖于已经定义的自然数。
2. **不可归谓词**：如果一个定义或构造是不可归谓词的，那么它可能依赖于自身或更大的整体。换句话说，它的定义可能是自上而下的，可能依赖于尚未完全定义的元素。例如，我们可能定义一个集合是由所有不包含自身的集合组成的，这个定义是不可归谓词的，因为它依赖于尚未完全定义的集合。

在类型理论中，这两个概念通常用来描述类型或构造的定义方式。例如，Martin-Löf的类型理论是可归谓词的，因为每个类型都是由更基本的类型构造的。而某些类型理论（如Coq中的类型理论）允许不可归谓词的构造，这使得它们能够表达更复杂的概念，但也可能导致一些逻辑和计算上的困难。

---

在自然语言处理和语言学中，"IV"通常是"Intransitive Verb"的缩写，指的是不需要直接宾语的动词。例如，"talk"、"run"、"sleep"等都是不及物动词，因为你可以只说"he talks"或"she runs"，而不需要添加直接宾语。这与及物动词（Transitive Verb，TV）相对，及物动词需要一个直接宾语，例如"eat"（你不能只说"he eats"，而需要说"he eats an apple"）。

---

A verb (IV) or an adjective (ADJ) can be interpreted as a predicate over a type $D$ that interprets the domain of the verb or adjective, i.e. a function of type $D \rightarrow$ Prop.

这句话的意思是，在现代类型理论（MTT）的语义中，一个动词（Intransitive Verb，IV）或形容词（Adjective，ADJ）可以被解释为一个谓词，这个谓词作用于一个类型D。这个类型D解释了动词或形容词的领域，也就是说，这个谓词是一个类型为"D -> Prop"的函数。

在这里，"D"是一个抽象的类型，它代表了动词或形容词的领域。例如，对于动词"run"，D可能是"Human"，因为"run"的领域是人；对于形容词"red"，D可能是"Object"，因为任何对象都可能是红色的。

所以，这个函数"D -> Prop"的意思是，给定一个类型为D的对象（例如一个人或一个物体），这个函数会返回一个命题（Prop），这个命题表示这个对象是否具有由动词或形容词表示的性质（例如是否在跑，或者是否是红色的）。

---

Modified common nouns (modified $\mathrm{CN}$ ), when the adjectives are intersective, can be interpreted by means of $\Sigma$-types of pairs.

"Modified common nouns"（被修饰的普通名词）是指由形容词、副词或短语修饰的名词。例如，在"red apple"、"quickly running man"或"book on the table"中，"apple"、"man"和"book"都是被修饰的普通名词。

在现代类型理论（MTT）的语义中，当形容词是交集性的（即，形容词描述的性质可以同时应用于多个对象，如"red"、"big"等），被修饰的普通名词可以通过Σ-types来解释。Σ-types，也称为依赖对类型或存在类型，是一种可以表示对象和该对象的性质的配对的类型。例如，Σm: Man. handsome (m)表示的是所有满足"handsome"性质的人的集合。

---

"Dynamic entailment"是动态语义学中的一个概念。在传统的逻辑系统中，"entailment"（蕴含）是一个基本的关系，表示一个命题（或一组命题）的真实性必然导致另一个命题的真实性。例如，在经典逻辑中，如果我们知道"P implies Q"（P蕴含Q）是真的，而且P是真的，那么我们就可以得出Q是真的。

然而，在动态语义学中，这种蕴含关系被重新定义为"dynamic entailment"。在动态蕴含关系中，一个命题的真实性可能会影响到其他命题的解释或真实性。这是因为在动态语义学中，语句的解释不仅取决于当前的语境，还取决于之前的语境和语句。因此，一个语句的真实性可能会改变语境，从而影响到后续语句的解释。

例如，考虑这样一个例子："John walks into a room. He sees a cat." 在这个例子中，第二句"He sees a cat"的解释依赖于第一句"John walks into a room"的解释，因为"he"指代的是"John"。这就是一个动态蕴含的例子：第一句的真实性影响到了第二句的解释。

然而，动态蕴含关系并不满足一些传统蕴含关系的性质，例如反身性（如果P是真的，那么P蕴含P）和传递性（如果P蕴含Q，Q蕴含R，那么P蕴含R）。这是因为在动态语义学中，语境的改变可能会影响到蕴含关系。

---

"Strong"和"Weak"量词是语义学中的概念，用来描述量词的不同类型。

1. "Strong"量词：这类量词在逻辑上有更强的限制性。例如，"all"、"every"、"each"、"none"等都是强量词。当我们说"All dogs bark"时，这个句子的真实性要求每一只狗都会叫。如果存在一只不会叫的狗，那么这个句子就是假的。
2. "Weak"量词：这类量词在逻辑上的限制性较弱。例如，"some"、"a few"、"several"等都是弱量词。当我们说"Some dogs bark"时，这个句子的真实性只要求存在至少一只会叫的狗。即使有很多狗不会叫，只要有一只会叫，这个句子就是真的。

在现代类型理论（MTT）的语义中，强量词和弱量词可以通过不同的方式来解释。例如，强量词可以通过全称量词（∀）来解释，而弱量词可以通过存在量词（∃）或Σ-types来解释。

---

在类型理论中，"type theory with records"（具有记录的类型理论）是一种扩展了基本类型理论的形式，引入了记录类型作为一种新的数据结构。

记录类型允许我们将多个字段组合在一起，以创建复杂的数据结构。每个字段都有一个标签（label）和一个对应的类型。通过使用记录类型，我们可以定义和操作具有不同字段的数据，类似于在编程语言中使用结构体或对象。

在记录类型中，可以进行以下操作：

1. 定义记录类型：通过指定字段的标签和类型，可以定义一个记录类型。例如，可以定义一个人的记录类型，其中包含姓名、年龄和地址字段。
2. 创建记录：可以创建一个具体的记录，为每个字段指定相应的值。例如，可以创建一个名为"John"、年龄为25岁、地址为"123 Main St"的人的记录。
3. 访问记录字段：可以使用字段的标签来访问记录中的特定字段的值。例如，可以通过记录类型中定义的标签"age"来访问人的记录中的年龄字段的值。
4. 更新记录字段：可以通过指定字段的标签和新值来更新记录中的特定字段的值。例如，可以更新人的记录中的地址字段的值为"456 Elm St"。

类型理论中的记录类型提供了一种灵活和强大的数据建模方式，可以用于表示和操作具有复杂结构的数据。它们在编程语言、数据库和形式化验证等领域中都有广泛的应用。

---

It is important to note that a judgment is not a formula in the ordinary sense of logic. In particular, we cannot apply logical operators such as negation and conjunction to judgments. For instance, if we negated the judgment (2.1), the result would not be a judgment anymore: the "negation" of (2.1), often written as $\Gamma \nvdash_{\Delta} a: A$, is not a judgment, but only a meta-level statement saying that the judgment (2.1) is incorrect (or, in a formal jargon, (2.1) is non-derivable). (See section 3.2.3 for further discussions in this respect.) (2.1) $\Gamma \vdash_{\Delta} a: A$

"Non-derivable"在这个上下文中，是指一个判断或公式不能从已知的规则或假设中推导出来。在形式逻辑中，如果一个判断是"derivable"，那么意味着我们可以通过一系列的推理步骤，从一组基本的假设或规则出发，得到这个判断。相反，如果一个判断是"non-derivable"，那么就意味着我们无法通过这样的推理步骤得到它。

在你引用的这段文本中，作者提到，如果我们对判断（2.1）进行否定，那么结果将不再是一个判断：（2.1）的"否定"，通常写作$\Gamma \nvdash_{\Delta} a: A$，不是一个判断，而只是一个元层面的声明，表示判断（2.1）是不正确的（或者用形式术语来说，（2.1）是"non-derivable"的）。这意味着我们不能从已知的规则或假设中推导出判断（2.1）。

在这个上下文中，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个元层面（meta-level）的声明。这个声明表示，我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$。也就是说，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个 judgment，而是一个对 judgment $\Gamma \vdash_{\Delta} a: A$ 的否定或反驳。

这里的关键是，judgment 是类型理论中的基本断言或声明，而我们不能对这些基本断言应用逻辑运算符，如否定和合取。因此，$\Gamma \nvdash_{\Delta} a: A$ 并不是一个新的 judgment，而是一个元层面的声明，表示我们不能从已知的规则或假设中推导出原来的 judgment。

在形式逻辑和类型理论中，$\vdash$ 符号通常用来表示"可推导"或"可证明"。例如，$\Gamma \vdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们可以推导出 $a$ 是类型 $A$ 的。

当我们在 $\vdash$ 符号前加上否定符号 $\nvdash$，这就变成了表示"不可推导"或"不可证明"的符号。因此，$\Gamma \nvdash_{\Delta} a: A$ 表示在给定的语境 $\Gamma$ 和签名 $\Delta$ 下，我们不能推导出 $a$ 是类型 $A$ 的。

这就是为什么 $\Gamma \nvdash_{\Delta} a: A$ 这个声明表示我们不能从已知的规则或假设中推导出 judgment $\Gamma \vdash_{\Delta} a: A$ 的原因。这是对原始判断的否定，但这个否定本身并不构成一个新的判断，而是一个元层面的声明。

> 因为一个judgment必须使用 $\vdash$才是judgment，而当变成否定形式后则不是一个judgment，而只能是一种声明，如果将否定形式也当作judgment那么任意一种非当前$\Gamma$都能因为$\nvdash$而成为一个judgment，那么judgment就没意义了对吗

是的，你的理解是正确的。在类型理论中，judgment 是一种基本的断言或声明，它描述了某种事实或关系，如 "$a$ 是类型 $A$ 的"。这些断言是可以被证明或推导出的，这就是为什么我们使用 $\vdash$ 符号来表示它们。

当我们对一个 judgment 进行否定，我们实际上是在说这个 judgment 是不正确的，或者说我们不能从已知的规则或假设中推导出这个 judgment。这种否定本身并不构成一个新的 judgment，因为它并不描述一个可以被证明或推导出的事实或关系。相反，那它是一个元层面的声明，表示我们不能证明或推导出原来的 judgment。

如果我们允许否定形式也成为 judgment，那么我们就会面临你所描述的问题：任何非当前的 $\Gamma$ 都可以因为 $\nvdash$ 而成为一个 judgment，这将使得 judgment 的概念失去意义。因此，我们只将那些可以被证明或推导出的断言视为 judgment，而将否定形式视为元层面的声明。